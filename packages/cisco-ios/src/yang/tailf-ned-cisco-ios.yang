// =========================================================================
//                          CISCO-IOS NED
// =========================================================================

module tailf-ned-cisco-ios {
  namespace "urn:ios";
  prefix ios;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }


  // =========================================================================
  // REVISION
  // =========================================================================

  revision 2017-03-17 {
    description
      "5.0.14
      See CHANGES.
      ";
  }


  // =========================================================================
  // TYPEDEF
  // =========================================================================


  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  // IPv4 prefix (address and mask length) in A.B.C.D/P format
  typedef ipv4-prefix {
    type tailf:ipv4-address-and-prefix-length;
  }

  // IPv6 prefix
  // Handles expanded IPv6 address format as well as any mixture
  // of upper/lower case letters in the address.
  typedef ipv6-prefix {
    type tailf:ipv6-address-and-prefix-length;
  }

  // Router Distinguisher
  typedef rd-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
      pattern '(\d*(.\d*)*)?:(\d*(.\d*)*)?';
    }
  }

  // VPN id type
  typedef vpn-id-type {
    type string {
      tailf:info "OUI:VPN-Index;;, format (hex) <3 bytes OUI:4 bytes "
        +"VPN_Index>";
      pattern '[0-9a-fA-F][0-9a-fA-F]?[0-9a-fA-F]?:[0-9a-fA-F]'
        +'[0-9a-fA-F]?[0-9a-fA-F]?[0-9a-fA-F]?';
    }
  }

  // ASN IP type
  typedef asn-ip-type {
    type string {
      tailf:info "ASN:nn or IP-address:nn";
      pattern '(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
        +'\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+';
    }
  }

  // Hour&minute type
  typedef hhmm-type {
    type string {
      pattern "([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?";
    }
  }

  // Weekday type
  typedef weekday-type {
    type enumeration {
      enum Mon;
      enum Tue;
      enum Wed;
      enum Thu;
      enum Fri;
      enum Sat;
      enum Sun;
    }
  }

  // Month type
  typedef month-type {
    type enumeration {
      enum Jan;
      enum Feb;
      enum Mar;
      enum Apr;
      enum May;
      enum Jun;
      enum Jul;
      enum Aug;
      enum Sep;
      enum Oct;
      enum Nov;
      enum Dec;
    }
  }

  // Standard access list type
  typedef std-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  // Extended access list type
  typedef ext-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;Access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;Access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;IP Named Extended Access list";
      }
    }
  }

  // Standard IP access list type
  typedef std-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-99>;;Standard IP access list";
        range "1..99";
      }
      type uint16 {
        tailf:info "<1300-1999>;;Standard IP access list (expanded range)";
        range "1300..1999";
      }
      type string {
        tailf:info "WORD;;Named access list";
      }
    }
  }

  // ip access list type
  typedef ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;Standard or Extended IP access list number";
        range "1..199";
      }
      type string {
        tailf:info "WORD;;IP Named Access list";
      }
    }
  }

  // Extended ip access list type
  typedef ext-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<100-199>;;IP access list number";
        range "100..199";
      }
      type uint16 {
        tailf:info "<2000-2699>;;IP access list number (expanded range)";
        range "2000..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  // Expanded ip access list type
  typedef exp-ip-acl-type {
    type union {
      type uint16 {
        tailf:info "<1-199>;;IP access list";
        range "1..199";
      }
      type uint16 {
        tailf:info "<1300-2699>;;IP expanded access list";
        range "1300..2699";
      }
      type string {
        tailf:info "WORD;;Access-list name";
      }
    }
  }

  // LDP discovery address type
  typedef ldp-discovery-address-type {
    type union {
      type enumeration {
        enum interface {
          tailf:info "Use interface address for LDP transport address";
          tailf:code-name "ldp_interface";
        }
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address to use for LDP transport address";
      }
    }
  }

  // Mst cost
  typedef mst-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name mst_cost_type_auto;
          tailf:info "Determine cost based on media speed of this "
          +"interface";
        }
      }
    }
  }

  // Spanning tree cost
  typedef spanning-tree-cost-type {
    type union {
      type uint32 {
        tailf:info "<1-200000000>;;Port path cost";
        range "1..200000000";
      }
      type enumeration {
        enum auto {
          tailf:code-name spanning-tree-cost-type-auto;
          tailf:info "Determine cost based on media speed of this "
          +"interface";
        }
      }
    }
  }

  // DSCP type
  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "Match packets with AF11 dscp (001010)";
          value 10011;
        }
        enum af12 {
          tailf:info "Match packets with AF12 dscp (001100)";
          value 10012;
        }
        enum af13 {
          tailf:info "Match packets with AF13 dscp (001110)";
          value 10013;
        }
        enum af21 {
          tailf:info "Match packets with AF21 dscp (010010)";
          value 10021;
        }
        enum af22 {
          tailf:info "Match packets with AF22 dscp (010100)";
          value 10022;
        }
        enum af23 {
          tailf:info "Match packets with AF23 dscp (010110)";
          value 10023;
        }
        enum af31 {
          tailf:info "Match packets with AF31 dscp (011010)";
          value 10031;
        }
        enum af32 {
          tailf:info "Match packets with AF32 dscp (011100)";
          value 10032;
        }
        enum af33 {
          tailf:info "Match packets with AF33 dscp (011110)";
          value 10033;
        }
        enum af41 {
          tailf:info "Match packets with AF41 dscp (100010)";
          value 10041;
        }
        enum af42 {
          tailf:info "Match packets with AF42 dscp (100100)";
          value 10042;
        }
        enum af43 {
          tailf:info "Match packets with AF43 dscp (100110)";
          value 10043;
        }
        enum cs1 {
          tailf:info "Match packets with CS1(precedence 1) dscp"+
          " (001000)";
          value 10001;
        }
        enum cs2 {
          tailf:info "Match packets with CS2(precedence 2) dscp"+
          " (010000)";
          value 10002;
        }
        enum cs3 {
          tailf:info "Match packets with CS3(precedence 3) dscp"+
          " (011000)";
          value 10003;
        }
        enum cs4 {
          tailf:info "Match packets with CS4(precedence 4) dscp"+
          " (100000)";
          value 10004;
        }
        enum cs5 {
          tailf:info "Match packets with CS5(precedence 5) dscp"+
          " (101000)";
          value 10005;
        }
        enum cs6 {
          tailf:info "Match packets with CS6(precedence 6) dscp"+
          " (110000)";
          value 10006;
        }
        enum cs7 {
          tailf:info "Match packets with CS7(precedence 7) dscp"+
          " (111000)";
          value 10007;
        }
        enum "default" {
          tailf:info "Match packets with default dscp (000000)";
          tailf:code-name "dscp_default";
          value 1000;
        }
        enum dscp {
          tailf:info "Set packet dscp from dscp";
          value 1001;
        }
        enum ef {
          tailf:info "Match packets with EF dscp (101110)";
          value 1002;
        }
        enum precedence {
          tailf:info "Set packet dscp from precedence";
          value 1003;
        }
      }
    }
  }

  // Precedence type
  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
        }
        enum internet {
          tailf:code-name "prec_internet";
          tailf:info "Set packets with internetwork control"+
          " precedence (6)";
        }
        enum network {
          tailf:info "Set packets with network control precedence"+
          " (7)";
        }
        enum priority {
          tailf:code-name "prec_priority";
          tailf:info "Set packets with priority precedence (1)";
        }
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
        }
      }
    }
  }

  // cos_value-type
  typedef cos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new cos value";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet cos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet cos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet cos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet cos from precedence";
          value 1004;
        }
      }
    }
  }

  // qos_value-type
  typedef qos_value-type {
    type union {
      type uint8 {
        tailf:info "<0-99>;;new qos-group";
        range "0..99";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet qos from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet qos from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet qos from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet qos from precedence";
          value 1004;
        }
      }
    }
  }

  // exp_value-type
  typedef exp_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new exp";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet exp from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet exp from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet exp from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet exp from precedence";
          value 1004;
        }
      }
    }
  }

  // prec_value-type
  typedef prec_value-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;new precedence";
        range "0..7";
      }
      type enumeration {
        enum cos {
          tailf:info "Set packet precedence from cos";
          value 1001;
        }
        enum dscp {
          tailf:info "Set packet precedence from dscp";
          value 1002;
        }
        enum exp {
          tailf:info "Set packet precedence from exp";
          value 1003;
        }
        enum precedence {
          tailf:info "Set packet precedence from precedence";
          value 1004;
        }
      }
    }
  }

  typedef redist-ospf-external-type {
    type enumeration {
      enum "1" {
        tailf:info "Redistribute external type 1 routes";
      }
      enum "2" {
        tailf:info "Redistribute external type 2 routes";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0..4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef ospf-metric-type {
    type uint32 {
      tailf:info "<1-2>;;OSPF Link State type";
      range "1..2";
    }
  }

  typedef limit-dc-non-dc-type {
    type union {
      type uint32 {
        tailf:info "<1-255>;;The maximum number of retransmissions";
        range "1..255";
      }
      type enumeration {
        enum disable {
          tailf:info "Disable the feature";
        }
      }
    }
  }

  typedef isis-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "Level-1 only";
      }
      enum level-1-2 {
        tailf:info "Level-1-2";
      }
      enum level-2 {
        tailf:info "Level-2 only";
      }
    }
  }

  typedef authentication-level-type {
    type enumeration {
      enum level-1 {
        tailf:info "ISIS authentication for level-1";
      }
      enum level-2 {
        tailf:info "ISIS authentication for level-2";
      }
    }
  }

  typedef logging-level-type {
    type union {
      type uint16 {
        tailf:info "<0-7>;;Logging severity level";
        range "0..7";
      }
      type enumeration {
        enum alerts {
          tailf:info "Immediate action needed (severity=1)";
          value 1;
        }
        enum critical {
          tailf:info "Critical conditions (severity=2)";
          value 2;
        }
        enum debugging {
          tailf:info "Debugging messages (severity=7)";
          value 7;
        }
        enum emergencies {
          tailf:info "System is unusable (severity=0)";
          value 0;
        }
        enum errors {
          tailf:info "Error conditions (severity=3)";
          value 3;
        }
        enum informational {
          tailf:info "Informational messages (severity=6)";
          value 6;
        }
        enum notifications {
          tailf:info "Normal but significant conditions (severity=5)";
          value 5;
        }
        enum warnings {
          tailf:info "Warning conditions (severity=4)";
          value 4;
        }
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
    }
  }

  typedef police-packets-bytes-type {
    type enumeration {
      enum packets {
        tailf:info "Treat 'burst' value as packets";
      }
      enum bytes {
        tailf:info "Treat 'burst' value as bytes";
      }
    }
  }

  typedef police-pps-bps-type {
    type enumeration {
      enum pps {
        tailf:info "pps  Treat 'rate' value in "+
        "packets-per-second";
      }
      enum bps {
        tailf:info "pps  Treat 'rate' value in "+
        "bytes-per-second";
      }
    }
  }

  // police target bit rate in bits per second (bps) type
  typedef police-bps-type {
    type uint64 {
      tailf:info "<8000-64000000000>;;Bits per second";
      range "8000..64000000000";
    }
  }

  typedef police-burst-type {
    type uint32 {
      tailf:info "<1000-512000000>;;Burst bytes";
      range "1000..512000000";
    }
  }


  // aaa-authorization-name-type
  typedef aaa-authorization-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authorization list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authorization list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-authentication-name-type
  typedef aaa-authentication-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default authentication list.";
        }
      }
      type string {
        tailf:info "WORD;;Named authentication list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-accounting-name-type
  typedef aaa-accounting-name-type {
    type union {
      type enumeration {
        enum "default" {
          tailf:info "The default accounting list.";
        }
      }
      type string {
        tailf:info "WORD;;Named Accounting list (max 31 characters).";
        length "1..31";
      }
    }
  }

  // aaa-group-type
  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum "tacacs+" {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }

  // ipsec-window-size-type
  typedef ipsec-window-size-type {
    type enumeration {
      enum "1024" {
        tailf:info "Window size of 1024";
      }
      enum "128" {
        tailf:info "Window size of 128";
      }
      enum "256" {
        tailf:info "Window size of 256";
      }
      enum "512" {
        tailf:info "Window size of 512";
      }
      enum "64" {
        tailf:info "Window size of 64 (default)";
      }
    }
  }

  typedef bgp-as-no-type {
    type union {
      type uint32 {
        tailf:info "<1-4294967295>;;Autonomous system number";
        range "1..4294967295";
      }
      type string {
        tailf:info "<1.0-XX.YY>;;Autonomous system number";
        pattern '[0-9]+.*';
      }
    }
  }

  typedef eigrp-as-no-type {
    type union {
      type uint16 {
        tailf:info "<1-65535>;;Autonomous system number";
        range "1..65535";
      }
      type string {
        tailf:info "WORD;;EIGRP Virtual-Instance Name";
      }
    }
  }

  typedef l2protocol-type {
    type enumeration {
      enum cdp {
        tailf:info "Cisco Discovery Protocol";
      }
      enum dtp {
        tailf:info "Dynamic Trunking Protocol";
      }
      enum lacp {
        tailf:info "LACP Protocol";
      }
      enum lldp {
        tailf:info "Link Layer Discovery Protocol";
      }
      enum pagp {
        tailf:info "Port Aggregation Protocol";
      }
      enum stp {
        tailf:info "Spanning Tree Protocol";
      }
      enum udld {
        tailf:info "UDLD Protocol";
      }
      enum vtp {
        tailf:info "Vlan Trunking Protocol";
      }
      enum dot1x {
        tailf:info "Dot1x Protocol";
      }
    }
  }

  typedef cable-downstream-interleaver-depth-option {
    type enumeration {
      enum I128-J1 {
        tailf:info "RFGW_MB_FEC-I-128-J-1";
      }
      enum I128-J2 {
        tailf:info "RFGW_MB_FEC-I-128-J-2";
      }
      enum I128-J3 {
        tailf:info "RFGW_MB_FEC-I-128-J-3";
      }
      enum I128-J4 {
        tailf:info "RFGW_MB_FEC-I-128-J-4";
      }
      enum I128-J5 {
        tailf:info "RFGW_MB_FEC-I-128-J-5";
      }
      enum I128-J6 {
        tailf:info "RFGW_MB_FEC-I-128-J-6";
      }
      enum I128-J7 {
        tailf:info "RFGW_MB_FEC-I-128-J-7";
      }
      enum I128-J8 {
        tailf:info "RFGW_MB_FEC-I-128-J-8";
      }
      enum I16-J8 {
        tailf:info "RFGW_MB_FEC-I-16-J-8 ";
      }
      enum I32-J4 {
        tailf:info "RFGW_MB_FEC-I-32-J-4 ";
      }
      enum I64-J2 {
        tailf:info "RFGW_MB_FEC-I-64-J-2 ";
      }
      enum I8-J16 {
        tailf:info "RFGW_MB_FEC-I-8-J-16 ";
      }
    }
  }

  typedef object-group-service-icmp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum alternate-address {
          tailf:info "Alternate address";
        }
        enum conversion-error {
          tailf:info "Datagram conversion";
        }
        enum echo {
          tailf:info "Echo (ping)";
        }
        enum echo-reply {
          tailf:info "Echo reply";
        }
        enum information-reply {
          tailf:info "Information replies";
        }
        enum information-request {
          tailf:info "Information requests";
        }
        enum mask-reply {
          tailf:info "Mask replies";
        }
        enum mask-request {
          tailf:info "Mask requests";
        }
        enum mobile-redirect {
          tailf:info "Mobile host redirect";
        }
        enum parameter-problem {
          tailf:info "All parameter problems";
        }
        enum redirect {
          tailf:info "All redirects";
        }
        enum router-advertisement {
          tailf:info "Router discovery advertise.";
        }
        enum router-solicitation {
          tailf:info "Router discovery solicitations";
        }
        enum source-quench {
          tailf:info "Source quenches";
        }
        enum time-exceeded {
          tailf:info "All time exceededs";
        }
        enum timestamp-reply {
          tailf:info "Timestamp replies";
        }
        enum timestamp-request {
          tailf:info "Timestamp requests";
        }
        enum traceroute {
          tailf:info "Traceroute";
        }
        enum unreachable {
          tailf:info "All unreachables";
        }
      }
    }
  }

  typedef object-group-service-tcp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum bgp {
          tailf:info "Border Gateway Protocol (179)";
        }
        enum chargen {
          tailf:info "Character generator (19)";
        }
        enum cmd {
          tailf:info "Remote commands (rcmd, 514)";
        }
        enum connectedapps-plain {
          tailf:info "ConnectedApps Cleartext (15001)";
        }
        enum connectedapps-tls {
          tailf:info "ConnectedApps TLS (15002)";
        }
        enum daytime {
          tailf:info "Daytime (13)";
        }
        enum discard {
          tailf:info "Discard (9)";
        }
        enum domain {
          tailf:info "Domain Name Service (53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum exec {
          tailf:info "Exec (rsh, 512)";
        }
        enum finger {
          tailf:info "Finger (79)";
        }
        enum ftp {
          tailf:info "File Transfer Protocol (21)";
        }
        enum ftp-data {
          tailf:info "FTP data connections (20)";
        }
        enum gopher {
          tailf:info "Gopher (70)";
        }
        enum hostname {
          tailf:info "NIC hostname server (101)";
        }
        enum ident {
          tailf:info "Ident Protocol (113)";
        }
        enum irc {
          tailf:info "Internet Relay Chat (194)";
        }
        enum klogin {
          tailf:info "Kerberos login (543)";
        }
        enum kshell {
          tailf:info "Kerberos shell (544)";
        }
        enum login {
          tailf:info "Login (rlogin, 513)";
        }
        enum lpd {
          tailf:info "Printer service (515)";
        }
        enum msrpc {
          tailf:info "MS Remote Procedure Call (135)";
        }
        enum nntp {
          tailf:info "Network News Transport Protocol (119)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum pop2 {
          tailf:info "Post Office Protocol v2 (109)";
        }
        enum pop3 {
          tailf:info "Post Office Protocol v3 (110)";
        }
        enum smtp {
          tailf:info "Simple Mail Transport Protocol (25)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "Syslog (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
        enum telnet {
          tailf:info "Telnet (23)";
        }
        enum time {
          tailf:info "Time (37)";
        }
        enum uucp {
          tailf:info "Unix-to-Unix Copy Program (540)";
        }
        enum whois {
          tailf:info "Nicname (43)";
        }
        enum www {
          tailf:info "World Wide Web (HTTP, 80)";
        }
      }
    }
  }

  typedef object-group-service-udp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum biff {
          tailf:info "Biff (mail notification, comsat, 512)";
        }
        enum bootpc {
          tailf:info "Bootstrap Protocol (BOOTP) client (68)";
        }
        enum discard {
          tailf:info "Discard (9)";
        }
        enum dnsix {
          tailf:info "DNSIX security protocol auditing (195)";
        }
        enum domain {
          tailf:info "Domain Name Service (DNS, 53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum isakmp {
          tailf:info "Internet Security Association and Key "
          +"Management Protocol (500)";
        }
        enum mobile-ip {
          tailf:info "Mobile IP registration (434)";
        }
        enum nameserver {
          tailf:info "IEN116 name service (obsolete, 42)";
        }
        enum netbios-dgm {
          tailf:info "NetBios datagram service (138)";
        }
        enum netbios-ns {
          tailf:info "NetBios name service (137)";
        }
        enum netbios-ss {
          tailf:info "NetBios session service (139)";
        }
        enum non500-isakmp {
          tailf:info "Internet Security Association and "
            +"Key Management Protocol (4500)";
        }
        enum ntp {
          tailf:info "Network Time Protocol (123)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum rip {
          tailf:info "Routing Information Protocol (router, in.routed, 520)";
        }
        enum ripv6 {
          tailf:info "Routing Information Protocol V6 (router, in.routed, 521)";
        }
        enum snmp {
          tailf:info "Simple Network Management Protocol (161)";
        }
        enum snmptrap {
          tailf:info "SNMP Traps (162)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "System Logger (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
        enum tftp {
          tailf:info "Trivial File Transfer Protocol (69)";
        }
        enum time {
          tailf:info "Time (37)";
        }
        enum who {
          tailf:info "Who service (rwho, 513)";
        }
        enum xdmcp {
          tailf:info "X Display Manager Control Protocol (177)";
        }
      }
    }
  }

  typedef object-group-service-tcp-udp-type {
    type union {
      type uint16 {
        tailf:info "<0-65535>;;Port number";
      }
      type enumeration {
        enum discard {
          tailf:info "Discard (9)";
        }
        enum domain {
          tailf:info "Domain Name Service (53)";
        }
        enum echo {
          tailf:info "Echo (7)";
        }
        enum pim-auto-rp {
          tailf:info "PIM Auto-RP (496)";
        }
        enum sunrpc {
          tailf:info "Sun Remote Procedure Call (111)";
        }
        enum syslog {
          tailf:info "Syslog (514)";
        }
        enum tacacs {
          tailf:info "TAC Access Control System (49)";
        }
        enum talk {
          tailf:info "Talk (517)";
        }
      }
    }
  }

  typedef isakmp-pfs-type {
    type enumeration {
      enum group1 {
        tailf:info "D-H Group1 (768-bit modp)";
      }
      enum group14 {
        tailf:info "D-H Group14 (2048-bit modp)";
      }
      enum group15 {
        tailf:info "D-H Group15 (3072-bit modp)";
      }
      enum group16 {
        tailf:info "D-H Group16 (4096-bit modp)";
      }
      enum group19 {
        tailf:info "D-H Group19 (256-bit ecp)";
      }
      enum group2 {
        tailf:info "D-H Group2 (1024-bit modp)";
      }
      enum group20 {
        tailf:info "D-H Group20 (384-bit ecp)";
      }
      enum group21 {
        tailf:info "D-H Group21 (521-bit ecp)";
      }
      enum group24 {
        tailf:info "D-H Group24 (2048-bit modp, 256 bit subgroup)";
      }
      enum group5 {
        tailf:info "D-H Group5 (1536-bit modp)";
      }
    }
  }


  // =========================================================================
  // GROUPING
  // =========================================================================


  // description-grouping
  grouping description-grouping {
    leaf "description" {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  // password-grouping
  grouping password-grouping {
    leaf "type" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password/key will follow";
        }
        enum "7" {
          tailf:info "Specifies a HIDDEN password/key will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|7|key-chain";
      tailf:meta-data "secret-password";
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) password/key";
      }
    }
  }

  // crypto-key-grouping
  grouping crypto-key-grouping {
    leaf "encryption" {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "0" {
          tailf:info "Specifies an UNENCRYPTED password will follow";
        }
        enum "6" {
          tailf:info "Specifies an ENCRYPTED password will follow";
        }
        enum "7" {
          tailf:info "Specifies an HIDDEN password will follow";
        }
      }
    }
    leaf secret {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value "0|6|7";
      tailf:meta-data "secret-password";
      type string {
        tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
      }
    }
  }


  // interface-name-grouping - all interface lists collected
  grouping interface-name-grouping {
    choice interface-choice {

      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Null/name";
        }
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Loopback/name";
        }
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern '([0-9\.])+';
        }
      }

      leaf VirtualPortGroup {
        tailf:info "Virtual Port Group";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/VirtualPortGroup/name";
        }
        type uint8 {
          tailf:info "<0-31>;;VirtualPortGroup interface number";
        }
      }

      leaf Embedded-Service-Engine {
        tailf:info "cisco embedded service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Embedded-Service-Engine/name";
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Service-Engine {
        tailf:info "Cisco service engine module";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Service-Engine/name";
        }
        type string {
          tailf:info "<0-2>/<0-0>;;Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Tunnel {
        tailf:info "Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Tunnel/name";
        }
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }

      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Port-channel/name";
        }
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }

      container Port-channel-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Port-channel {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Port-channel-subinterface/Port-channel/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf Multilink {
        tailf:info "Multilink-group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Multilink/name";
        }
        type uint16 {
          tailf:info "<1-65535>;;Multilink interface number";
          range "1..65535";
        }
      }

      leaf MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/MFR/name";
        }
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }

      container MFR-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf MFR {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/MFR-subinterface/MFR/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BRI/name";
        }
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Ethernet {
        tailf:info "Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Ethernet/name";
        }
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/FastEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/GigabitEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf TenGigabitEthernet {
        tailf:info "Ten Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/TenGigabitEthernet/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf FortyGigabitEthernet {
        tailf:info "Forty Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/FortyGigabitEthernet/name";
        }
        type string {
          tailf:info "X/Y/Z;;FortyGigabitEthernet interface id";
          pattern '[0-9]+.*';
        }
      }

      leaf HundredGigE {
        tailf:info "Hundred Gigabit Ethernet";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/HundredGigE/name";
        }
        type string {
          tailf:info "<0-66>/<0-128>;;HundredGigE interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Wlan-GigabitEthernet {
        tailf:info "Wlan-GigabitEthernet interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Wlan-GigabitEthernet/name";
        }
        type string {
          tailf:info "<0-0>;;Wlan-GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf wlan-ap {
        tailf:info "Service module interface to embedded AP";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/wlan-ap/name";
        }
        type string {
          tailf:info "<0-0>;;wlan-ap interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf ATM {
        tailf:info "ATM interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/ATM/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf CEM {
        tailf:info "Circuit Emulation interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/CEM/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf BDI {
        tailf:info "Bridge-Domain interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BDI/name";
        }
        type uint16 {
          tailf:info "<1-4095>;;BDI interface number";
          range "1..4095";
        }
      }

      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/BVI/name";
        }
        type string {
          tailf:info "<1-255>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Video {
        tailf:info "video service interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Video/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Integrated-Cable {
        tailf:info "Integrated Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Integrated-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Modular-Cable {
        tailf:info "Modular Cable interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Modular-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Wideband-Cable {
        tailf:info "Wideband CMTS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Wideband-Cable/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Dialer {
        tailf:info "Dialer interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Dialer/name";
        }
        type string {
          tailf:info "<0-255>;;Dialer interface number";
          pattern '[0-9]+.*';
        }
      }

      leaf Bundle {
        tailf:info "Virtual Bundle";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Bundle/name";
        }
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }

      leaf Cellular {
        tailf:info "Cellular";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Cellular/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Qam-red {
        tailf:info "QAM red interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Qam-red/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Asi {
        tailf:info "ASI interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Asi/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Vlan {
        tailf:info "Catalyst Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Vlan/name";
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }

      leaf Async {
        tailf:info "Async interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Async/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Group-Async {
        tailf:info "Async Group interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Group-Async/name";
        }
        type uint16;
      }

      leaf POS {
        tailf:info "POS interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/POS/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Serial/name";
        }
        type string {
          pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?';
        }
      }

      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/Serial-subinterface/Serial/name";
          }
          type string {
            pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?\.[0-9]+';
          }
        }
      }

      leaf Virtual-Template {
        tailf:info "Virtual Template interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Virtual-Template/name";
        }
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }

      leaf pseudowire {
        tailf:info "Pseudowire Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/pseudowire/name";
        }
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      leaf LISP {
        tailf:info "Locator/ID Separation Protocol Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/LISP/name";
        }
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }

      container LISP-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf LISP {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          tailf:non-strict-leafref {
            path "/ios:interface/LISP-subinterface/LISP/name";
          }
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
      }

      // network-clock input-source * interface ToP0/12
      leaf ToP {
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+/[0-9]+";
        }
      }

      leaf Dot11Radio {
        tailf:info "IEEE 802.11 WLAN";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/Dot11Radio/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }

      leaf vasileft {
        tailf:info "VasiLeft interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/vasileft/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;vasileft interface number";
          range "1..1000";
        }
      }

      leaf vasiright {
        tailf:info "VasiRight interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/vasiright/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;vasiright interface number";
          range "1..1000";
        }
      }

      leaf AppNav-Compress {
        tailf:info "Service-Context Virtual Interface Compress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/AppNav-Compress/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-Compress interface number";
          range "1..1000";
        }
      }

      leaf AppNav-UnCompress {
      tailf:info "Service-Context Virtual interface UnCompress";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/AppNav-UnCompress/name";
        }
        type uint16 {
          tailf:info "<1-1000>;;AppNav-UnCompress interface number";
          range "1..1000";
        }
      }

     leaf ucse {
        tailf:info "Cisco ucse server";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ios:interface/ucse/name";
        }
        type string {
          pattern '[0-9]+.*';
        }
      }
    }
  } // interface-name-grouping


  // service-group * / service-policy
  // control-plane service-policy
  // interface * / service-policy
  // interface pseudowire * / service-policy
  grouping service-policy-grouping {
    leaf "input" {
      tailf:info "Assign input policy-map";
      tailf:cli-remove-before-change;
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;input Policy-map name";
      }
    }
    leaf "output" {
      tailf:info "Assign output policy-map";
      tailf:cli-remove-before-change;
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;output Policy-map name";
      }
    }
  }

  // police {conform|exceed|violate}-action groupings
  grouping police-action-transmit-grouping {
    leaf transmit {
      tailf:info "transmit packet";
      type empty;
    }
  }
  grouping police-action-drop-grouping {
    leaf drop {
      tailf:info "drop packet";
      type empty;
    }
  }


  // Police conform action grouping
  grouping police-conform-action-grouping {
    container conform-action {
      tailf:info "action when rate is less than conform burst";
      tailf:cli-flatten-container;
      choice conform-action-choice {
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
      }
    }

    leaf table {
      tailf:info "Specify conform-action table-map";
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/ios:table-map/name";
      }
      type string {
        tailf:info "WORD;;table-map name";
      }
    }
  }

  // Police exceed action grouping
  grouping police-exceed-action-grouping {
    container exceed-action {
      tailf:info "action when rate is within conform and conform + exceed burst";
      tailf:cli-flatten-container;
      choice exceed-action-choice {
        leaf dscp {
          //tailf:info
          type dscp-type;
        }
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
      }
    }
  }

  // Police violate action grouping
  grouping police-violate-action-grouping {
    container violate-action {
      tailf:info "action when rate is greater than conform exceed burst";
      tailf:cli-flatten-container;
      choice violate-action-choice {
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf transmit {
          tailf:info "transmit packet";
          type empty;
        }
        leaf drop {
          tailf:info "drop packet";
          type empty;
        }
      }
    }
  }


  // Police multiple conform action grouping
  grouping police-multiple-conform-action-grouping {
    container conform-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container conform-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container conform-set-cos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container conform-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container conform-set-dscp-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-imposition-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container conform-set-mpls-exp-topmost-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container conform-set-prec-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container conform-set-qos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container conform-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container conform-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container conform-action {
        tailf:info "action when rate is less than conform burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }

  // Police multiple exceed action grouping
  grouping police-multiple-exceed-action-grouping {
    container exceed-dscp {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf dscp {
          //tailf:info
          type dscp-type;
        }
      }
    }
    container exceed-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container exceed-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container exceed-set-cos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container exceed-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container exceed-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container exceed-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container exceed-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container exceed-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container exceed-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container exceed-set-qos-transmit-table {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type cos_value-type;
        }
        leaf table {
          tailf:info "Specify table-map";
          tailf:non-strict-leafref {
            path "/ios:table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
    }
    container exceed-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container exceed-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container exceed-action {
        tailf:info "action when rate is within conform and "+
          "conform + exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }

  // Police multiple violate action grouping
  grouping police-multiple-violate-action-grouping {
    container violate-set-clp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-clp-transmit {
          tailf:info "set atm clp and send it";
          type empty;
        }
      }
    }
    container violate-set-cos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-cos-transmit {
          tailf:info "rewrite packet cos and send it";
          type cos_value-type;
        }
      }
    }
    container violate-set-discard-class-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-discard-class-transmit {
          tailf:info "set discard-class and send it";
          type uint8 {
            tailf:info "<0-7>;;new discard-class";
            range "0..7";
          }
        }
      }
    }
    container violate-set-dscp-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-dscp-transmit {
          tailf:info "set dscp and send it";
          type dscp-type;
        }
      }
    }
    container violate-set-frde-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-frde-transmit {
          tailf:info "set FR DE and send it";
          type empty;
        }
      }
    }
    container violate-set-mpls-exp-imposition-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-imposition-transmit {
          tailf:info "set exp at tag imposition and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-mpls-exp-topmost-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-mpls-exp-topmost-transmit {
          tailf:info "set exp on topmost label and send it";
          type exp_value-type;
        }
      }
    }
    container violate-set-prec-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-prec-transmit {
          tailf:info "rewrite packet precedence and send it";
          type prec_value-type;
        }
      }
    }
    container violate-set-qos-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        leaf set-qos-transmit {
          tailf:info "set qos-group and send it";
          type qos_value-type;
        }
      }
    }
    container violate-transmit {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-transmit-grouping;
      }
    }
    container violate-drop {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      container violate-action {
        tailf:info "action when rate is greater than conform + "+
          "exceed burst";
        tailf:cli-flatten-container;
        uses police-action-drop-grouping;
      }
    }
  }


  // police-action-grouping
  grouping police-action-grouping {
    container actions {
      tailf:cli-break-sequence-commands;
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      // policy-map * / class * / police ? / conform-action
      uses police-multiple-conform-action-grouping;
      // policy-map * / class * / police ? / exceed-action
      uses police-multiple-exceed-action-grouping;
      // policy-map * / class * / police ? / violate-action
      uses police-multiple-violate-action-grouping;
    }
  }


  grouping policy-map-class-grouping {

    // policy-map * / class * / pass-through
    leaf pass-through {
      tailf:info "pass-through action";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / drop|inspect|pass
    container policy {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }

      // policy-map * / class * / drop
      // policy-map * / class * / pass
      // policy-map * / class * / inspect
      leaf action {
        tailf:cli-drop-node-name;
        tailf:cli-remove-before-change;
        type enumeration {
          enum drop {
            tailf:info "Drop the packet";
          }
          enum inspect {
            tailf:info "Context-based Access Control Engine";
          }
          enum pass {
            tailf:info "Pass the packet";
          }
        }
      }

      // policy-map * / class * / drop log
      // policy-map * / class * / pass log
      leaf log {
        when "(../action = 'drop') or (../action = 'pass')" {
          tailf:dependency "../action";
        }
        tailf:info "Send logging message for drop|pass";
        tailf:cli-optional-in-sequence;
        type empty;
      }

      // policy-map * / class * / inspect
      leaf parameter-map {
        tailf:cli-drop-node-name;
        when "../action = 'inspect'" {
          tailf:dependency "../action";
        }
        tailf:non-strict-leafref {
          path "/ios:parameter-map/type/inspect/name";
        }
        type string {
          tailf:info "WORD;;Parameter-map (inspect) name";
        }
      }
    }

    // policy-map * / class * / inspect-police
    container inspect-police {
      when "../policy/action = 'inspect'" {
        tailf:dependency "../policy/action";
      }
      tailf:cli-drop-node-name;
      container police {
        tailf:info "Police";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:info "Specify police rate";
          type uint32 {
            tailf:info "<8000-2000000000>;;Rate value in bps";
            range "8000..2000000000";
          }
        }
        leaf burst {
          tailf:info "Specify 'burst' parameter";
          type uint32 {
            tailf:info "<1000-512000000>;;Burst value in bytes";
            range "1000..512000000";
          }
        }
      }
    }

    // policy-map * / class * / bandwidth
    container bandwidth {
      tailf:info "Bandwidth";
      leaf bits {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<8-10000000>;;Kilo Bits per second";
          range "8..10000000";
        }
      }

      // policy-map * / class * / bandwidth percent
      leaf percent {
        tailf:info "% of total Bandwidth";
        tailf:cli-remove-before-change;
        type percentage-type;
      }

      // policy-map * / class * / bandwidth remaining
      container remaining {
        tailf:info "% of the remaining bandwidth";

        // policy-map * / class * / bandwidth remaining percent
        container percent {
          tailf:info "% of the remaining bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf percent {
            // dep: before this is created, change ratio
            tailf:cli-diff-dependency "../../ratio/ratio" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-drop-node-name;
            type percentage-type;
          }
          uses bandwidth-remaining-account-grouping;
        }

        // policy-map * / class * / bandwidth remaining ratio
        container ratio {
          tailf:info "ratio for sharing excess bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf ratio {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-65536>;;Ratio";
              range "1..65536";
            }
          }
          uses bandwidth-remaining-account-grouping;
        }
      }
    }

    // policy-map * / class * / compression
    container compression {
      tailf:info "Activate Compression";
      presence "Activate Compression";
      container header {
        tailf:info "configure header compression";
        presence "configure header compression";
        leaf ip {
          tailf:info "configure ip header compression";
          type enumeration {
            enum rtp {
              tailf:code-name "header_rtp";
              tailf:info "configure rtp header compression";
            }
            enum tcp {
              tailf:info "configure tcp header compression";
            }
          }
        }
      }
    }

    // policy-map * / class * / dbl
    leaf dbl {
      tailf:info "enable dynamic buffer limiting";
      tailf:cli-full-command;
      type empty;
    }

    // policy-map * / class * / estimate
    container estimate {
      tailf:info "estimate resources required for this class";
      container bandwidth {
        tailf:info "bandwidth required to service this class";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        container delay-one-in {
          tailf:info "specify QoS target delay";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf doi {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              range "50..1000000";
              tailf:info "<50-1000000>;;delay one packet of N";
            }
          }

          leaf milliseconds {
            type uint32 {
              range "8..1000" {
                tailf:info "<8-1000>;;worst-case milliseconds of delay";
              }
            }
          }
        }
        leaf drop-one-in {
          tailf:info "specify QoS target loss rate";
          type uint32 {
            tailf:info "<50-1000000>;;drop one packet of N";
          }
        }
      }
    }

    // policy-map * / class * / fair-queue
    // class-default: fair-queue [number-of-dynamic-queues]
    // DWFQ: fair-queue
    // policy-map: fair-queue [queue-limit queue-value]
    // NOT SUPPORTED:
    // air-queue [congestive-discard-threshold [dynamic-q [reservable-q]]]
    container fair-queue {
      tailf:info "Enable Flow-based Fair Queuing in this Class";
      tailf:cli-reset-container;
      presence true;
      leaf dynamic-queues {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          range "16|32|64|128|256|512|1024|2048|4096" {
            tailf:info "<16-4096>;;Number Dynamic Conversation "+
              "Queues";
          }
        }
      }
      leaf queue-limit {
        tailf:info "per flow queue limit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-32768>;;packets";
          range "1..32768";
        }
      }
    }

    // policy-map * / class * / flow
    container flow {
      tailf:info "Flow subcommands";
      leaf monitor {
        tailf:info "Apply a Flow Monitor";
        tailf:non-strict-leafref {
          path "/ios:flow/monitor/name";
        }
        type string {
          tailf:info "WORD;;Flow Monitor name";
        }
      }
    }

    // policy-map * / class * / netflow-sampler
    leaf netflow-sampler {
      tailf:info "NetFlow action";
      tailf:cli-full-command;
      // should be leafref to sampler
      type string {
        tailf:info "WORD;;Name of the flow sampler";
      }
    }

    // policy-map * / class * / police aggregate
    container police-aggregate {
      tailf:cli-no-keyword;
      tailf:cli-drop-node-name;
      container police {
        tailf:info "Police";
        leaf aggregate {
          tailf:info "Choose aggregate policer for current class";
          tailf:cli-diff-dependency "/ios:qos/aggregate-policer";
          tailf:cli-diff-dependency "../../../police-policy-map/police/cir" {
            tailf:cli-trigger-on-set;
          }
          type string {
            tailf:info "WORD;;enter aggregate-policer name";
          }
        }
      }
    }

    // policy-map * / class * / police ?
    choice police-choice {

      // police "cirmode" - (policy map)
      // police cir <bps> [[bc <burst-normal>] [be <burst-max>]]
      //        [pir <bps> [be <burst-bytes>]] ACTIONS
      // NOTE: cir, bc & be keywords are mandatory in this model.
      //       Java code will add missing cir,bc and be in show().
      case police-cirmode-case {
        container police-policy-map {  //NEW: police-cirmode
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'cirmode')" {
              tailf:dependency "/ios:tailfned/police";
            }
            // cir <bps>
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              tailf:cli-diff-dependency
                "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type police-bps-type;
            }
            // [bc <burst-normal>]
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-burst-type;
            }
            // [be <burst-max>]
            leaf be {
              when "../bc" {
                tailf:dependency "../bc";
              }
              tailf:info "Excess burst";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-burst-type;
            }
            // [pir <bps> [be <burst-bytes>]]
            leaf pir {
              tailf:info "Peak Information Rate";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type police-bps-type;
            }
            container pir-be {
              when "../pir" {
                tailf:dependency "../pir";
              }
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-flatten-container;
              tailf:cli-hide-in-submode;
              leaf be {
                tailf:info "Excess burst";
                type police-burst-type;
              }
            }
            // conform-action | exceed-action | violate-action
            uses police-action-grouping;

            // policy-map * / class * / police / conform-color
            container conform-color {
              tailf:info "conform color aware";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf class-map-name {
                tailf:cli-drop-node-name;
                tailf:non-strict-leafref {
                  path "/ios:class-map/name";
                }
                type string {
                  tailf:info "WORD;;class-map name for conform color aware";
                }
              }
              leaf exceed-color {
                tailf:info "exceed color aware";
                tailf:non-strict-leafref {
                  path "/ios:class-map/name";
                }
                type string {
                  tailf:info "WORD;;lass-map name for exceed color aware";
                }
              }
            }
          }
        }
      }

      // police cir percent (combo of percent & policy-map versions)
      // police cir percent <percentage>
      //    [bc] <burst> ms] [be [<burst> ms]
      //    [pir percent <percentage> [be <burst> ms]] ACTIONS
      case police-cir-percent-case {
        container police-cir-percent {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container cir {
              tailf:info "Committed information rate";
              container percent {
                tailf:info "% of interface bandwidth for Committed "+
                  "information rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-incomplete-command;
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // percent <percentage>
                leaf percentage {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type percentage-type;
                }
                // [bc <burst> ms]
                leaf bc {
                  tailf:info "Conform burst";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container bc-ms {
                  when "../bc" {
                    tailf:dependency "../bc";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [be [<burst> ms]
                leaf be {
                  when "../bc-ms/ms" {
                    tailf:dependency "../bc-ms/ms";
                  }
                  tailf:info "Excess burst";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst ms";
                  }
                }
                container be-ms {
                  when "../be" {
                    tailf:dependency "../be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // [pir percent <percentage> [be <burst> ms]]
                container pir {
                  tailf:info "Peak Information Rate";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  leaf percent {
                    tailf:info "% of interface bandwidth for Peak "+
                      "Information Rate";
                    type percentage-type;
                  }
                }
                container pir-be {
                  when "../pir" {
                    tailf:dependency "../pir";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-hide-in-submode;
                  leaf be {
                    tailf:info "Excess burst";
                    type uint16 {
                      tailf:info "<1-2000>;;Burst ms";
                    }
                  }
                }
                container pir-be-ms {
                  when "../pir-be/be" {
                    tailf:dependency "../pir-be/be";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police rate (control-plane)
      // police rate <units> <pps|bps> [burst <burst-in-x> [<packets|bytes>]]
      //   [peak-rate <peak-rate-in-xps> [<pps|bps>]]
      //   [peak-burst <peak-burst-in-x> [<packets|bytes>]]
      //   [conform-action <action>]
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }

              // <units>
              leaf "units" {
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "<1-2000000000>;;Rate value in the range "+
                    "8000-2,000,000,000 bps or 1-2,000,000 pps";
                }
              }
              // <pps|bps>
              leaf xps {
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-pps-bps-type;
              }

              // [burst <burst-in-x> <packets|bytes>]
              leaf burst {
                tailf:info "Specify 'burst' parameter";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Burst value in "+
                    "packets/bytes";
                }
              }
              leaf burst-type {
                when "../burst" {
                  tailf:dependency "../burst";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-packets-bytes-type;
              }

              // [peak-rate <peak-rate-in-xps> <pps|bps>]
              leaf peak-rate {
                tailf:info "Specify peak rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Peak-rate value in "+
                    "packets or bytes per second";
                  range "1..512000000";
                }
              }
              leaf peak-rate-type {
                when "../peak-rate" {
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-pps-bps-type;
              }

              // [peak-burst <peak-burst-in-x> <packets|bytes>]
              leaf peak-burst {
                tailf:info "Specify 'peak-burst' parameter for peak-rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-512000000>;;Burst value in "+
                    "packets/bytes";
                }
              }
              leaf peak-burst-type {
                when "../peak-burst" {
                  tailf:dependency "../peak-burst";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-packets-bytes-type;
              }

              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }


      // police rate percent (control-plane)
      // police rate percent <percentage> [burst <ms> ms]
      //    [peak-rate percent <percentage>] [peak-burst <ms> ms]
      case police-rate-percent-case {
        container police-rate-percent {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              container percent {
                tailf:info "% of interface bandwidth for rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // <percentage>
                leaf percentage {
                  tailf:cli-drop-node-name;
                  tailf:cli-hide-in-submode;
                  type percentage-type;
                }
                // [burst <ms> ms]
                leaf burst {
                  tailf:info "Specify 'burst' parameter";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  type uint16 {
                    tailf:info "<1-2000>;;Burst value in milliseconds";
                  }
                }
                leaf ms {
                  when "../burst" {
                    tailf:dependency "../burst";
                  }
                  tailf:info "Treat 'burst' value in milliseconds";
                  tailf:cli-hide-in-submode;
                  type empty;
                }
                // [peak-rate percent <percentage>]
                container peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "% of interface bandwidth for peak-rate";
                    type percentage-type;
                  }
                }
                // [peak-burst <ms> ms]
                leaf peak-burst {
                  tailf:info "Specify 'peak-burst' parameter for "+
                    "'peak-rate'";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type uint16 {
                    tailf:info "<1-2000>;;Peak burst value in "+
                      "milliseconds";
                  }
                }
                container peak-burst-ms {
                  when "../peak-burst" {
                    tailf:dependency "../peak-burst";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  tailf:cli-hide-in-submode;
                  tailf:cli-flatten-container;
                  leaf ms {
                    tailf:info "Milli seconds";
                    tailf:cli-no-keyword;
                    type empty;
                  }
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police rate pdp
      // police rate pdp [burst <bytes>]
      //    [peak-rate pdp [peak-burst <bytes>]] ACTIONS
      case police-rate-pdp-case {
        container police-rate-pdp {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Specify police rate";
              container pdp {
                tailf:info "% of interface bandwidth for rate";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-pmap-c-police";
                tailf:cli-flatten-container;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                // [burst <bytes>]
                leaf burst {
                  tailf:info "Conform burst";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // [peak-rate pdp [peak-burst <bytes>]]
                leaf peak-rate {
                  tailf:info "Specify peak rate";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type enumeration {
                    enum "pdp" {
                    }
                  }
                }
                leaf peak-burst {
                  when "../peak-rate" {
                    tailf:dependency "../peak-rate";
                  }
                  tailf:info "Specify 'peak-burst' parameter for 'peak-rate'";
                  tailf:cli-hide-in-submode;
                  tailf:cli-optional-in-sequence;
                  type police-burst-type;
                }
                // conform-action | exceed-action | violate-action
                uses police-action-grouping;
              }
            }
          }
        }
      }

      // police flow (policy-map)
      // police flow [mask {dest-only | full-flow | src-only}]
      //    <bps> [<burst-normal>] ACTIONS
      case police-flow-case {
        container police-flow {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container flow {
              tailf:info "police each flow";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-pmap-c-police";
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // [mask {dest-only | full-flow | src-only}]
              leaf mask {
                tailf:info "flow mask to be used for policing";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type enumeration {
                  enum dest-only {
                    tailf:info "destination-address only flow mask";
                  }
                  enum full-flow {
                    tailf:info "full flow mask";
                  }
                  enum src-only {
                    tailf:info "source-address only flow mask";
                  }
                }
              }
              // <bps>
              leaf bps {
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                type police-bps-type;
              }
              // [<burst-normal>]
              leaf burst-normal {
                when "../bps" {
                    tailf:dependency "../bps";
                  }
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type police-burst-type;
              }
              // conform-action | exceed-action | violate-action
              uses police-action-grouping;
            }
          }
        }
      }

      // police "bpsflat" - (Catalyst 4500)
      // police <bps> bps <byte> byte ACTIONS
      case police-bpsflat-case {
        container police-catalyst { // NEW: police-bpsflat
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-pmap-c-police";
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'bpsflat')" {
              tailf:dependency "/ios:tailfned/police";
            }
            // <bps> bps
            leaf bps-value {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<32000-32000000000>;;Rate in bits per second "+
                  "(postfix k, m, g optional; decimal point allowed)";
              }
            }
            leaf bps {
              when "../bps-value" {
                tailf:dependency "../bps-value";
              }
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type empty;
            }
            // <byte> byte
            leaf byte-value {
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<32000-32000000000>;;(postfix k, m, g "+
                  "optional; decimal point allowed)";
              }
            }
            leaf byte {
              when "../byte-value" {
                tailf:dependency "../byte-value";
              }
              tailf:cli-hide-in-submode;
              type empty;
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-hide-in-submode;
              // policy-map * / class * / police ? / conform-action
              uses police-multiple-conform-action-grouping;
              // policy-map * / class * / police ? / exceed-action
              uses police-multiple-exceed-action-grouping;
              // policy-map * / class * / police ? / violate-action
              uses police-multiple-violate-action-grouping;
            }
          }
        }
      }

      // police switch "numflat" - (Catalyst c3550)
      // police <bps> <burst> exceed-action {drop | policed-dscp-transmit}]
      case police-switch-case {
        container police-switch {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'numflat')" {
              tailf:dependency "/ios:tailfned/police";
            }
            // <bps = cir>
            leaf cir {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency
                "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type uint32 {
                tailf:info "<8000-1000000000>;;Bits per second";
                range "8000..1000000000";
              }
            }
            // <burst = bc>
            leaf bc {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<8000-2000000>;;Normal burst bytes";
                range "8000..2000000";
              }
            }
            // exceed-action
            leaf exceed-action {
              tailf:info "action when rate is exceeded";
              type enumeration {
                enum drop {
                  tailf:info "drop packet";
                }
                enum policed-dscp-transmit {
                  tailf:info "change dscp per policed-dscp map and send it";
                }
              }
            }
          }
        }
      }

      // police "numflat"
      // police <bps> [burst-normal] [burst-max] ACTIONS
      case police-numflat-case {
        container police-numflat {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'numflat')" {
              tailf:dependency "/ios:tailfned/police";
            }
            // <bps> (cir)
            leaf cir {
              tailf:cli-drop-node-name;
              tailf:cli-diff-dependency
                "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type police-bps-type;
            }
            // <bc> (burst-normal)
            leaf bc {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // <be> (burst-max)
            leaf be {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-no-keyword;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              // policy-map * / class * / police ? / conform-action
              uses police-multiple-conform-action-grouping;
              // policy-map * / class * / police ? / exceed-action
              uses police-multiple-exceed-action-grouping;
              // policy-map * / class * / police ? / violate-action
              uses police-multiple-violate-action-grouping;
            }
          }
        }
      }

      // police "cirflat" - (Catalyst C3750, C6504)
      // police cir <bps> bc <burst-normal> [pir <bps>] [be <burst-max] ACTIONS
      case police-cirflat-case {
        container police-cirflat {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            when "contains(/ios:tailfned/police, 'cirflat')" {
              tailf:dependency "/ios:tailfned/police";
            }
            // cir <bps>
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-diff-dependency "../../../police-aggregate/police/aggregate" {
                tailf:cli-trigger-on-set;
              }
              type police-bps-type;
            }
            // bc <burst-normal>
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // [pir <bps>]
            leaf pir {
              tailf:info "Peak Information Rate";
              tailf:cli-optional-in-sequence;
              type police-bps-type;
            }
            // [be> <burst-max>]
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-optional-in-sequence;
              type police-burst-type;
            }
            // conform-action | exceed-action | violate-action
            container actions {
              tailf:cli-break-sequence-commands;
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses police-conform-action-grouping;
              uses police-exceed-action-grouping;
              uses police-violate-action-grouping;
            }
          }
        }
      }
    }

    // policy-map * / class * / priority
    container priority {
      tailf:info "Strict Scheduling Priority for this Class";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf level {
        tailf:info "Multi-Level Priority Queue";
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<1-2>;;Multi-Level Priority Queue";
          range "1..2";
        }
      }
      choice priority-type {
        leaf kilo-bits {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<8-10000000>;;Kilo Bits per second";
            range "8..10000000";
          }
        }
        // policy-map * / class * / priority percent
        leaf percent {
          tailf:info "% of total bandwidth";
          tailf:cli-remove-before-change;
          type uint16 {
            tailf:info "<1-100>;;percentage";
            range "1..100";
          }
        }
      }
      leaf burst {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<32-64000000>;;Burst in bytes";
          range "32..64000000";
        }
      }
    }

    // policy-map * / class * / shape
    container shape {
      tailf:info "Traffic Shaping";

      // policy-map * / class * / shape adaptive
      leaf adaptive {
        tailf:info "Enable Traffic Shaping adaptation to BECN";
        tailf:cli-full-command;
        type uint32 {
          range "8000..154400000";
          tailf:info "<8000-154400000>;;Lower Bound Target Bit "+
            "Rate (bits per second)";
        }
      }

      // policy-map * / class * / shape average
      container average {
        tailf:info "configure token bucket: CIR (bps) [Bc (bits) "+
          "[Be (bits)]], send out Bc only per interval";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice average-choice {
          case a {
            leaf bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<8000-max>;;Target Bit "+
                  "Rate (bits per second), the value "+
                  "needs to be a multiple of 8000";
              }
            }
            leaf bits-per-interval-sustained {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<256-154400000>;;bits per "+
                  "interval, sustained. Needs to be "+
                  "multiple of 128. Recommend not to "+
                  "configure it, the algorithm will "+
                  "find out the best value";
                range "256..154400000";
              }
            }
            leaf bits-per-interval-excess {
              tailf:cli-drop-node-name;
              type uint32 {
                range "0..154400000";
                tailf:info "<0-154400000>;;bits per "+
                  "interval, excess. Needs to be "+
                  "multiple of 128. Bc will be used if "+
                  "you don't configure it.";
              }
            }
          }

          case b {
            leaf percent {
              tailf:info "% of interface bandwidth for "+
                "Committed information rate";
              type percentage-type;
            }
            leaf burst-size-sustained {
              tailf:cli-incomplete-command;
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<10-2000>;;Sustained burst size in msec";
                range "10..2000";
              }
            }
            leaf ms {
              tailf:info "milliseconds";
              type empty;
            }
            container bse {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf burst-size-excess {
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<10-2000>;;Excess burst size in msec";
                  range "10..2000";
                }
              }
              leaf ms {
                tailf:info "milliseconds";
                type empty;
              }
            }
          }

          case c {
            leaf target-bit-rate {
              tailf:cli-drop-node-name;
              type uint64 {
                tailf:info "<8000-max>;;Target Bit "+
                  "Rate (bits per second), the value "+
                  "needs to be a multiple of 8000";
              }
            }
            leaf account {
              tailf:info "Overhead Accounting";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf user-defined {
              tailf:info "Offset Size";
              type int8 {
                tailf:info "<-63 - 63>;;User Defined size";
                range "-63..63";
              }
            }
            leaf atm {
              tailf:info "ATM cell tax";
              type empty;
            }
          }
        }
      }

      // policy-map * / class * / shape fecn-adapt
      leaf fecn-adapt {
        tailf:info "Enable Traffic Shaping reflection of FECN as BECN";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / shape fr-voice-adapt
      container fr-voice-adapt {
        tailf:info "Enable rate adjustment depending on voice presence";
        presence true;
        leaf deactivation {
          type uint16 {
            range "1..10000";
            tailf:info "<1-10000>;;de-activation delay in seconds";
          }
        }
      }

      // policy-map * / class * / shape max-buffers
      leaf max-buffers {
        tailf:cli-full-command;
        tailf:info "Set Maximum Buffer Limit";
        type uint16 {
          tailf:info "<1-4096>;;Maximum Buffer Limit";
          range "1..4096";
        }
      }
    }

    // policy-map * / class * / queue-limit
    container queue-limit {
      tailf:info "Queue Max Threshold for Tail Drop";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "../shape";
      choice queue-limit-choice {

        // policy-map * / class * / queue-limit percent
        case queue-limit-percent {
          leaf percent {
            tailf:info "% of threshold";
            type percentage-type;
          }
        }

        // policy-map * / class * / queue-limit dscp * percent
        case queue-limit-dscp {
          list dscp {
            tailf:info "parameters for each dscp value";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key dscp;
            leaf dscp {
              type dscp-type;
            }
            leaf percent {
              tailf:info "% of threshold";
              type percentage-type;
            }
          }
        }

        case queue-limit-value {
          leaf queue-limit-value {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-8192000>;;in bytes, <1-3400> in ms, "+
                "<1-32768> in packets by default";
              range "1..8192000";
            }
          }
          leaf queue-limit-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum bytes {
                tailf:info "in bytes";
              }
              enum ms {
                tailf:info "in milliseconds";
              }
              enum us {
                tailf:info "in microseconds";
              }
              enum packets {
                tailf:info "in packets";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / random-detect
    container random-detect {
      tailf:info "Enable Random Early Detection as drop policy";

      // policy-map * / class * / random-detect precedence-based  <= hidden!
      // policy-map * / class * / random-detect cos-based
      // policy-map * / class * / random-detect dscp-based
      // policy-map * / class * / random-detect discard-class-based
      // policy-map * / class * / random-detect * aggregate
      container "base" {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-diff-dependency "../../../bandwidth/percent";
          type enumeration {
            enum cos-based {
              tailf:info "Enable cos-class-based WRED as drop policy";
            }
            enum precedence-based  {
              tailf:info "Enable precedence-based WRED as drop policy";
            }
            enum discard-class-based {
              tailf:info "Enable discard-class-based WRED as drop policy";
            }
            enum dscp-based {
              tailf:info "Enable dscp-based WRED as drop policy";
            }
          }
        }
        leaf aggregate {
          tailf:info "aggregate subclasses";
          type empty;
        }
        leaf minimum-thresh {
          tailf:info "minimum threshold for red aggregate";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-1000000>;;minimum threshold (number of packets)";
            range "0..1000000";
          }
        }
        leaf maximum-thresh {
          tailf:info "maximum threshold for red aggregate";
          type uint32 {
            tailf:info "<0-1000000>;;maximum threshold (number of packets)";
            range "0..1000000";
          }
        }
        leaf mark-probability {
          tailf:info "mark-probability for red aggregate";
          type empty;
        }
        leaf denominator {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-65535>;;mark probability denominator";
            range "0..65535";
          }
        }
      }

      // policy-map * / class * / random-detect exponential-weighting-constant
      leaf exponential-weighting-constant {
        tailf:info "weight for mean queue depth calculation";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-16>;;integer in 1..16 used in weighted "+
            "average to mean 2^number";
          range "1..16";
        }
      }

      // policy-map * / class * / random-detect ecn
      leaf ecn {
        tailf:info "explicit congestion notification";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / random-detect cos *
      list cos {
        when "../base/type = 'cos-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each cos value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key cos;
        leaf cos {
          type uint8 {
            tailf:info "<0-7>;;cos value";
            range "0..7";
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence *
      list precedence {
        when "../base/type = 'precedence-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each precedence value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key prec;
        leaf prec {
          type union {
            type uint8 {
              tailf:info "<0-7>;;IP precedence";
              range "0..7";
            }
            type enumeration {
              enum rsvp {
                tailf:info "rsvp traffic";
              }
            }
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect precedence values *
      container precedence-values {
        tailf:cli-drop-node-name;
        list precedence {
          tailf:info "parameters for each precedence value";
          when "../../base/type = 'precedence-based'" {
            tailf:dependency "../../base/type";
          }
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../base/type";
          key values;
          leaf values {
            tailf:info "multiple precedence subclasses";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-7>;;SUBCLASS id";
              range "0..7";
            }
          }
          uses random-detect-values-grouping;
        }
      }

      // policy-map * / class * / random-detect discard-class *
      list discard-class {
        when "../base/type = 'discard-class-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each discard-class value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key dclass;
        leaf dclass {
          type uint16 {
            tailf:info "<0-7>;;discard-class value";
            range "0..7";
          }
        }
        uses random-detect-grouping;
      }

      // policy-map * / class * / random-detect dscp *
      list dscp {
        when "../base/type = 'dscp-based'" {
          tailf:dependency "../base/type";
        }
        tailf:info "parameters for each dscp value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../base/type";
        key dscpvalue;
        leaf dscpvalue {
          type dscp-type;
        }
        uses random-detect-grouping;
      }
    }

    // policy-map * / class * / set
    container set {
      tailf:info "Set QoS values";

      // policy-map * / class * / set atm-clp
      leaf atm-clp {
        tailf:info "Set ATM CLP bit to 1";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / set cos
      container cos {
        tailf:info "Set IEEE 802.1Q/ISL class of service/user priority";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice cos-type {
          case a {
            leaf val {
              tailf:cli-drop-node-name;
              type uint16 {
                range "0..7";
                tailf:info "<0-7>;;cos value";
              }
            }
          }
          case b {
            leaf pack {
              tailf:cli-drop-node-name;
              type enumeration {
                enum dscp {
                  tailf:code-name "pack_dscp";
                  tailf:info "Set value from packet dscp";
                }
                enum precedence {
                  tailf:code-name "pack_precedence";
                  tailf:info "Set value from packet "+
                  "precedence.";
                }
              }
            }
            leaf table {
              tailf:info "Set codepoint value based on tablemap.";
              tailf:non-strict-leafref {
                path "/ios:table-map/name";
              }
              type string {
                tailf:info "WORD;;table-map name";
              }
            }
          }
        }
      }

      // policy-map * / class * / set discard-class
      leaf discard-class {
        tailf:info "Discard behavior identifier";
        tailf:cli-full-command;
        type uint16 {
          range "0..7";
          tailf:info "<0-7>;;Discard Class value";
        }
      }

      // policy-map * / class * / set dscp
      container dscp {
        tailf:info "Set DSCP in IP(v4) and IPv6 packets";

        // policy-map * / class * / set dscp tunnel
        leaf tunnel {
          tailf:info "set tunnel packet dscp";
          tailf:cli-full-command;
          type dscp-type;
        }

        // policy-map * / class * / set dscp
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type dscp-type;
        }
      }

      // policy-map * / class * / set fr-de
      leaf fr-de {
        tailf:info "Set FR DE bit to 1";
        tailf:cli-full-command;
        type empty;
      }

      // policy-map * / class * / set ip
      container ip {
        tailf:info "Set IP specific values";
        choice ip-choice {
          leaf dscp {
            tailf:info "Set IP DSCP (DiffServ CodePointint)";
            type dscp-type;
          }
          container precedence {
            tailf:info "Set IP precedence";
            presence "Set IP precedence";
            leaf precedence-val {
              tailf:cli-drop-node-name;
              type precedence-type;
            }
          }
        }
      }

      // policy-map * / class * / set mpls experimental
      container mpls {
        tailf:info "Set MPLS specific values";
        container experimental {
          tailf:info "Set Experimental value";

          // policy-map * / class * / set mpls experimental imposition
          container imposition {
            tailf:info "Set Experimental value at tag imposition";
            leaf exp-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;Experimental value";
                range "0..7";
              }
            }
          }

          // policy-map * / class * / set mpls experimental topmost
          container topmost {
            tailf:info "Set Experimental value on topmost label";
            leaf exp-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;Experimental value";
                range "0..7";
              }
            }
          }
        }
      }

      // policy-map * / class * / set qos-group
      container qos-group {
        tailf:info "Set QoS Group";
        leaf qos-group-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint8 {
            range "0..99";
          }
        }
      }

      // policy-map * / class * / set precedence
      container precedence {
        tailf:info "Set precedence in IP(v4) and IPv6 packets";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        choice precedence-choice {
          case precedence-value {
            leaf precedence-value {
              tailf:cli-drop-node-name;
              tailf:cli-no-keyword;
              type precedence-type;
            }
          }
          case precedence-from-field {
            leaf from-field {
              tailf:cli-drop-node-name;
              tailf:cli-no-keyword;
              type enumeration {
                enum cos {
                  tailf:info "Set packet precedence from L2 COS";
                }
                enum qos-group {
                  tailf:info "Set packet precedence from QoS Group.";
                }
              }
            }
            leaf table {
              tailf:info "Set packet precedence based on table map.";
              tailf:non-strict-leafref {
                path "/ios:table-map/name";
              }
              type string {
                tailf:info "WORD;;table-map name";
              }
            }
          }
        }
      }
    }

    // policy-map * / class * / service-policy
    leaf service-policy {
      tailf:info "Configure QoS Service Policy";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      tailf:non-strict-leafref {
        path "/ios:policy-map/name";
      }
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    // policy-map * / class * / trust
    leaf trust {
      tailf:info "Set trust value for the class";
      type enumeration {
        enum cos {
          tailf:info "trust value for the class";
        }
        enum dscp {
          tailf:info "trust value for the class";
        }
        enum ip-precedence {
          tailf:info "trust value for the class";
        }
      }
    }

    // policy-map * / class * / distribute service-node-group *
    container distribute {
      tailf:info "Distribute action";
      list service-node-group {
        tailf:info "Distribute to service-node-group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        max-elements 2;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;service-node-group name";
          }
        }
      }
    }

    // policy-map * / class * / monitor-load
    leaf monitor-load {
      tailf:info "Monitor AO";
      tailf:cli-full-command;
      type enumeration {
        enum MS-port-mapper {
          tailf:info "Monitor Microsoft Endpoint Port Mapper load";
        }
        enum cifs {
          tailf:info "Monitor CIFS Accelerator load";
        }
        enum http {
          tailf:info "Monitor HTTP Accelerator load";
        }
        enum ica {
          tailf:info "Monitor ICA Accelerator load";
        }
        enum mapi {
          tailf:info "Monitor MAPI Accelerator load";
        }
        enum nfs {
          tailf:info "Monitor NFS Accelerator load";
        }
        enum ssl {
          tailf:info "Monitor SSL accelerator load";
        }
        enum video {
          tailf:info "Monitor Video Accelerator load";
        }
        enum ice {
        }
      }
    }
  }


  grouping distribute-list-content-grouping {

    // distribute-list <access-list-name> in|out
    leaf access-list-name {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-disallow-value "route-map|prefix|gateway|in|out";
      //tailf:cli-incomplete-command;
      type exp-ip-acl-type;
    }

    // distribute-list prefix-list
    leaf prefix-list {
      tailf:info "Filter connections based on an IPv6 prefix-list";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ipv6/prefix-list/prefixes"; // NESTED
      type string {
        tailf:info "WORD;;Prefix-list name";
      }
    }

    // distribute-list prefix <pfx-list-name> gateway <pfx-list-name> in|out
    leaf "prefix" {
      tailf:info "Filter prefixes in routing updates";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/prefix-list/prefixes"; // NESTED
      type string {
        tailf:info "WORD;;Name of an IP prefix-list";
      }
    }
    leaf gateway {
      tailf:info "Filtering incoming updates based on gateway";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "/ios:ip/prefix-list/prefixes"; // NESTED
      type string {
        tailf:info "WORD;;Name of an IP prefix-list";
      }
    }

    // distribute-list prefix routemap <route-map-name> in|out
    leaf route-map {
      tailf:info "Filter prefixes based on the route-map";
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;route-map name";
      }
    }
  }

  grouping redistribute-ospf-match-grouping {

    leaf match {
      tailf:info "Redistribution of OSPF routes";
      tailf:cli-incomplete-command;
      type empty;
    }

    leaf internal {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:info "Redistribute OSPF internal routes";
      type empty;
    }

    container external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }

    container external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }

    container nssa-external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }

    container nssa-external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }

  // router rip
  // router ospf *
  // router bgp *
  // router eigrp * / address-family * / topology base /
  // router isis
  grouping router-distribute-list-grouping {

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        tailf:cli-diff-dependency "../../distribute-list-interface/distribute-list" {
          tailf:cli-trigger-on-set;
        }
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-remove-before-change;
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface"; // NESTED
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        uses distribute-list-content-grouping;
      }
    }
  }

  // router rip /
  // router eigrp * /
  grouping router-offset-list-grouping {

    list offset-list {
      tailf:info "Add or subtract offset from metrics";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key direction;
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type union {
          type uint32 {
            tailf:info "<0-99>;;Access list of networks to apply offset "
              +"(0 selects all networks)";
            range "0..99";
          }
          type uint32 {
            tailf:info "<1300-1999>;;Access list of networks to apply offset "
              +"(expanded range)";
            range "1300..1999";
          }
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Perform offset on incoming updates";
          }
          enum out {
            tailf:info "Perform offset on outgoing updates";
          }
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-16>;;Offset";
          range "0..16";
        }
      }
    }

    container offset-list-interface {
      tailf:cli-drop-node-name;
      list offset-list {
        tailf:info "Add or subtract offset from metrics";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key "direction interface";
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type union {
            type uint32 {
              tailf:info "<0-99>;;Access list of networks to apply offset "
                +"(0 selects all networks)";
              range "0..99";
            }
            type uint32 {
              tailf:info "<1300-1999>;;Access list of networks to apply offset "
                +"(expanded range)";
              range "1300..1999";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Perform offset on incoming updates";
            }
            enum out {
              tailf:info "Perform offset on outgoing updates";
            }
          }
        }
        leaf offset {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type uint32 {
            tailf:info "<0-2147483647>;;Offset";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface"; // NESTED
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  }

  // router rip *
  // router ospf *
  // router isis
  // router isis *
  grouping passive-interface-grouping {

    // router rip * / passive-interface
    container passive-interface {
      tailf:info "Suppress routing updates on an interface";
      choice passive-interface-choice {
        // router rip * / passive-interface default
        leaf "default" {
          tailf:info "Suppress routing updates on all interfaces";
          type empty;
        }
        // router rip * / passive-interface *
        list interface {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/ios:interface"; // NESTED
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
        }
      }
    }

    // Fix to handle showing "no passive-interface <ifname>"
    // Replace 'disable passive-interface <ifname> with
    // "no passive-interface <ifname>"
    container disable {
      tailf:info "Use with 'disable passive-interface' for "+
        "'no passive-interface' config";
      when "../passive-interface/default"  {
        tailf:dependency "../passive-interface/default";
      }
      tailf:cli-diff-dependency "../passive-interface/default";
      list passive-interface {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key interface;
        leaf interface {
          tailf:cli-multi-word-key;
          tailf:cli-diff-dependency "/ios:interface"; // NESTED
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }
  }


  // ip-community-list-grouping
  grouping ip-community-list-grouping {

    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key expr;
      leaf expr {
        tailf:cli-multi-word-key {
          tailf:cli-max-words 11;
        }
        type string {
          tailf:info "<RULE>;;deny <options> | permit <options>";
          pattern "(permit.*)|(deny.*)";
        }
      }
    }
  }

  // ip-extcommunity-list-grouping
  grouping ip-extcommunity-list-grouping {

    list entry {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key expr;
      leaf expr {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
          pattern "(permit.*)|(deny.*)";
        }
      }
    }

  }


  // ip-route-options-grouping
  grouping ip-route-options-grouping {
    leaf dhcp {
      tailf:info "Default Gateway obtained from DHCP";
      tailf:cli-optional-in-sequence;
      tailf:cli-case-insensitive;
      type empty;
    }
    leaf metric {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-255>;;Distance metric for this route";
        range "1..255";
      }
    }
    leaf global {
      tailf:info "Next hop address is global";
      type empty;
    }
    leaf name {
      tailf:info "Specify name of the next hop";
      type string {
        tailf:info "WORD;;Name of the next hop";
      }
    }
    leaf permanent {
      tailf:info "permanent route";
      type empty;
    }
    leaf multicast {
      tailf:info "multicast route";
      type empty;
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Tag value";
        range "1..4294967295";
      }
    }
    leaf track {
      tailf:info "Install route depending on tracked item";
      type uint16 {
        tailf:info "<1-1000>;;tracked object number";
        range "1..1000";
      }
    }
  }

  // ip-route-grouping
  grouping ip-route-grouping {

    list ip-route-interface-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask interface forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf forwarding-address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Forwarding router's address";
          }
          type enumeration {
            enum multicast {
              tailf:info "multicast route";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }

    list ip-route-forwarding-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask forwarding-address";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf forwarding-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Forwarding router's address";
        }
      }
      uses ip-route-options-grouping;
    }

    list ip-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      key "prefix mask interface";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination prefix mask";
        }
      }
      leaf interface {
        tailf:cli-disallow-value "metric|global|name|permanent|multicast|tag|track";
        type union {
          type string {
            tailf:info "WORD;;Interface name";
          }
          type enumeration {
            enum dhcp {
              tailf:info "Default Gateway obtained from DHCP";
            }
          }
        }
      }
      uses ip-route-options-grouping;
    }
  }

  // ipv6-route-options-grouping
  grouping ipv6-route-options-grouping {
    leaf distance {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type uint8 {
        tailf:info "<1-254>;;Administrative distance";
        range "1..254";
      }
    }
    choice type-choice {
      leaf multicast {
        tailf:info "Route only usable by multicast";
        tailf:cli-full-command;
        type empty;
      }
      leaf unicast {
        tailf:info "Route only usable by unicast";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Tag value";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Tag value";
      }
    }
  }

  // ipv6-route-grouping
  grouping ipv6-route-grouping {
    list ipv6-route-interface-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix interface destination";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "../../../../../interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;
    }
    list ipv6-route-destination-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix destination";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf destination {
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address of next-hop";
        }
      }
      uses ipv6-route-options-grouping;

    }
    list ipv6-route-interface-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "prefix interface";
      leaf "prefix" {
        tailf:cli-disallow-value "vrf";
        type ipv6-prefix {
          tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
        }
      }
      leaf interface {
        tailf:cli-diff-dependency "../../../../../interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      uses ipv6-route-options-grouping;
    }
  }

  // random-detect-grouping
  grouping random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<1-262143>;;minimum threshold (in packet by default)";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum bytes {
          tailf:info "number of bytes";
        }
        enum ms {
          tailf:info "milliseconds";
        }
        enum us {
          tailf:info "microseconds";
        }
      }
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-262143>;;maximum threshold (number of packets)";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum bytes {
          tailf:info "number of bytes";
        }
        enum ms {
          tailf:info "milliseconds";
        }
        enum us {
          tailf:info "microseconds";
        }
      }
    }
    leaf denominator {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-65535>;;mark probability denominator";
      }
    }
  }

  // random-detect-values-grouping
  grouping random-detect-values-grouping {
    leaf minimum-thresh {
      tailf:info "minimum threshold for red aggregate";
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<1-512000000>;;minimum threshold (number of packets)";
      }
    }
    leaf maximum-thresh {
      tailf:info "maximum threshold for red aggregate";
      type uint32 {
        tailf:info "<1-512000000>;;maximum threshold (number of packets)";
      }
    }
    leaf mark-prob {
      tailf:info "mark-probability for red aggregate";
      type uint32 {
        tailf:info "<0-65535>;;mark probability denominator";
        range "0..65535";
      }
    }
  }

  // class-map-match-grouping
  grouping class-map-match-grouping {

    // class-map * / match access-group
    container access-group {
      tailf:info "Access group";
      leaf-list index {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        type uint32 {
          tailf:info "<1-2799>;;Access list index";
          range "1..2799";
        }
      }
      leaf-list name {
        tailf:info "Named Access List";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Access List name";
        }
      }
    }

    // class-map * / match any
    leaf any {
      tailf:info "Any packets";
      type empty;
    }

    // class-map * / match class-map
    leaf-list class-map {
      tailf:info "Class map";
      tailf:cli-list-syntax;
      tailf:non-strict-leafref {
        path "/ios:class-map/name";
      }
      type string {
        tailf:info "WORD;;Match class-map name";
      }
    }

    // class-map * / match cos
    leaf-list cos {
      tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
      tailf:cli-flat-list-syntax;
      tailf:cli-disallow-value "inner";
      max-elements 8;
      type uint16 {
        tailf:info "<0-7>;;Enter up to 8 class-of-service values"+
          " separated by white-spaces";
        range "0..7";
      }
    }

    // class-map * / match cos inner
    container cos-inner {
      tailf:cli-drop-node-name;
      container cos {
        tailf:info "IEEE 802.1Q/ISL class of service/user priority values";
        leaf-list inner {
          tailf:info "ATM VC configured as Access VC class of service/user "+
            "priority values";
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint16 {
            tailf:info "<0-7>;;Enter up to 8 class-of-service values"+
              " separated by white-spaces";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match destination-address
    container destination-address {
      tailf:info "Destination address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match discard-class
    leaf-list discard-class {
      tailf:info "Discard behavior identifier";
      tailf:cli-list-syntax;
      type uint8 {
        tailf:info "<0-7>;;Discard Class value";
        range "0..7";
      }
    }

    // class-map * / match dscp *
    leaf-list dscp {
      tailf:info "Match DSCP in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      tailf:cli-full-command;
      tailf:meta-data "max-values" {
        tailf:meta-value "2 :: 8"; // values start after 2 words, max 8 per line
      }
      type dscp-type;
    }

    // class-map * / match fr-de
    leaf fr-de {
      tailf:info "Match on Frame-relay DE bit";
      type empty;
    }

    // class-map * / match fr-dlci
    leaf-list fr-dlci {
      tailf:info "Match on fr-dlci";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<16-1007>;;frame-relay dlci number";
        range "16..1007";
      }
    }

    // class-map * / match input-interface
    leaf-list input-interface {
      tailf:info "Select an input interface to match";
      tailf:cli-list-syntax;
      type string {
        tailf:info "WORD;;Interface name";
      }
    }

    // class-map * / match ip
    container ip {
      tailf:info "IP specific values";
      // class-map * / ip dscp
      leaf-list dscp {
        tailf:info "Match IP DSCP (DiffServ CodePoints)";
        tailf:cli-flat-list-syntax;
        type dscp-type;
      }
      // class-map * / ip precedence
      leaf-list precedence {
        tailf:info "Match IP precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      // class-map * / ip rtp *
      list rtp {
        tailf:info "Match RTP port nos";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "port1 port2";
        leaf port1 {
          type uint16 {
            tailf:info "<2000-65535>;;Lower bound of UDP"+
              " destination port";
            range "2000..65535";
          }
        }
        leaf port2 {
          type uint16 {
            tailf:info "<0-16383>;;Range of UDP ports";
            range "0..16383";
          }
        }
      }
    }

    // class-map * / match mpls experimental topmost *
    container mpls {
      tailf:info "Multi Protocol Label Switching specific values";
      container experimental {
        tailf:info "Match MPLS experimental";
        leaf-list topmost  {
          tailf:info "Match MPLS experimental value on topmost label";
          tailf:cli-flat-list-syntax;
          type uint16 {
            tailf:info "<0-7>;;Enter up to 8 experimental values "+
              "separated by white-spaces";
            range "0..7";
          }
        }
      }
    }

    // class-map * / match precedence *
    leaf-list precedence {
      tailf:info "Match Precedence in IP(v4) and IPv6 packets";
      tailf:cli-flat-list-syntax;
      type precedence-type;
    }

    // class-map * / match protocol
    container protocol {
      tailf:info "Protocol";

      // class-map * / match protocol attribute
      container attribute {
        tailf:info "Attribute based protocol match";

        // class-map * / match protocol attribute category *
        list category {
          tailf:info "Category attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key category-type;
          leaf category-type {
            type enumeration {
              enum "voice-and-video" {
                tailf:info "Filter incoming connections";
              }
              enum "database" {
                tailf:info "Filter outgoing connections";
              }
              enum "email" {
                tailf:info "Email related applications";
              }
              enum "browsing" {
                tailf:info "Browsing related applications";
              }
              enum "trojan" {
                tailf:info "Trojan related applications";
              }
              enum "gaming" {
                tailf:info "Gaming related applications";
              }
              enum "anonymizers" {
                tailf:info "Anonymizers applications";
              }
              enum "backup-and-storage" {
                tailf:info "Backup and storage related applications";
              }
              enum "business-and-productivity-tools" {
                tailf:info "Business-and-productivity-tools related "+
                  "applications";
              }
              enum "epayement" {
                tailf:info "Epayement related applications";
              }
              enum "file-sharing" {
                tailf:info "File-sharing related applications";
              }
              enum "industrial-protocols" {
                tailf:info "Industrial-protocols related applications";
              }
              enum "instant-messaging" {
                tailf:info "Instant-messaging related applications";
              }
              enum "inter-process-rpc" {
                tailf:info "Inter-process-rpc related applications";
              }
              enum "internet-security" {
                tailf:info "Internet security related applications";
              }
              enum "layer3-over-ip" {
                tailf:info "Layer3-over-IP related applications";
              }
              enum "location-based-services" {
                tailf:info "Location-based-services related applications";
              }
              enum "net-admin" {
                tailf:info "Net-admin related applications";
              }
              enum "newsgroup" {
                tailf:info "Newsgroup related applications";
              }
              enum "other" {
                tailf:info "Other related applications";
              }
              enum "social-networking" {
                tailf:info "Social-networking related applications";
              }
              enum "software-updates" {
                tailf:info "Software updates and downloads related "+
                  "applications";
              }
            }
          }
        }

        // class-map * / match protocol attribute traffic-class *
        list traffic-class {
          tailf:info "traffic-class attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key traffic-class-type;
          leaf traffic-class-type {
            type enumeration {
              enum "broadcast-video" {
                tailf:info "Broadcast TV, live events, video surveillance";
              }
              enum "bulk-data" {
                tailf:info "Non-interactive data applications";
              }
              enum "multimedia-conferencing" {
                tailf:info "Desktop software multimedia collaboration applications";
              }
              enum "multimedia-streaming" {
                tailf:info "Video-on-Demand (VoD) streaming video";
              }
              enum "network-control" {
                tailf:info "Network control plane traffic";
              }
              enum "ops-admin-mgmt" {
                tailf:info "Network operations, administration, and management";
              }
              enum "real-time-interactive" {
                tailf:info "High-definition interactive video applications";
              }
              enum "signaling" {
                tailf:info "Signaling traffic that supports IP voice and video telephony";
              }
              enum "transactional-data" {
                tailf:info "Interactive data applications";
              }
              enum "voip-telephony" {
                tailf:info "VoIP telephony (bearer-only) traffic";
              }
            }
          }
        }

        // class-map * / match protocol attribute business-relevance *
        list business-relevance {
          tailf:info "business-relevance attribute";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key business-relevance-type;
          leaf business-relevance-type {
            type enumeration {
              enum "business-irrelevant" {
                tailf:info "Undesirable business traffic";
              }
              enum "business-relevant" {
                tailf:info "Business critical applications";
              }
              enum "default" {
                tailf:info "Related business applications";
              }
            }
          }
        }
      }

      // class-map * / match protocol *
      list protocol-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-disallow-value "attribute";
          type string {
            tailf:info "WORD;;protocol";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "value";
          leaf "value" {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }
    }

    // class-map * / match packet length min *
    // class-map * / match packet length max *
    // class-map * / match packet length min * max *
    container packet {
      tailf:info "Layer 3 Packet length";
      list "length" {
        tailf:info "Layer 3 Packet length";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key line;
        leaf line {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "LINE;;min X | max X | min X max Y";
            pattern '(min \d+)|(max \d+)|(min \d+ max \d+)';
          }
        }
      }
    }

    // class-map * / match qos-group *
    leaf-list qos-group {
      tailf:info "Qos-group";
      tailf:cli-list-syntax;
      type uint16 {
        tailf:info "<0-99>;;Qos Group value";
        range "0..99";
      }
    }

    // class-map * / match source-address *
    container source-address {
      tailf:info "Source address";
      leaf-list mac {
        tailf:info "MAC address";
        tailf:cli-list-syntax;
        type string {
          tailf:info "H.H.H;;MAC address";
        }
      }
    }

    // class-map * / match vlan *
    leaf-list vlan {
      tailf:info "VLANs to match";
      tailf:cli-range-list-syntax;
      type uint16 {
        tailf:info "<1-4094>;;VLAN id";
        range "1..4094";
      }
    }

    // class-map * / match service instance ethernet *
    container service {
      tailf:info "Service Instance to match";
      container instance {
        tailf:info "Service Instance to match";
        leaf-list ethernet {
          tailf:info "Service Instance to match";
          tailf:cli-list-syntax;
          type uint32 {
            tailf:info "<1-4294967295>;;Service Instance Identifier";
          }
        }
      }
    }
  }

  // ip-name-server-grouping
  grouping ip-name-server-grouping {
    list name-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      max-elements 6;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Domain server IP address (maximum of 6)";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Domain server IPv6 address (maximum of 6)";
          }
        }
      }
    }
  }

  // ip-host-grouping
  grouping ip-host-grouping {
    list host-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key hostname;
      leaf hostname {
        tailf:cli-disallow-value "vrf";
        type string {
          tailf:info "WORD;;Name of host";
        }
      }
      leaf tcp-port-number {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Default telnet port number";
        }
      }
      leaf-list ip-address1 {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Host IP address";
        }
      }
    }
  }

  // ip-dhcp-excluded-address-grouping
  grouping ip-dhcp-excluded-address-grouping {
    list low-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key low;
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
    }
    list low-high-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "low high";
      leaf low {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Low IP address";
        }
      }
      leaf high {
        tailf:cli-disallow-value "vrf";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;High IP address";
        }
      }
    }
  }

  // ntp-peer-grouping
  grouping ntp-peer-grouping {
    list peer-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
        }
      }
      leaf burst {
        tailf:info "Send a burst when peer is reachable (Default)";
        type empty;
      }
      leaf iburst {
        tailf:info "Send a burst when peer is unreachable (Default)";
        type empty;
      }
      leaf "key" {
        tailf:info "Configure peer authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Peer key number";
          range "1..4294967295";
        }
      }
      leaf maxpoll {
        tailf:info "Maximum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf minpoll {
        tailf:info "Minimum poll interval";
        type uint8 {
          tailf:info "<4-17>;;Poll value in Log2";
          range "4..17";
        }
      }
      leaf normal-sync {
        tailf:info "Disable rapid sync at startup";
        type empty;
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }

  // sntp-server-grouping
  grouping sntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value "vrf";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
        }
      }
      leaf "key" {
        tailf:info "Configure server authentication key";
        type uint32 {
          tailf:info "<1-4294967295>;;Server key number";
          range "1..4294967295";
        }
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
        }
      }
    }
  }

  // line-grouping
  grouping line-grouping {

    // line * / location
    leaf location {
      tailf:info "Enter terminal location description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;One text line describing the terminal's location";
      }
    }

    // line * / absolute-timeout
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes";
      }
    }

    // line * / access-class
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      list access-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
        leaf vrf-also {
          tailf:info "Same access list is applied for all VRFs";
          type empty;
        }
      }
    }

    // line * / no flush-at-activation
    leaf flush-at-activation {
      tailf:info "Clear input stream at activation";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // line * / activation-character
    container activation-character-choice {
      tailf:cli-drop-node-name;
      choice activation-character-choice {
        // line * / no activation-character
        leaf activation-character {
          tailf:info "Define the activation character";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        // line * / activation-character
        container activation-character-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf activation-character {
            type string {
              tailf:info "CHAR or <0-127>;;Activation character or "+
                "its decimal equivalent";
            }
          }
        }
      }
    }

    // line * / escape-character
    leaf escape-character {
      tailf:info "Change the current line's escape character";
      type union {
        type uint8 {
          tailf:info "ASCII decimal equivalent";
        }
        type enumeration {
          enum BREAK {
            tailf:info "Cause escape on BREAK";
          }
          enum DEFAULT {
            tailf:info "Use default escape character";
          }
          enum NONE {
            tailf:info "Disable escape entirely";
          }
        }
      }
    }

    // line * / script
    container script {
      tailf:info "specify event related chat scripts to run on the line";
      leaf dialer {
        tailf:info "chat script to run whenever dialer makes an outgoing call";
        tailf:non-strict-leafref {
          path "/ios:chat-script/name";
        }
        type string {
          tailf:info "WORD;;chat script name";
        }
      }
    }

    // line * / modem
    container modem {
      tailf:info "Configure the Modem Control Lines";

      // line * / modem enable
      leaf enable {
        tailf:info "Console port is used for connecting modem";
        tailf:cli-boolean-no;
        type boolean;
      }

      // line * / modem InOut
      leaf InOut {
        tailf:info "Configure line for incoming AND outgoing use of modem";
        type empty;
      }

      // line * / modem autoconfigure
      container autoconfigure {
        tailf:info "Automatically configure modem on line";

        // line * / modem autoconfigure discovery
        leaf discovery {
          tailf:info "Attempt to determine modem type automatically";
          type empty;
        }

        // line * / modem autoconfigure type
        leaf "type" {
          tailf:info "Specify modem type";
          type string {
            tailf:info "WORD;;Modem type";
          }
        }
      }
    }

    // line * / exec
    container exec-choice {
      tailf:cli-drop-node-name;
      choice exec-choice {
        // line * / no exec
        default exec;
        leaf exec {
          tailf:info "Configure EXEC";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        // line * / exec prompt
        container exec-conf {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container exec {
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            container prompt {
              tailf:info "EXEC prompt";
              leaf timestamp {
                tailf:info "Print timestamps for show commands";
                type empty;
              }
            }
          }
        }
      }
    }

    // line * / exec-timeout
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
        }
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
        }
      }
    }

    // line * / timeout login response
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeout for any user input during login sequences";
          type uint16 {
            tailf:info "<1-300>;;Timeout in seconds";
            range "1..300";
          }
        }
      }
    }

    // line * /  session-disconnect-warning
    container session-disconnect-warning {
      tailf:info "Set warning countdown for session-timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Session timeout warning in seconds";
        }
      }
      leaf message {
        tailf:info "Optional warning message";
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;One text line optional warning message";
        }
      }
    }

    // line * / logging
    container logging {
      tailf:info "Modify message logging facilities";
      // line * / logging synchronous
      container synchronous {
        tailf:info "Synchronized message output";
        tailf:cli-delete-when-empty;
        presence true;
        // line * / logging synchronous level
        leaf level {
          tailf:info "Severity level to output asynchronously";
          type union {
            type uint8 {
              tailf:info "<0-7>;;Severity level; lower number for higher severity";
              range "0..7";
            }
            type enumeration {
              enum all {
                tailf:info "Turn off all severity level for asynchronous output";
              }
            }
          }
        }
      }
    }

    // line * / rotary
    leaf rotary {
      tailf:info "Add line to a rotary group";
      type uint8 {
        tailf:info "<0-100>;;Rotary group to add line to";
        range "0..100";
      }
    }

    // line * / login
    container login {
      tailf:info "Enable password checking";
      tailf:cli-delete-when-empty;
      presence true;

      // line * / login local
      leaf local {
        tailf:info "Local password checking";
        type empty;
      }
    }

    // line * / login authentication
    // line * / login tacacs
    container local-authentication {
      tailf:cli-drop-node-name;
      container login {
        tailf:info "Enable password checking";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        leaf tacacs {
          type empty;
        }

        leaf authentication {
          tailf:info "Authentication parameters.";
          type union {
            type string {
              tailf:info "WORD;;Use an authentication list with this name.";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default authentication list.";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / autocommand
    container autocommand {
      tailf:info "Automatically execute an EXEC command";
      leaf command {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Appropriate EXEC command";
        }
      }
    }

    // line * / accounting
    container accounting {
      tailf:info "Accounting parameters";

      // line * / accounting exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
          type enumeration {
            enum "default" {
              tailf:info "Use the default accounting list.";
            }
          }
        }
        default "default";
      }

      // line * / accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key level;
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "WORD;;Use an accounting list with this name";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default accounting list";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / logout-warning
    leaf logout-warning {
      tailf:info "Set Warning countdown for absolute timeout of line";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Warning time in seconds";
      }
    }

    // line * / ipv6 access-class *
    container ipv6 {
      tailf:info "IPv6 options";
      list access-class {
        tailf:info "Filter connections based on an IPv6 access list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming connections";
            }
            enum "out" {
              tailf:info "Filter outgoing connections";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }
    }

    // line * / authorization exec
    container authorization {
      tailf:info "Authorization parameters";

      // line * / authorization exec
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
        default "default";
      }

      // line * / authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key level;
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          type union {
            type string {
              tailf:info "WORD;;Use an authorization list with this name";
            }
            type enumeration {
              enum "default" {
                tailf:info "Use the default authorization list";
              }
            }
          }
          default "default";
        }
      }
    }

    // line * / history size
    container history {
      tailf:info "Enable and control the command history function";
      leaf size {
        tailf:info "Set history buffer size";
        type uint16 {
          tailf:info "<0-256>;;Size of history buffer";
          range "0..256";
        }
      }
    }

    // line * / full-help
    leaf full-help {
      tailf:info "Provide help to unprivileged user";
      type empty;
    }

    // line * / password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }

    // line * / privilege
    container privilege {
      tailf:info "Change privilege level for line";
      leaf level {
        tailf:info "Assign default privilege level for line";
        type uint8 {
          tailf:info "<0-15>;;Default privilege level for line";
          range "0..15";
        }
      }
    }

    // line * / session-timeout
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no "+
        "input traffic";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf session-timeout-value {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf "output" {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }

    // line * / stopbits
    leaf stopbits {
      tailf:info "Set async line stop bits";
      type enumeration {
        enum "1" {
          tailf:info "One stop bit";
        }
        enum "1.5" {
          tailf:info "One and one-half stop bits";
        }
        enum "2" {
          tailf:info "Two stop bits";
        }
      }
    }

    // line * / telnet
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of "+
          "a CR followed by a LF";
        type empty;
      }
    }

    // line * / transport
    container transport {
      tailf:info "Define transport protocols for line";
      tailf:cli-incomplete-no;

      // line * / transport input
      leaf-list "input" {
        tailf:info "Define which protocols to use when connecting "+
          "to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {}
          enum mop {}
          enum v120 {}
          enum acercon {}
        }
      }

      // line * / transport output
      leaf-list "output" {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat {
            tailf:info "DEC LAT protocol";
          }
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
          enum lapb-ta {}
          enum mop {}
          enum v120 {}
        }
      }

      // line * / transport preferred
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }

    // line * / speed
    leaf speed {
      tailf:info "Set the transmit and receive speeds";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Transmit and receive speeds";
      }
    }

    // line * / rxspeed
    leaf rxspeed {
      tailf:info "Set the receive speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Receive speed";
      }
    }

    // line * / txspeed
    leaf txspeed {
      tailf:info "Set the transmit speed";
      type uint32 {
        tailf:info "<0-4294967295>;;Transmit speed";
      }
    }

    // line * / flowcontrol
    leaf flowcontrol {
      tailf:info "Set the flow control";
      type enumeration {
        enum hardware {
          tailf:info "Set hardware flow control";
        }
        enum software {
          tailf:info "Set software flow control";
        }
      }
    }

    // line * / length
    leaf "length" {
      tailf:info "Set number of lines on a screen";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing)";
        range "0..512";
      }
    }

    // line * / width
    leaf width {
      tailf:info "Set width of the display terminal";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "Number of characters on a screen line";
        range "0..512";
      }
    }

  }

  // queue-size-grouping
  grouping queue-size-grouping {
    leaf queue-size-1 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-2 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-3 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-4 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-5 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-6 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-7 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
    leaf queue-size-8 {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-100>;;enter percent of queue size between 1 "
          +"and 100";
        range "1..100";
      }
    }
  }

  // grouping interface-common-pre-grouping
  grouping interface-common-pre-grouping {

    // interface * / mac-address
    leaf mac-address {
      tailf:info "Manually set interface MAC address";
      type string {
        tailf:info "H.H.H;;MAC address";
      }
    }

    // interface * / description
    leaf "description" {
      tailf:info "Interface specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 240 characters describing this interface";
        length "0..240";
      }
    }

    // interface * / backup
    container backup {
      tailf:info "Modify backup parameters";

      // interface * / backup interface
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }

    // interface * / glbp *
    list glbp {
      tailf:info "Gateway Load Balancing Protocol interface commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key group-number;
      leaf group-number {
        type uint16 {
          tailf:info "<0-1023>;;Group number";
          range "0..1023";
        }
      }

      // interface * / glbp * ip
      leaf ip {
        tailf:info "Enable group and set virtual IP address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Virtual IP address";
        }
      }

      // interface * / glbp * ip * secondary
      container ip-secondary-list {
        tailf:cli-drop-node-name;
        list ip {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary address";
            type empty;
          }
        }
      }

      // interface * / glbp * priority
      leaf priority {
        tailf:info "Priority level";
        type uint8 {
          tailf:info "<1-255>;;Priority value";
          range "1..255";
        }
      }

      // interface * / glbp * preempt
      container preempt {
        tailf:info "Overthrow lower priority designated routers";
        tailf:cli-delete-when-empty;
        presence true;
        container delay {
          tailf:info "Wait before preempting";
          leaf minimum {
            tailf:info "Delay at least this long";
            type uint32 {
              tailf:info "<0-3600>;;Number of seconds for minimum delay";
              range "0..3600";
            }
          }
        }
      }
    }
  }

  // interface * / ospfv3
  // interface * / ospfv3 * ipv4
  // interface * / ospfv3 * ipv6
  grouping interface-ospfv3-grouping {

    // interface * / ospfv3 area
    container area {
      tailf:info "Set the OSPF area ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        type union {
          type uint32 {
            tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;OSPF area ID in IP address format";
          }
        }
      }
      leaf instance {
        tailf:info "Set the OSPF instance";
        type uint8 {
          tailf:info "<0-31>;;Instance ID";
          range "0..31";
        }
      }
    }

    // interface * / ospfv3 priority
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }

    // interface * / ospfv3 authentication
    container authentication {
      tailf:info "Enable authentication";
      choice authentication-choice {
        leaf key-chain {
          tailf:info "Use a key-chain for cryptographic authentication keys";
          tailf:non-strict-leafref {
            path "/ios:key/chain/name";
          }
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        leaf "null" {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }
  }

  // grouping interface-common-grouping0
  grouping interface-common-grouping0 {

    // interface * / arp
    container arp {
      tailf:info "Set arp type (arpa, probe, snap), timeout, log options or"+
        "packet priority";

      // interface * / arp timeout
      leaf timeout {
        tailf:info "Set ARP cache timeout";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-2147483>;;Seconds";
          range "0..2147483";
        }
      }

      // interface * / arp frame-relay
      leaf frame-relay {
        tailf:info "Enable ARP for a frame relay interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }
    }

    // interface * / authentication
    container authentication {
      tailf:info "set the port-control value";

      // authentication event
      container event {
        tailf:info "Set action for authentication events";

        // authentication event server dead action authorize vlan
        container server {
          tailf:info "Configure actions for AAA server events";
          container dead {
            tailf:info "Configure AAA server dead actions";
            container action {
              tailf:info "Required action for authentication event";
              container authorize {
                tailf:info "Authorize the port";
                leaf vlan {
                  tailf:info "Configure Critical Authorization VLAN";
                  type uint16 {
                    tailf:info "<1-4094>;;Enter a VlanId";
                  }
                }
              }
            }
          }
        }

        // authentication event no-response action authorize vlan
        container no-response {
          tailf:info "Configure non-responsive host actions";
          container action {
            tailf:info "Required action for authentication event";
            container authorize {
              tailf:info "Authorize the port";
              leaf vlan {
                tailf:info "Configure Guest vlan";
                type uint16 {
                  tailf:info "<1-4094>;;Enter a VlanId";
                  range "1..4094";
                }
              }
            }
          }
        }
      }

      // authentication host-mode
      leaf host-mode {
        tailf:info "Set the Host mode for authentication on this interface";
        type enumeration {
          enum multi-auth {
            tailf:info "Multiple Authentication Mode";
          }
          enum multi-domain {
            tailf:info "Multiple Domain Mode";
          }
          enum multi-host {
            tailf:info "Multiple Host Mode";
          }
          enum single-host {
            tailf:info "SINGLE HOST Mode";
          }
        }
      }

      // authentication order dot1x
      container order {
        tailf:info "Add an authentication method to the order list";
        leaf dot1x {
          tailf:info "Authentication method 'dot1x' allowed";
          type enumeration {
            enum mab {
              tailf:info "Authentication method 'mab' allowed";
            }
            enum webauth {
              tailf:info "Authentication method 'webauth' allowed";
            }
          }
        }
      }

      // authentication priority dot1x
      container priority {
        tailf:info "Add an authentication method to the priority list";
        leaf dot1x {
          tailf:info "Authentication method 'dot1x' allowed";
          type enumeration {
            enum mab {
              tailf:info "Authentication method 'mab' allowed";
            }
            enum webauth {
              tailf:info "Authentication method 'webauth' allowed";
            }
          }
        }
      }

      // interface * / authentication port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState will be set to AUTO";
          }
          enum force-authorized {
            tailf:info "PortState set to Authorized";
          }
          enum force-unauthorized {
            tailf:info "PortState will be set to UnAuthorized";
          }
        }
      }

      // authentication periodic
      leaf periodic {
        tailf:info "Enable or Disable Reauthentication for this port";
        type empty;
      }

      // authentication timer reauthenticate server
      container timer {
        tailf:info "Set authentication timer values";
        leaf reauthenticate {
          tailf:info "Time in seconds after which an automatic "+
            "re-authentication should be initiated (default 1 hour)";
          type union {
            type uint16 {
              tailf:info "<1-65535>;;Enter a value between 1 and 65535";
              range "1..65535";
            }
            type enumeration {
              enum server {
                tailf:info "Obtain re-authentication timeout value from the "+
                "server";
              }
            }
          }
        }
      }
    }

    // interface * / access-session
    container access-session {
      tailf:info "Access Session specific Interface Configuration Commands";

      // interface * / access-session closed
      leaf closed {
        tailf:info "Enable closed access on port (disabled by default"+
          ", i.e. open access)";
        type empty;
      }

      // interface * / access-session port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState set to automatic";
          }
          enum force-authorized {
            tailf:info "PortState set to AUTHORIZED";
          }
          enum force-unauthorized {
            tailf:info "PortState set to UnAuthorized";
          }
        }
        default force-authorized;
      }
    }

    // interface * / mab
    container mab {
      tailf:info "MAC Authentication Bypass Interface Config Commands";
      presence true;
      leaf eap {
        tailf:info "Use EAP authentication for MAC Auth Bypass";
        type empty;
      }
    }

    // interface * / medium
    leaf medium {
      tailf:info "Configures the interface as point-to-point";
      type enumeration {
        enum "p2p";
      }
    }

    // interface * / frame-relay
    container frame-relay {
      tailf:info "Set frame relay parameters";

      // interface * / frame-relay multilink
      container multilink {
        tailf:info "Set Multilink FR parameters";

        // interface * / frame-relay multilink output-threshold
        leaf output-threshold {
          tailf:info "Set output-threshold as xmt credit on one bundle link";
          type uint32 {
            tailf:info "<20-2147483647>;;number of bytes";
            range "20..2147483647";
          }
        }

        // interface * / frame-relay multilink bid
        container bid {
          tailf:info "Bundle id for this bundle interface";
          tailf:cli-reset-container;
          leaf bid {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;String to identify this bundle to the peer";
            }
          }
        }
      }

      // interface * / frame-relay limi-type
      leaf lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI";
        tailf:cli-full-command;
        type enumeration {
          enum ansi {
          }
          enum cisco {
          }
          enum q933a {
          }
        }
      }

      // interface * / frame-relay intf-type
      leaf intf-type {
        tailf:info "Configure a FR DTE/DCE/NNI interface";
        tailf:cli-full-command;
        type enumeration {
          enum dce {
            tailf:info "Configure a FR DCE";
          }
          enum dte {
            tailf:info "Configure a FR DTE";
          }
          enum nni {
            tailf:info "Configure a FR NNI";
          }
        }
      }

      // interface * / frame-relay interface-dlci
      container interface-dlci {
        tailf:info "Define a DLCI on an interface/subinterface";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-fr-dlci";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf dlci {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<16-1007>;;Define a switched or locally "+
              "terminated DLCI";
          }
        }
        leaf encapsulation {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum cisco {
              tailf:info "Use CISCO Encapsulation";
            }
            enum IETF {
              tailf:info "Use RFC1490/RFC2427 Encapsulation";
            }
          }
        }

        // interface * / frame-relay interface-dlci / class
        leaf class {
          tailf:non-strict-leafref {
            path "/ios:map-class/frame-relay/name";
          }
          type string;
        }
      }
    }

    // interface * / fair-queue
    container fair-queue {
      tailf:info "Enable Fair Queuing on an Interface";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf congestive-discard-threshold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4096>;;Congestive Discard Threshold";
        }
      }
      leaf dynamic-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<16-4096>;;Number Dynamic Conversation Queues";
        }
      }
      leaf reservable-queues {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-1000>;;Number Reservable Conversation Queues";
        }
      }
    }

    // interface * / flowcontrol
    container flowcontrol {
      tailf:info "Configure flow operation.";

      // interface * / no flowcontrol bidirectional
      leaf bidirectional {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / flowcontrol receive
      leaf receive {
        tailf:info "Configure receiving flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }

      // interface * / flowcontrol send
      leaf send {
        tailf:info "Configure sending flow operation";
        type enumeration {
          enum desired {
            tailf:info "Allow but do not require flow-control packets on port";
          }
          enum off {
            tailf:info "Disable flow-control packets on port";
          }
          enum on {
            tailf:info "Enable flow-control packets on port";
          }
        }
      }
    }

    // interface * / traffic-shape
    container traffic-shape {
      tailf:info "Enable Traffic Shaping on an Interface or Sub-Interface";

      // interface * / traffic-shape rate
      container rate {
        tailf:info "configure token bucket: CIR (bps) [Bc (bits) [Be (bits)]]";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf bit-rate {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../../group/access-list" {
            tailf:cli-trigger-on-set;
          }
          type uint32 {
            tailf:info "<8000-100000000>;;Target Bit Rate (bits per second)";
          }
        }
        leaf burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, sustained";
            range "0..100000000";
          }
        }
        leaf excess-burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, excess in first interval";
            range "0..100000000";
          }
        }
        leaf max-buffers {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Set buffer limit";
            range "1..4096";
          }
        }
      }

      // interface * / traffic-shape group *
      list group {
        tailf:info "configure token bucket: group <access-list> CIR (bps) [Bc (bits) [Be (bits)]] ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key access-list;
        leaf access-list {
          tailf:cli-diff-dependency "../../rate/bit-rate" {
            tailf:cli-trigger-on-set;
          }
          type uint16 {
            tailf:info "<1-2799>;;selecting Access list";
            range "1..2799";
          }
        }
        leaf bit-rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<8000-100000000>;;Target Bit Rate (bits per second)";
          }
        }
        leaf burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, sustained";
            range "0..100000000";
          }
        }
        leaf excess-burst-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-100000000>;;bits per interval, excess in first interval";
            range "0..100000000";
          }
        }
        leaf max-buffers {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Set buffer limit";
            range "1..4096";
          }
        }
      }
    }

    // interface * / keepalive
    choice keepalive-choice {
      // interface * / no keepalive
      leaf keepalive {
        tailf:info "Enable keepalive";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // interface * / keepalive <period>
      container keepalive-period {
        tailf:cli-drop-node-name;
        leaf keepalive {
          tailf:info "Enable keepalive";
          type uint16 {
            tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
            range "0..32767";
          }
          default 10;
        }
      }
      // interface * / keepalive <period> [retries]
      container keepalive-period-retries {
        tailf:cli-drop-node-name;
        container keepalive {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf period {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-32767>;;Keepalive period (default 10 seconds)";
              range "0..32767";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            type uint8 {
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / snmp
    container snmp {
      tailf:info "Modify SNMP interface parameters";

      // interface * / snmp ifindex persist
      container ifindex {
        tailf:info "Persist ifindex for the interface";
        leaf persist {
          tailf:info "Enable/Disable ifIndex persistence ";
          type empty;
        }
      }

      // interface * / snmp trap
      container trap {
        tailf:info "Allow a specific SNMP trap";

        // interface * / no snmp trap link-status
        leaf link-status {
          tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / snmp trap link-status permit duplicates
        container link-status-capas {
          tailf:cli-drop-node-name;
          container link-status {
            tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
            container permit {
              tailf:info "Permit the following capability";
              leaf duplicates {
                tailf:info "Permit duplicate SNMP LINKUP and LINKDOWN traps";
                type empty;
              }
            }
          }
        }

        // interface * / snmp trap mac-notification change
        container mac-notification {
          tailf:info "MAC Address notification for the interface";
          container change {
            tailf:info "Enable Mac Address notification feature for this port";
            // interface * / snmp trap mac-notification change added
            leaf added {
              tailf:info "Enable Mac Address added notification for this port";
              type empty;
            }
            // interface * / snmp trap mac-notification change removed
            leaf removed {
              tailf:info "Enable Mac Address removed notification for this port";
              type empty;
            }
          }
        }
      }
    }

    // interface * / flow-sampler
    container flow-sampler {
      tailf:info "Attach flow sampler to the interface";
      leaf name {
        tailf:cli-drop-node-name;
        tailf:non-strict-leafref {
          path "/ios:flow-sampler-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the flow sampler";
        }
      }
      container egress {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:non-strict-leafref {
            path "/ios:flow-sampler-map/name";
          }
          type string {
            tailf:info "WORD;;Name of the flow sampler";
          }
        }
        leaf egress {
          tailf:info "Egress flow sampler";
          type empty;
        }
      }
    }

    // interface * / lldp
    container lldp {
      tailf:info "LLDP interface subcommands";

      // interface * / no lldp transmit
      leaf transmit {
        tailf:info "Enable LLDP transmission on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no lldp receive
      leaf receive {
        tailf:info "Enable LLDP reception on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / bfd
    container bfd {
      tailf:info "BFD interface configuration commands";

      // interface * / bfd interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<15-999>;;Milliseconds";
            range "15..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<15-999>;;Milliseconds";
            range "15..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }

      // interface * / no bfd echo
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / bfd template
      leaf template {
        tailf:info "BFD template";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;bfd template name";
        }
      }
    }

    // interface * / bandwidth
    container bandwidth {
      tailf:info "Set bandwidth informational parameter";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf inherit {
        tailf:cli-optional-in-sequence;
        tailf:info "Specify how bandwidth is inherited";
        type empty;
      }
      leaf kilobits {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-10000000>;;Bandwidth in kilobits";
          range "1..10000000";
        }
      }
    }

    // interface * / cdp
    container cdp {
      tailf:info "CDP interface subcommands";

      // interface * / cdp enable  [e.g. ASR1k]
      // interface * / no cdp enable
      leaf enable {
        tailf:info "Enable CDP on interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / cdp tlv
      container tlv {
        tailf:info "Enable exchange of specific tlv information";
        container app {
          tailf:info "Enable/Configure Application TLV";
          tailf:cli-display-separated;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-sequence-commands;
          presence true;
          leaf tlvtype {
            tailf:info "Configure APP TLV";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "Configure App TLV Type information";
              range "1001..65535";
            }
          }
          leaf "value" {
            tailf:info "Configure App TLV Value information";
            type string {
              tailf:info "WORD;;Configure App TLV value information";
            }
          }
        }
        leaf server-location {
          tailf:info "Enable CDP location server on interface";
          tailf:cli-full-command;
          type empty;
        }
        leaf location {
          tailf:info "Exchange location information";
          tailf:cli-full-command;
          type empty;
        }
        // log
      }
    }

    // interface * / mop
    container mop {
      tailf:info "DEC MOP server commands";

      // interface * / no mop enabled
      leaf xenabled {
        tailf:alt-name enabled;
        tailf:info "Enable MOP for interface";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no mop sysid
      leaf sysid {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dampening
    container dampening {
      tailf:info "Enable event dampening";
      presence true;
      leaf dampening-time {
        tailf:cli-drop-node-name;
        tailf:cli-delete-container-on-delete;
        type uint16 {
          tailf:info "<1-30>;;Half-life time for penalty";
          range 1..30;
        }
      }
    }

    // interface * / vlan-range *
    list vlan-range {
      tailf:cli-mode-name "config-if-vlan-range";
      key id;
      leaf id {
        type uint16 {
          tailf:info "WORD;;VLAN IDs 1-4094";
          range "1..4094";
        }
      }

      // interface * / vlan-range * / service-policy input
      // interface * / vlan-range * / service-policy output
      container service-policy {
        tailf:info "Configure Service Policy";
        uses service-policy-grouping;
      }
    }

    // interface * / hold-queue *
    list hold-queue {
      tailf:info "Set hold queue depth";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Input queue";
          }
          enum out {
            tailf:info "Output queue";
          }
        }
      }
      leaf queue-length {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type uint16 {
          tailf:info "<0-4096>;;Queue length";
          range "0..4096";
        }
      }
    }

    // interface * / mpls
    container mpls {
      tailf:info "Configure MPLS interface parameters";

      // interface * / mpls accounting experimental
      container accounting {
        tailf:info "Enable MPLS accounting on this interface";
        container experimental {
          tailf:info "Count packets by MPLS experimental value on "
            +"this interface";
          leaf "input" {
            tailf:info "received packets";
            type empty;
          }
          leaf "output" {
            tailf:info "transmitted packets";
            type empty;
          }
        }
      }

      // interface * / mpls bgp forwarding
      container bgp {
        tailf:info "MPLS BGP";
        leaf forwarding {
          tailf:info "Configure MPLS forwarding for directly "
            +"connected BGP peers";
          type empty;
        }
      }

      // interface * / mpls label protocol
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Configure label/tag distribution "
            +"protocol (LDP/TDP)";
          type enumeration {
            enum both {
              tailf:info "Use LDP or TDP (Adapt to peer "
              +"on multiaccess interface)";
            }
            enum ldp {
              tailf:info "Use LDP (default)";
            }
            enum tdp {
              tailf:info "Use TDP";
            }
          }
        }
      }

      // interface * / mpls ldp
      container ldp {
        tailf:info "Configure Label Distribution Protocol "
          +"(LDP) parameters";

        // interface * / mpls ldp igp
        container igp {
          tailf:info "Configure IGP-related parameters";

          choice sync-choice {
            // interface * / no mpls ldp igp sync
            leaf sync {
              tailf:info "Allow LDP-IGP Synchronization on this interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            // interface * / mpls ldp igp sync delay
            container sync-delay {
              tailf:cli-drop-node-name;
              container sync {
                tailf:info "Allow LDP-IGP Synchronization on this interface";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                leaf delay {
                  tailf:info "Configure LDP to IGP sync achieved notification delay time";
                  type uint8 {
                    tailf:info "<5-60>;;Delay time (seconds)";
                    range "5..60";
                  }
                }
              }
            }
          }
        }

        // interface * / mpls ldp discovery
        container discovery {
          tailf:info "Configure interface LDP Discovery parameters";
          // interface * / mpls ldp discovery transport-address
          leaf transport-address {
            tailf:info "Specify interface LDP transport address";
            type ldp-discovery-address-type;
          }
        }
      }

      // interface * / mpls mtu
      leaf mtu {
        tailf:info "Set MPLS Maximum Transmission Unit";
        tailf:cli-full-command;
        type union {
          type uint16 {
            tailf:info "<1501-1524>;;MTU (baby giants bytes)";
            range "1501..1524";
          }
          type uint16 {
            tailf:info "<64-1500>;;MTU (bytes)";
            range "64..1500";
          }
          type uint16 {
            tailf:info "<64-9216>;;MTU size in bytes";
            range "64..9216";
          }
        }
        default 1500;
      }

      // interface * / mpls traffic-eng
      container traffic-eng {
        tailf:info "Configure Traffic Engineering parameters";

        // interface * / mpls traffic-eng administrative-weight
        leaf administrative-weight {
          tailf:info "Set the administrative weight for the "
            +"interface";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Weight";
            range "0..4294967295";
          }
        }

        // interface * / mpls traffic-eng backup-path
        leaf backup-path {
          tailf:info "Configure an MPLS TE backup for this interface";
          type string {
            tailf:info "Tunnel;;Tunnel interface";
          }
        }

        // interface * / mpls traffic-eng attribute-flags
        leaf attribute-flags {
          tailf:info "Set user-defined interface "
            +"attibute flags";
          tailf:cli-full-command;
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Attribute flags";
          }
        }

        // interface * / mpls traffic-eng flooding
        container flooding {
          tailf:info "Set flooding parameters";
          container thresholds {
            tailf:info "Set flooding thresholds";
            leaf-list down {
              tailf:info "Set the thresholds for decreased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;decreased bandwidth "
                  +"usage (percent)";
                range "0..100";
              }
            }
            leaf-list up {
              tailf:info "Set the thresholds for increased "
                +"resource availability";
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "<0-100>;;increased bandwidth usage "
                  +"(percent)";
                range "0..100";
              }
            }
          }
        }

        // interface * / mpls traffic-eng tunnels
        leaf tunnels {
          tailf:info "enable MPLS Traffic Engineering tunnels";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / mpls ip
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / mpls propagate-cos
      leaf propagate-cos {
        type empty;
      }
    }

    // interface * / isis
    container isis {
      tailf:info "IS-IS commands";

      // interface * / isis bfd
      container bfd {
        tailf:info "Bidirectional Forwarding Protocol";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / isis bfd disable
        leaf disable {
          tailf:info "disable bfd";
          type empty;
        }
      }

      // interface * / isis tag
      leaf tag {
        tailf:info "Assign an admin tag to an ISIS interface IP route";
        type uint32 {
          tailf:info "<1-4294967295>;;Admin tag number";
        }
      }

      // interface * / isis circuit-type
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
        default level-1-2;
      }

      // interface * / isis network point-to-point
      leaf network {
        tailf:info "Network type";
        tailf:cli-full-command;
        type enumeration {
          enum point-to-point {
            tailf:info "Specify ISIS point-to-point network";
          }
        }
      }

      // interface * / isis metric
      choice metric-choice {
        case default-case {
          leaf metric {
            tailf:info "Configure the metric for interface";
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
          }
        }
        case level-case {
          container metric-level {
            tailf:cli-drop-node-name;
            list metric {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key level;
              leaf level {
                type enumeration {
                  enum level-1 {
                    tailf:info "Apply metric to level-1 links";
                  }
                  enum level-2 {
                    tailf:info "Apply metric to level-2 links";
                  }
                }
              }
              leaf "default" {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint32 {
                  tailf:info "<1-16777214>;;Default metric";
                  range "1..16777214";
                }
              }
            }
          }
        }
      }

      // interface * / isis authentication
      uses router-isis-interface-grouping;

      // interface * / isis ipv6
      container ipv6 {
        tailf:info "IPv6 interface configuration";
        tailf:cli-diff-dependency "../../ipv6/enable" {
          tailf:cli-trigger-on-set;
        }
        choice metric-choice {

          // interface * / isis ipv6 metric
          leaf metric {
            tailf:info "Configure the metric for interface";
            type union {
              type uint32 {
                tailf:info "<1-16777214>;;Default metric";
                range "1..16777214";
              }
              type enumeration {
                enum maximum {
                  tailf:info "Maximum metric. All routers will exclude "+
                  "this link from their SPF";
                }
              }
            }
          }

          // interface * / isis ipv6 metric ? level-1|level-2
          container metric-level {
            tailf:cli-drop-node-name;
            list metric {
              tailf:info "Configure the metric for interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                type enumeration {
                  enum level-1 {
                    tailf:info "Apply metric to level-1 links";
                  }
                  enum level-2 {
                    tailf:info "Apply metric to level-2 links";
                  }
                }
              }
              leaf "value" {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type union {
                  type uint32 {
                    tailf:info "<1-16777214>;;Default metric";
                    range "1..16777214";
                  }
                  type enumeration {
                    enum maximum {
                      tailf:info "Maximum metric. All routers will exclude "+
                      "this link from their SPF";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / isis three-way-handshake
      leaf three-way-handshake {
        tailf:info "Select Cisco or IETF three-way handshake";
        tailf:cli-diff-dependency "../../ipv6/router/isis" {
          tailf:cli-trigger-on-set;
        }
        type enumeration {
          enum cisco {
            tailf:info "Cisco implementation of three-way handshake (default)";
          }
          enum ietf {
            tailf:info "IETF implementation of three-way handshake";
          }
        }
        default cisco;
      }

      // interface * / isis priority
      choice priority-choice {
        leaf priority {
          tailf:info "Set priority for Designated Router election";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-127>;;Priority value";
            range "0..127";
          }
        }
        // interface * / isis priority ? level-1
        // interface * / isis priority ? level-2
        container priority-level-1-2 {
          tailf:cli-drop-node-name;
          list priority {
            tailf:info "Set priority for Designated Router election";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify priority for level-1 routing";
                }
                enum level-2 {
                  tailf:info "Specify priority for level-2 routing";
                }
              }
            }
            leaf priority {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint8 {
                tailf:info "<0-127>;;Priority value";
                range "0..127";
              }
            }
          }
        }
      }

      // interface * / isis hello-multiplier
      container hello-multiplier {
        tailf:info "Set Hello multiplier";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Hello multiplier value";
            range "1..65535";
          }
        }
      }

      // interface * / isis hello-interval
      container hello-interval {
        tailf:info "Set Hello interval in seconds";
        choice hello-interval-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval value";
              range "1..65535";
            }
          }
          leaf minimal {
            tailf:info "Holdtime 1 second, interval depends on multiplier";
            type empty;
          }
        }
      }

      // interface * / isis csnp-interval
      choice csnp-interval-choice {
        leaf csnp-interval {
          tailf:info "Set CSNP interval in seconds";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;CSNP interval value";
          }
        }
        // interface * / isis csnp-interval ? level-1
        // interface * / isis csnp-interval ? level-2
        container csnp-interval-level {
          tailf:cli-drop-node-name;
          list csnp-interval {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify interval for level-1 CSNPs";
                }
                enum level-2 {
                  tailf:info "Specify interval for level-2 CSNPs";
                }
              }
            }
            leaf seconds {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint16 {
                tailf:info "<0-65535>;;CSNP interval value";
              }
            }
          }
        }
      }

      // interface * / isis password
      choice password-choice {
        leaf password {
          tailf:info "Configure the authentication password for interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Password";
          }
        }
        // interface * / isis password ? level-1
        // interface * / isis password ? level-2
        container password-level-1-2 {
          tailf:cli-drop-node-name;
          list password {
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            key level;
            leaf password {
              tailf:cli-prefix-key;
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Password";
              }
            }
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Specify password for level-1 PDUs";
                }
                enum level-2 {
                  tailf:info "Specify password for level-2 PDUs";
                }
              }
            }
          }
        }
      }
    }

    // interface * / vrf forwarding
    // interface * / ip vrf forwarding
    choice vrf-choice {
      container ip-vrf {
        tailf:cli-drop-node-name;
        container ip {
          container vrf {
            leaf forwarding {
              tailf:info "Configure forwarding table";
              tailf:cli-diff-dependency "/ios:ip/vrf";  // IN CHOICE
              tailf:non-strict-leafref {
                path "/ios:ip/vrf/name";
              }
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
          }
        }
      }

      // interface * / vrf forwarding
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf forwarding {
          tailf:info "Configure forwarding table";
          tailf:cli-diff-dependency "/ios:vrf/definition"; // IN CHOICE
          tailf:non-strict-leafref {
            path "/ios:vrf/definition/name";
          }
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }
    }

    // interface * / pm-path
    container pm-path {
      tailf:info "Global pm-path configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "/ios:pm-agent";
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Path name";
        }
      }
      leaf interface-id {
        tailf:info "Specify the interface-id";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the interface-id value";
          range "1..4294967295";
        }
      }
    }

    // interface * / ip
    container ip {
      tailf:info "Interface Internet Protocol config commands";

      // interface * / ip access-group
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:code-name "access_group_direction_in";
              tailf:info "inbound packets";
            }
            enum out {
              tailf:code-name "access_group_direction_out";
              tailf:info "outbound packets";
            }
          }
        }
        leaf access-list {
          tailf:cli-diff-dependency "/ios:ip/access-list";
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type exp-ip-acl-type;
        }
      }

      // interface * / ip authentication
      container authentication {
        tailf:info "authentication subcommands";

        // interface * / ip authentication mode eigrp *
        container mode {
          tailf:info "mode";
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key as-no;
            leaf as-no {
              type uint16 {
                tailf:info "<1-65535>;;Autonomous system number";
                range "1..65535";
              }
            }
            leaf md5 {
              tailf:info "Keyed message digest";
              type empty;
            }
          }
        }

        // interface * / ip authentication key-chain eigrp *
        container key-chain {
          tailf:info "key-chain";
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key as-no;
            leaf as-no {
              type uint16 {
                tailf:info "<1-65535>;;Autonomous system number";
                range "1..65535";
              }
            }
            leaf key-chain {
              tailf:cli-drop-node-name;
              tailf:non-strict-leafref {
                path "/ios:key/chain/name";
              }
              type string {
                tailf:info "WORD;;name of key-chain";
              }
            }
          }
        }
      }

      // interface * / ip accounting
      container accounting {
        tailf:info "Enable IP accounting on this interface";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / ip accounting output-packets
        leaf output-packets {
          tailf:info "Account for IP packets output on this interface";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip accounting precedence
        container precedence {
          tailf:info "Count packets by IP precedence on this interface";
          leaf "input" {
            tailf:info "received packets";
            type empty;
          }
          leaf "output" {
            tailf:info "transmitted packets";
            type empty;
          }
        }

        // interface * / ip accounting access-violations
        leaf access-violations {
          tailf:info "Account for IP packets violating access lists on this"+
            " interface";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ip vrf
      container vrf {
        tailf:info "VPN Routing/Forwarding parameters on the interface";
        leaf receive {
          tailf:info "Add Interface Address into VRF Table";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Table name";
          }
        }
        leaf sitemap {
          tailf:info "Configure route-map for routes"+
            "received from this site";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Name of the route-map";
          }
          // Note: no dependency to route-map
        }
      }

      // interface * / ip arp inspection
      container arp {
        tailf:info "Configure ARP features";
        container inspection {
          tailf:info "Arp Inspection configuration";

          // interface * / ip arp inspection trust
          leaf trust {
            tailf:info "Configure Trust state";
            type empty;
          }

          // interface * / ip arp inspection limit
          container limit {
            tailf:info "Configure Rate limit of incoming ARP packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice limit-choice {
              leaf none {
                tailf:info "No limit";
                type empty;
              }
              leaf rate {
                tailf:info "Rate Limit";
                type uint16 {
                  tailf:info "<0-10000>;;Packets per second";
                  range "0..10000";
                }
              }
            }
            container burst {
              tailf:info "Configure Burst parameters for ARP packets";
              tailf:cli-flatten-container;
              leaf interval {
                tailf:info "Number of seconds to check the rate";
                type uint8 {
                  tailf:info "<1-15>;;Burst interval in seconds";
                  range "1..15";
                }
              }
            }
          }
        }
      }

      // interface * / ip address
      choice address-choice {

        // interface * / ip unnumbered
        container unnumbered {
          tailf:info "Enable IP processing without an explicit address";
          uses interface-name-grouping;
        }

        // interface * / no ip address
        container no-address {
          tailf:cli-drop-node-name;
          leaf address {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            tailf:cli-full-no;
            type boolean;
            default true;
          }
        }

        // interface * / ip address
        container address {
          tailf:info "Set the IP address of an interface";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice address-choice {
            case fixed-case {
              // interface * / ip address a.b.c.d m.a.s.k
              container primary {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                // dep: before this created, must change l2vpn xconnect context
                tailf:cli-diff-dependency "/ios:l2vpn-xconnect/l2vpn/xconnect/context" {
                  tailf:cli-trigger-on-set;
                }
                leaf address {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  tailf:cli-incomplete-no;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
              }
              // interface * / ip address a.b.c.d m.a.s.k secondary
              list secondary {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                tailf:cli-diff-dependency "../primary/address";
                key "address mask";
                leaf address {
                  tailf:cli-incomplete-no;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address";
                  }
                }
                leaf mask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP subnet mask";
                  }
                }
                leaf secondary {
                  tailf:info "Make this IP address a secondary address";
                  type empty;
                }
              }
            }
            // interface * / ip address dhcp
            case dhcp-case {
              container dhcp {
                tailf:info "IP Address negotiated via DHCP";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                presence true;
                container client-id {
                  tailf:info "Specify client-id to use";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  uses interface-name-grouping;
                }
                leaf hostname {
                  tailf:info "Specify value for hostname option";
                  type string {
                    tailf:info "WORD;;hostname string";
                  }
                }
              }
            }
            // interface * / ip address negotiated
            case negotiated-case {
              container negotiated {
                tailf:info "IP Address negotiated over PPP";
                tailf:cli-reset-container;
                tailf:cli-delete-when-empty;
                presence true;
                leaf previous {
                  tailf:info "IPCP attempts to negotiate previous address "+
                    "assigned";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ip directed-broadcast
      container directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        tailf:cli-delete-when-empty;
        presence true;
        leaf access-list {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-199>;;A standard IP access list "+
                "number";
              range "1..199";
            }
            type uint16 {
              tailf:info "<1300-2699>;;A standard IP expanded "+
                "access list number";
              range "1300..2699";
            }
          }
        }
      }

      // interface * / ip split-horizon eigrp no-list *
      // interface * / no ip split-horizon eigrp *
      container split-horizon-eigrp {
        tailf:cli-drop-node-name;
        container split-horizon {
          tailf:info "Perform split horizon";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            list no-list {
              tailf:info "'no ip split-horizon eigrp' entry";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key as-no;
              leaf as-no {
                type uint16 {
                  tailf:info "<1-65535>;;Autonomous System";
                  range "1..65535";
                }
              }
            }
          }
        }
      }

      // interface * / no ip split-horizon
      leaf split-horizon {
        tailf:info "Perform split horizon";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ip router
      container router {
        tailf:info "IP router interface commands";

        // interface * / ip router isis
        container isis {
          tailf:info "IS-IS Routing for IP";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ip flow
      container flow {
        tailf:info "NetFlow related commands";

        // interface * / ip flow ingress
        leaf ingress {
          tailf:info "Enable inbound NetFlow";
          type empty;
        }

        // interface * / ip flow egress
        leaf egress {
          tailf:info "Enable outbound NetFlow";
          type empty;
        }

        // interface * / ip flow monitor * input
        // interface * / ip flow monitor * output
        list monitor {
          tailf:info "Apply a Flow Monitor";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key direction;
          leaf direction {
            type enumeration {
              enum "input" {
                tailf:info "Apply Flow Monitor on input traffic";
              }
              enum "output" {
                tailf:info "Apply Flow Monitor on output traffic";
              }
            }
          }
          leaf name {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "/ios:flow/monitor/name";
            }
            type string {
              tailf:info "WORD;;Flow Monitor name";
            }
          }
        }
      }

      // interface * / ip helper-address *
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        list helper-address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
        // interface * / ip helper-address vrf * *
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "vrf address";
          leaf vrf {
            type string {
              tailf:info "VRF name for helper-address";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
      }

        // interface * / ip summary-address eigrp *
      container summary-address {
        tailf:info "Perform address summarization";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          key "as-no ip-address wildcard-mask";
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;Autonomous system number";
              range "1..65535";
            }
          }
          leaf ip-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP summary address";
            }
          }
          leaf wildcard-mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Summary mask";
            }
          }
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Administrative distance";
              range "1..255";
            }
          }
        }
      }

      // interface * / ip ospf
      container ospf {
        tailf:info "OSPF interface commands";

        // interface * / ip ospf *
        list process-id {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf secondaries {
            tailf:info "Include or exclude secondary IP addresses";
            type empty;
          }
          leaf none {
            tailf:info "Do not include secondary IP addresses";
            type empty;
          }
        }

        // interface * / ip ospf authentication
        container authentication {
          tailf:info "Enable authentication";
          tailf:cli-delete-when-empty;
          presence true;
          choice authentication-choice {
            // interface * / ip ospf authentication message-digest
            leaf message-digest {
              tailf:info "Use message-digest authentication";
              type empty;
            }
            // interface * / ip ospf authentication null
            leaf "null" {
              tailf:info "Use no authentication";
              type empty;
            }
            // interface * / ip ospf authentication key-chain
            leaf key-chain {
              tailf:info "Use a key-chain for cryptographic authentication keys";
              type string {
                tailf:info "WORD;;Key-chain name";
              }
            }
          }
        }

        // interface * / ip ospf authentication-key
        container authentication-key {
          tailf:info "Authentication password (key)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }

        // interface * / ip ospf message-digest-key *
        list message-digest-key {
          tailf:info "Message digest authentication password (key)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-remove-before-change;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping;
          }
        }

        // interface * / ip ospf network
        leaf-list network {
          tailf:info "Network type";
          tailf:cli-flat-list-syntax {
            tailf:cli-replace-all;
          }
          tailf:cli-full-command;
          max-elements 2;
          type enumeration {
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
          }
        }

        // interface * / ip ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ip ospf dead-interval
        container dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice dead-interva-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Seconds";
                range "1..65535";
              }
            }
            case minimal {
              leaf minimal {
                tailf:info "Set to 1 second";
                type empty;
              }
              leaf hello-multiplier {
                tailf:info "Set multiplier for Hellos";
                type uint8 {
                  tailf:info "<3-20>;;Number of Hellos sent within 1 second";
                  range "3..20";
                }
              }
            }
          }
        }

        // interface * / ip ospf bfd
        container bfd {
          tailf:info "BFD interface configuration commands";
          presence true;
          leaf enable {
            tailf:cli-full-command;
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable BFD for this interface";
              }
            }
          }
        }

        // interface * / ip ospf mtu-ignore
        leaf mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip ospf cost
        leaf cost {
          tailf:info "Interface cost";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Cost";
            range "1..65535";
          }
        }

        // interface * / ip ospf ttl-security
        container ttl-security {
          tailf:info "TTL security check";
          tailf:cli-delete-when-empty;
          presence true;
          leaf hops {
            tailf:info "IP hops";
            type uint8 {
              tailf:info "<1-254>;;maximum number of hops allowed";
              range "1..254";
            }
          }
        }

        // interface * / ip ospf priority
        leaf priority {
          tailf:info "Router priority";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority";
          }
        }

        // interface * / ip ospf lls
        container lls {
          tailf:info "Link-local Signaling (LLS) support";
          tailf:cli-delete-when-empty;
          presence true;
          // interface * / ip ospf lls disable
          leaf disable {
            tailf:info "disable LLS";
            type empty;
          }
        }

        // interface * / ip ospf database-filter all out
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          container all {
            tailf:info "Filter all LSA";
            leaf out {
              tailf:info "Outgoing LSA";
              type empty;
            }
          }
        }
      }

      // interface * / ip pim
      container pim {
        tailf:info "PIM interface commands";

        // interface * / ip pim query-interval
        leaf query-interval {
          tailf:info "PIM router query interval";
          type uint16 {
            tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
            range "1..65535";
          }
          default 30;
        }

        // interface * / ip pim nbma-mode
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }

        // interface * / ip pim sparse-mode
        // interface * / ip pim sparse-dense-mode
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum sparse-mode {
              tailf:info "Enable PIM sparse-mode operation";
            }
            enum sparse-dense-mode {
              tailf:info "Enable PIM sparse-dense-mode operation";
            }
          }
        }

        // interface * / ip pim dr-priority
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to "+
              "larger value";
          }
        }

        // interface * / ip pim snooping
        leaf snooping {
          tailf:info "PIM Snooping enable for Catalyst Vlan";
          type empty;
        }

        // interface * / ip pim passive
        leaf passive {
          tailf:info "Enable PIM passive interface operation";
          tailf:cli-full-command;
          type empty;
        }
      }

      // interface * / ip multicast
      container multicast {
        tailf:info "IP multicast interface commands";

        // interface * / ip multicast boundary
        container boundary {
          tailf:info "Boundary for administratively scoped multicast addresses";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf access-list {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;ACL name or number";
            }
          }
          leaf filter-autorp {
            tailf:info "Filter AutoRP packet contents.";
            type empty;
          }
        }

        // interface * / ip multicast limit
        container limit {
          tailf:info "Limit multicast mroute state";

          // interface * / ip multicast limit *
          list access-lists {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / connected *
          list connected {
            tailf:info "Limit connected incoming state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / out *
          list out {
            tailf:info "Limit outgoing state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }

          // interface * / ip multicast limit / rpf *
          list rpf {
            tailf:info "Limit incoming state";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key access-list;
            leaf access-list {
              tailf:cli-suppress-range;
              type ip-acl-type;
            }
            leaf allowed-state {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-2147483647>;;Max Allowed State on this interface";
                range "0..2147483647";
              }
            }
          }
        }
      }

      // interface * / ip policy route-map
      container policy {
        tailf:info "Enable policy routing";
        leaf route-map {
          tailf:info "Policy route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // interface * / no ip unreachables
      leaf unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / no ip proxy-arp
      leaf proxy-arp {
        tailf:info "Enable proxy ARP";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }

      // interface * / no ip route-cache
      container route-cache-conf {
        tailf:cli-drop-node-name;
        leaf route-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface * / ip route-cache
      container route-cache {
        tailf:info "Enable fast-switching cache for outgoing packets";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;

        // interface * / no ip route-cache cef
        leaf cef {
          tailf:info "Enable Cisco Express Forwarding";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / ip route-cache flow
        leaf flow {
          tailf:info "Enable Flow fast-switching cache";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache policy
        leaf policy {
          tailf:info "Enable fast-switching policy cache for outgoing packets";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }

        // interface * / ip route-cache same-interface
        leaf same-interface {
          tailf:info "Enable fast-switching on the same interface";
          tailf:cli-boolean-no;
          type boolean;
          default false;
        }
      }

      // interface * / ip mroute-cache
      // interface * / no ip mroute-cache
      leaf mroute-cache {
        tailf:info "Enable switching cache for incoming multicast packets";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }


      // interface * / ip igmp
      container igmp {
        tailf:info "IGMP interface commands";

        // interface * / ip igmp max-groups
        container max-groups {
          tailf:info "set maximum number of IGMP groups that can be joined";
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967294>;;maximum # of groups";
            }
          }
          // interface * / ip igmp max-groups action
          leaf action {
            tailf:info "action taken on exceeding the limit";
            tailf:cli-full-command;
            type enumeration {
              enum deny {
                tailf:info "do not allow any more groups";
              }
              enum replace {
                tailf:info "replace existing group with new";
              }
            }
            default deny;
          }
        }

        // interface * / ip igmp filter
        leaf filter {
          tailf:info "set IGMP filter profile number";
          type uint32 {
            tailf:info "<1-4294967295>;;IGMP profile number";
            range "1..4294967295";
          }
        }

        // interface * / ip igmp join-group
        list join-group {
          tailf:info "IGMP join multicast group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP group address";
            }
          }
          leaf source {
            tailf:info "Include SSM source";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP source address";
            }
          }
        }

        // interface * / ip igmp static-group
        container static-group {
          tailf:info "IGMP static multicast group";
          list groups {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              tailf:cli-suppress-range;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP group address";
                }
                type enumeration {
                  enum "*" {
                    tailf:info "Populated for all groups";
                  }
                }
              }
            }
          }
          //FIXME: verify on device
          list class-map {
            tailf:info "Class map of type multicast-flows";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              tailf:non-strict-leafref {
                path "/ios:class-map/name";
              }
              type string {
                tailf:info "WORD;;Name of class-map of type multicast-flows";
              }
            }
          }
        }

        // interface * / ip igmp version
        leaf version {
          tailf:info "IGMP version";
          type uint8 {
            tailf:info "<1-3>;;version number";
            range "1..3";
          }
        }

        // interface * / ip igmp access-group
        leaf access-group {
          tailf:info "IGMP group access group";
          type exp-ip-acl-type;
        }
      }

      // interface * / no ip redirects
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ip hello-interval eigrp *
      container hello-interval {
        tailf:info "Configures EIGRP-IPv4 hello interval";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds between hello transmissions";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ip hold-time eigrp *
      container hold-time {
        tailf:info "Configures EIGRP-IPv4 hold time";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds before neighbor is considered down";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ip nbar
      container nbar {
        tailf:info "Network-Based Application Recognition";

        // interface * / ip nbar protocol-discovery
        leaf protocol-discovery {
          tailf:info "Enable protocol discovery for both ipv4 and ipv6";
          type empty;
        }
      }

      // interface * / ip nhrp
      container nhrp {
        tailf:info "NHRP interface subcommands";

        // interface * / ip nhrp authentication
        leaf authentication {
          tailf:info "Authentication string";
          type string {
            tailf:info "WORD;;authentication string";
          }
        }

        // interface * / ip nhrp group
        leaf group {
          tailf:info "NHRP group name";
          type string {
            tailf:info "WORD;;group name string";
          }
        }

        // interface * / ip nhrp map
        container map {
          tailf:info "Map dest IP addresses to NBMA addresses";

          // interface * / ip nhrp map *
          list map-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key ip-address;
            leaf ip-address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of destination";
              }
            }
            leaf nbma-address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP NBMA address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                }
              }
            }
          }

          // interface * / ip nhrp map multicast
          container multicast {
            tailf:info "Use this NBMA mapping for broadcasts/multicasts";

            // interface * / ipv nhrp map multicast dynamic
            leaf dynamic {
              tailf:info "Dynamically learn destinations from client "+
                "registrations on hub";
              type empty;
            }

            // interface * / ipv nhrp map multicast *
            list multicast-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key nbma-address;
              leaf nbma-address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP NBMA address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                  }
                }
              }
            }
          }

          // interface * / ip nhrp map group *
          list group {
            tailf:info "NHRP group mapping";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;NHRP group name";
              }
            }

            // interface * / ip nhrp map group * service-policy output
            container service-policy {
              tailf:info "QoS service-policy";
              leaf "output" {
                tailf:info "apply QoS service policy in the output direction";
                tailf:non-strict-leafref {
                  path "/ios:policy-map/name";
                }
                type string {
                  tailf:info "WORD;;QoS policy-map name";
                }
              }
            }
          }
        }

        // interface * / ip nhrp network-id
        leaf network-id {
          tailf:info "NBMA network identifier";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Network identifier";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
        }

        // interface * / ip nhrp holdtime
        leaf holdtime {
          tailf:info "Advertised holdtime";
          type uint16 {
            tailf:info "<1-65535>;;Number of seconds";
            range "1..65535";
          }
        }

        // interface * / ip nhrp nhs
        container nhs {
          tailf:info "Specify a next hop server";

          // interface * / ip nhrp nhs *
          list nhs-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key nhs-address;
            leaf nhs-address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Protocol IP address of NHS";
              }
            }
            // interface * / ip nhrp nhs * nbma
            leaf nbma {
              tailf:info "NBMA of NHS";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
                type string {
                  tailf:info "WORD;;NHS FQDN string";
                }
              }
            }
            // interface * / ip nhrp nhs * multicast
            leaf multicast {
              when "../nbma" {
                tailf:dependency "../nbma";
              }
              tailf:info "Use this NBMA mapping for broadcasts/multicasts";
              type empty;
            }
          }
        }

        // interface * / ip nhrp server-only
        container server-only {
          tailf:info "Disable NHRP requests";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-caching {
            tailf:info "Do not create NHRP cache entries";
            type empty;
          }
        }

        // interface * / ip nhrp registration
        container registration {
          tailf:info "Settings for registration packets.";

          // interface * / ip nhrp registration no-unique
          leaf no-unique {
            tailf:info "Do not set the 'Unique' flag in registration requests.";
            type empty;
          }

          // interface * / ip nhrp registration timeout
          leaf timeout {
            tailf:info "Time between periodic Registration messages";
            type uint16 {
              tailf:info "<1-65535>;;Number of seconds";
              range "1..65535";
            }
          }
        }

        // interface * / ip nhrp shortcut
        container shortcut {
          tailf:info "Enable shortcut switching";
          tailf:cli-delete-when-empty;
          presence true;
          leaf virtual-template {
            tailf:info "Virtual template interface number";
            type uint16 {
              tailf:info "<1-200>;;Virtual template number";
            }
          }
        }

        // interface * / ip nhrp redirect
        container redirect {
          tailf:info "Enable NHRP redirect traffic indication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf timeout {
            tailf:info "Specify interval over which to throttle";
            type uint8 {
              tailf:info "<2-30>;;Interval in seconds";
              range "2..30";
            }
          }
        }
      }

      // interface * / ip tcp
      container tcp {
        tailf:info "TCP header compression and other parameters";

        // interface * / ip tcp adjust-mss
        leaf adjust-mss {
          tailf:info "Adjust the mss of transit packets";
          type uint16 {
            tailf:info "<500-1460>;;Maximum segment size in bytes";
            range "500..1460";
          }
        }

        // interface * / ip tcp header-compression
        container header-compression {
          tailf:info "Enable TCP header compression";
          tailf:cli-delete-when-empty;
          presence true;
          leaf "type" {
            tailf:cli-drop-node-name;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Using PPP  IPHC compression for TCP/UDP/RTP";
              }
              enum passive {
                tailf:info "Compress only for destinations which send "+
                "compressed headers";
              }
            }
          }
        }

        // interface * / ip tcp compression-connections
        leaf compression-connections {
          tailf:info "Maximum number of compressed connections";
          type uint16 {
            tailf:info "<1-256>;;Number of connections";
            range "1..256";
          }
        }
      }

      // interface * / ip rtp
      container rtp {
        tailf:info "RTP parameters";
        container header-compression {
          tailf:info "Enable RTP header compression";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf "type" {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum ietf-format {
                tailf:info "Compressing using IETF format";
              }
              enum iphc-format {
                tailf:info "Compress using IPHC format";
              }
              enum passive {
                tailf:info "Compress only for destinations which send "+
                "compressed headers";
              }
            }
          }
          leaf periodic-refresh {
            tailf:info "Periodic context refresh";
            type empty;
          }
        }
        leaf compression-connections {
          tailf:info "Maximum number of compressed connections";
          type uint16 {
            tailf:info "<1-1000>;;Number of connections";
            range "1..1000";
          }
        }
      }

      // interface * / ip header-compression
      container header-compression {
        tailf:info "IPHC options";
        leaf max-header {
          tailf:info "Maximim compressible header";
          type uint8 {
            tailf:info "<20-168>;;Maximim compressible header";
            range "20..168";
          }
        }
      }

      // interface * / ip mobile
      container mobile {
        tailf:info "Mobile IP support";

        // interface * / ip mobile router-service
        container router-service {
          tailf:info "Mobile router support";

          // interface * / ip mobile router-service roam
          container roam {
            tailf:info "Roaming interface";
            presence true;
            leaf priority {
              tailf:info "Priority level";
              type uint8 {
                tailf:info "<0-255>;;Priority level";
              }
            }
          }

          // interface * / ip mobile router-service description
          leaf "description" {
            tailf:info "roaming interface description";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;roaming interface description";
            }
          }

          // interface * / ip mobile router-service link-type
          leaf link-type {
            tailf:info "Link type of the roaming interface";
            type string; //fixme: enum
          }

          // interface * / ip mobile router-service tunnel
          container tunnel {
            tailf:info "Tunnel parameters";
            leaf mode {
              tailf:info "Tunnel encapsulation mode";
              type enumeration {
                enum gre {
                  tailf:info "Generic Routing Encapsulation";
                }
                enum ipip {
                  tailf:info "IP-in-IP Encapsulation";
                }
              }
            }
          }

          // interface * / ip mobile router-service collocated
          container collocated {
            tailf:info "Collocated care-of address options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf gateway {
              tailf:info "Default gateway for static collocated "+
                "care-of address";
              tailf:cli-optional-in-sequence;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address to use as the default gateway";
              }
            }
            leaf ccoa-only {
              tailf:info "Only register a collocated CoA";
              tailf:cli-optional-in-sequence;
              type empty;
            }

            // interface * / ip mobile router-service collocated registration
            container registration {
              tailf:info "Registration options";
              tailf:cli-break-sequence-commands;
              leaf retry {
                tailf:info "Retry interval in seconds (1-65535)";
                type uint16 {
                  tailf:info "<1-65535>;;Seconds (default 60; 65535 = never)";
                  range "1..65535";
                }
                default 60;
              }
              container nat {
                tailf:info "NAT traversal settings";
                container traversal {
                  tailf:info "Enable NAT traversal support";
                  tailf:cli-compact-syntax;
                  presence true;
                  leaf keepalive {
                    tailf:info "Keepalive message frequency (sec)";
                    type uint16 {
                      tailf:info "<0-65535>;;keepalive value";
                    }
                  }
                  leaf force {
                    tailf:info "Force home agent to use UDP encapsulation "+
                      "for the tunnel";
                    type empty;
                  }
                }
              }
            }
            leaf encapsulation {
              type enumeration {
                enum slip {}
                enum ppp {}
              }
            }
          }
        }
      }

      // interface * / ip inspect * in
      // interface * / ip inspect * out
      list inspect {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Inbound inspection";
            }
            enum out {
              tailf:info "Outbound inspection";
            }
          }
        }
        leaf name {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          tailf:non-strict-leafref {
            path "/ios:ip/inspect/name/name";
          }
          type string {
            tailf:info "WORD;;Name of inspection defined";
          }
        }
      }

      // interface * / ip virtual-reassembly
      container virtual-reassembly {
        tailf:info "Enable Virtual Fragment Reassembly";
        tailf:cli-delete-when-empty;
        presence true;

        // interface * / ip virtual-reassembly in
        leaf in {
          tailf:info "Enable VFR on Ingress";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / ip virtual-reassembly out
        leaf out {
          tailf:info "Enable VFR on Egress";
          tailf:cli-full-command;
          type empty;
        }

        container conf {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;

          // interface * / ip virtual-reassembly drop-fragments
          leaf drop-fragments {
            tailf:info "Drop all the incoming fragments";
            type empty;
          }

          // interface * / ip virtual-reassembly max-fragments
          leaf max-fragments {
            tailf:info "Specify max number of fragments per reassembly "+
              "(datagram)";
            type uint8 {
              tailf:info "<1-64>;;Number of fragments per datagram";
              range "1..64";
            }
          }

          // interface * / ip virtual-reassembly max-reassemblies
          leaf max-reassemblies {
            tailf:info "Specify max number of concurrent reassemblies";
            type uint16 {
              tailf:info "<1-1024>;;Number of datagrams that can be "+
                "reassembled at a time";
              range "1..1024";
            }
          }

          // interface * / ip virtual-reassembly timeout
          leaf timeout {
            tailf:info "Specify timeout value of the datagram being reassembled";
            type uint8 {
              tailf:info "<1-60>;;Timeout value of the datagram being reassembled";
            }
          }

          // interface * / ip virtual-reassembly percentage
          leaf percentage {
            tailf:info "Reserved Reassembly capacity for high priority packets";
            type uint8 {
              tailf:info "<1-100>;;Reserved Reassembly capacity percentage";
              range "1..100";
            }
          }

          // interface * / ip virtual-reassembly dscp
          leaf-list dscp {
            tailf:info "DSCP value";
            tailf:cli-flat-list-syntax;
            tailf:cli-full-command;
            type dscp-type;
          }

          // interface * / ip virtual-reassembly precedence
          leaf-list precedence {
            tailf:info "IP precedence";
            tailf:cli-flat-list-syntax;
            tailf:cli-full-command;
            type precedence-type;
          }
        }
      }

      // interface * / ip dns view-group
      container dns {
        tailf:info "Configure DNS server";
        leaf view-group {
          tailf:info "Configure a DNS view-list for use on this interface";
          tailf:non-strict-leafref {
            path "/ios:ip/dns/view-list/name";
          }
          type string {
            tailf:info "WORD;;View-list name";
          }
        }
      }

      // interface * / ip dhcp
      container dhcp {
        tailf:info "Configure DHCP parameters for this interface";

        // interface * / ip dhcp relay information
        container relay {
          tailf:info "DHCP relay configuration parameters";
          container information {
            tailf:info "DHCP relay information option";
            container check-reply {
              tailf:info "Validate relay information in BOOTREPLY";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            container option {
              tailf:info "DHCP relay information option";
              leaf subscriber-id {
                tailf:info "Subscriber identifier sub option";
                type string {
                  tailf:info "WORD;;Subscriber identifier string";
                }
              }
            }
            container option-insert {
              tailf:info "Insert relay information in BOOTREQUEST";
              presence true;
              leaf none {
                tailf:info "Set to none";
                type empty;
              }
            }
            leaf policy-action {
              tailf:info "Define reforwarding policy";
              type enumeration {
                enum drop {
                  tailf:info "Do not forward BOOTREQUEST message";
                }
                enum encapsulate {
                  tailf:info "Encapsulate existing information";
                }
                enum keep {
                  tailf:info "Leave existing information alone";
                }
                enum replace {
                  tailf:info "Replace existing information";
                }
              }
            }
            leaf trusted {
              tailf:info "Received DHCP packet may contain relay info option "
                +"with zero giaddr";
              type empty;
            }
          }
        }

        // interface * / ip dhcp snooping
        container snooping {
          tailf:info "DHCP Snooping";

          // interface * / ip dhcp snooping limit
          container limit {
            tailf:info "DHCP Snooping limit";
            leaf rate {
              tailf:info "DHCP Snooping limit";
              type uint16 {
                tailf:info "<1-2048>;;DHCP snooping rate limit";
                range "1..2048";
              }
            }
          }

          // interface * / ip dhcp snooping trust
          leaf trust {
            tailf:info "DHCP Snooping trust config";
            type empty;
          }

          // interface * / ip dhcp snooping vlan *
          list vlan {
            tailf:info "DHCP Snooping vlan";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping vlan";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              tailf:cli-flatten-container;
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id (3-63 "
                          +"chars)";
                        length "3..63";
                      }
                    }
                  }
                }
              }
            }
          }

          // interface * / ip dhcp snooping bridge-domain *
          list bridge-domain {
            tailf:info "DHCP Snooping bridge-domain";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-4094>;;DHCP Snooping bridge-domain number";
                range "1..4094";
              }
            }
            container information {
              tailf:info "DHCP Snooping information";
              tailf:cli-flatten-container;
              container option {
                tailf:info "DHCP Snooping information option";
                container format-type {
                  tailf:info "Option 82 information format";
                  container circuit-id {
                    tailf:info "Circuit id option 82 format";
                    leaf string {
                      tailf:info "User defined string for circuit id";
                      type string {
                        tailf:info "WORD;;Use string for circuit id";
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      // interface * / ip mtu
      leaf mtu {
        tailf:info "Set IP Maximum Transmission Unit";
        type uint16 {
          tailf:info "<68-9216>;;MTU (bytes)";
          range "68..9216";
        }
      }

      // interface * / ip nat
      container nat {
        tailf:info "NAT interface commands";
        leaf allow-static-host {
          tailf:info "Allow static-ip clients";
          type empty;
        }
        leaf enable {
          tailf:info "Enable Address Translation (NVI)";
          type empty;
        }
        choice nat-choice {
          leaf inside {
            tailf:info "Inside interface for address translation";
            type empty;
          }
          leaf outside {
            tailf:info "Outside interface for address translation";
            type empty;
          }
        }
      }

      // interface * / ip rsvp
      container rsvp {
        tailf:info "RSVP Interface Commands";

        // interface * / ip rsvp bandwidth
        container bandwidth {
          tailf:info "RSVP Reservable Bandwidth (kbps)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          leaf interface-bandwidth {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-10000000>;;Reservable Bandwidth (kbps)";
              range "1..10000000";
            }
          }
          leaf single-flow-bandwidth {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-10000000>;;Largest Reservable Flow (kbps)";
              range "1..10000000";
            }
          }
        }

        // interface * / ip rsvp signalling hello
        container signalling {
          tailf:info "RSVP signalling";
          container hello {
            tailf:info "Enable neighbor-down detection";
            presence true;
            // interface * / ip rsvp signalling hello graceful-restart
            container graceful-restart {
              tailf:info "Configure RSVP Graceful Restart";
              presence true;
            }
          }
        }

        // interface * / ip rsvp resource-provider
        container resource-provider {
          tailf:info "RSVP resource provider";
          choice resource-provider-choice {
            leaf none {
              tailf:info "Associates NO resources with reservations";
              type empty;
            }
            leaf wfq {
              tailf:info "Associates WFQ resources with reservations";
              type enumeration {
                enum interface {
                  tailf:info "Associates WFQ queues and bandwidth at the "+
                  "interface level with reservations";
                }
                enum pvc {
                  tailf:info "Associates WFQ queues and bandwidth at the "+
                  "PVC level with reservations";
                }
              }
            }
          }
        }
      }

      // interface * / ip verify
      container verify {
        tailf:info "Enable per packet validation";

        // interface * / ip verify
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ip verify unicast reverse-path
          container reverse-path {
            tailf:info "Reverse path validation of source address "+
              "(old command format)";
            presence true;
          }

          // interface * / ip verify unicast source
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the "
                +"source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which"
                  +" packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability "+
                "in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking "+
                "source address";
              type empty;
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "allow-self-ping|allow-default";
              type exp-ip-acl-type;
            }
          }
        }

        // interface * / ip verify source
        container source {
          tailf:info "source address";
          tailf:cli-delete-when-empty;
          presence true;

          // interface * / ip verify source vlan dhcp-snooping
          container vlan {
            tailf:info "vlan specification";
            container dhcp-snooping {
              tailf:info "snooping enable vlan";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf port-security {
                tailf:info "port security";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ip rip
      container rip {
        tailf:info "Router Information Protocol";

        // interface * / ip rip send version
        container send {
          tailf:info "advertisement transmission";
          leaf version {
            tailf:info "version control";
            type enumeration {
              enum "1" {
                tailf:info "RIP version 1";
              }
              enum "2" {
                tailf:info "RIP version 2";
              }
            }
          }
        }

        // interface * / ip rip receive version
        container receive {
          tailf:info "advertisement reception";
          leaf version {
            tailf:info "version control";
            type enumeration {
              enum "1" {
                tailf:info "RIP version 1";
              }
              enum "2" {
                tailf:info "RIP version 2";
              }
            }
          }
        }

        // interface * / ip rip authentication
        container authentication {
          tailf:info "Authentication control";

          // interface * / ip rip authentication mode
          leaf mode {
            tailf:info "Authentication mode";
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text authentication";
              }
            }
          }

          // interface * / ip rip authentication key-chain
          leaf key-chain {
            tailf:info "Authentication key-chain";
            tailf:non-strict-leafref {
              path "/ios:key/chain/name";
            }
            type string {
              tailf:info "LINE;;name of key-chain";
            }
          }
        }
      }

      // interface * / ip mask-reply
      leaf mask-reply {
        tailf:info "Enable sending ICMP Mask Reply messages";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ip bandwidth-percent *
      container bandwidth-percent {
        tailf:info "Set EIGRP bandwidth limit";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key as-number;
          leaf as-number {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
            }
          }
          leaf percent {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-999999>;;Maximum bandwidth percentage that EIGRP may use";
              range "1..999999";
            }
          }
        }
      }

      // interface * / no ip next-hop-self eigrp *
      // interface * / ip next-hop-self eigrp no-list *
      container next-hop-self {
        tailf:info "Configures EIGRP-IPv4 next-hop-self";
        container eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          list no-list {
            tailf:info "'no ip next-hop-self eigrp' entry";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key as-number;
            leaf as-number {
              type uint16 {
                tailf:info "<1-65535>;;AS number";
                range "1..65535";
              }
            }
          }
        }
      }

      // interface * / ip lisp source-locator
      container lisp {
        tailf:info "Locator/ID Separation Protocol";
        container source-locator {
          tailf:info "Choose IP source address for LISP packets egressing this interface";
          uses interface-name-grouping;
        }
      }

      // interface * / ip wccp
      container wccp {
        tailf:info "WCCP IPv4 interface commands";
        tailf:cli-diff-dependency "/ios:ip/wccp";
        uses interface-ip-wccp-grouping;

        // interface * / ip wccp vrf *
        list vrf {
          tailf:info "Configure WCCP for a VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/ios:vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          uses interface-ip-wccp-grouping;
        }
      }
    }

    // interface * / ipv6
    container ipv6 {
      tailf:info "IPv6 interface subcommands";

      // interface * / ipv6 address
      container address {
        tailf:info "Configure IPv6 address on interface";
        choice address-choice {

          // interface * / ipv6 address autoconfig
          case autoconfig-case {
            container autoconfig {
              tailf:info "Obtain address using autoconfiguration";
              presence true;
              leaf "default" {
                tailf:info "Insert default route";
                type empty;
              }
            }
          }

          // interface * / ipv6 address dhcp
          case dhcp-case {
            container dhcp {
              tailf:info "Obtain a ipv6 address using dhcp";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf rapid-commit {
                tailf:info "Enable Rapid-Commit";
                type empty;
              }
            }
          }

          // interface * / ipv6 address *
          case manual-case {
            list prefix-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "prefix";
              leaf "prefix" {
                type union {
                  type ios:ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 link-local address";
                  }
                }
              }
              leaf link-local {
                tailf:info "Use link-local address";
                tailf:cli-full-command;
                type empty;
              }
              leaf anycast {
                tailf:info "Configure as an anycast";
                tailf:cli-full-command;
                type empty;
              }
              leaf eui-64 {
                tailf:info "Use eui-64 interface identifier";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }

      // interface * / ipv6 enable
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        type empty;
      }

      // interface * / ipv6 unnumbered
      container unnumbered {
        tailf:info "Preferred interface for source address selection";
        uses interface-name-grouping;
      }

      // interface * / ipv6 traffic-filter *
      list traffic-filter {
        tailf:info "Access control list for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "inbound packets";
            }
            enum "out" {
              tailf:info "outbound packets";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
      }

      // interface * / ipv6 nd
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";

        // interface * / ipv6 nd dad
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }

        // interface * / ipv6 nd reachable-time
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds";
            range "0..3600000";
          }
        }

        // interface * / ipv6 nd prefix
        container "prefix" {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";

          // interface * / ipv6 nd prefix *
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key ipv6-prefix;
            leaf ipv6-prefix {
              type union {
                type ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type enumeration {
                  enum "default" {
                    tailf:info "Specify prefix default parameters";
                  }
                }
              }
            }
            // interface * / ipv6 nd prefix * no-advertise
            choice advertise-choice {
              case no-advertise {
                leaf no-advertise {
                  tailf:info "Do not advertise prefix";
                  tailf:cli-full-command;
                  type empty;
                }
              }
              case advertise {
                // interface * / ipv6 nd prefix * <valid-lifetime>
                leaf valid-lifetime {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Valid Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * <preferred-lifetime>
                leaf preferred-lifetime {
                  tailf:cli-drop-node-name;
                  type union {
                    type enumeration {
                      enum "infinite" {
                        tailf:info "Infinite Preferred Lifetime";
                      }
                    }
                    type uint32 {
                      tailf:info "<0-4294967295>;;Preferred Lifetime (secs)";
                    }
                  }
                }
                // interface * / ipv6 nd prefix * off-link
                leaf off-link {
                  tailf:cli-break-sequence-commands;
                  tailf:info "Prefix is offlink";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-autoconfig
                leaf no-autoconfig {
                  tailf:info "Do not use prefix for autoconfiguration";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-rtr-address
                leaf no-rtr-address {
                  tailf:info "Do not send full router address in prefix advert";
                  type empty;
                }
                // interface * / ipv6 nd prefix * no-onlink
                leaf no-onlink {
                  tailf:info "Do not use prefix for onlink determination";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / ipv6 nd managed-config-flag
        leaf managed-config-flag {
          tailf:info "Hosts should use DHCP for address config";
          type empty;
        }

        // interface * / ipv6 nd other-config-flag
        leaf other-config-flag {
          tailf:info "Hosts should use DHCP for non-address config";
          type empty;
        }

        // interface * / ipv6 nd ra
        container ra {
          tailf:info "Router Advertisement control";

          // interface * / ipv6 nd ra suppress
          container suppress {
            tailf:info "Suppress IPv6 Router Advertisements";
            tailf:cli-delete-when-empty;
            presence true;
            leaf all {
              tailf:info "Suppress all ipv6 Router advertisements";
              type empty;
            }
          }

          // interface * / ipv6 nd ra interval
          container interval {
            choice interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<4-1800>;;RA Interval (sec)";
                  range "4..1800";
                }
              }
              leaf msec {
                tailf:info "Interval in milliseconds";
                type uint32 {
                  tailf:info "<70-1800000>;;RA Interval (msec)";
                  range "70..1800000";
                }
              }
            }
          }

          // interface * / ipv6 nd ra lifetime
          leaf lifetime {
            tailf:info "Set IPv6 Router Advertisement Lifetime";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-9000>;;RA Lifetime (seconds)";
              range "0..9000";
            }
          }
        }

        // interface * / ipv6 nd raguard
        container raguard {
          tailf:info "apply the router advertisements (RA) guard feature";
          presence true;
        }

        // interface * / ipv6 nd autoconfig
        container autoconfig {
          tailf:info "Automatic Configuration";

          // interface * / ipv6 nd autoconfig prefix
          leaf "prefix" {
            tailf:info "Prefix";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ipv6 nd autoconfig default-route
          leaf default-route {
            tailf:info "Default Route";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // interface * / ipv6 mld
      container mld {
        tailf:info "interface commands";

        // interface * / ipv6 mld access-group
        leaf access-group {
          tailf:info "source, group membership access";
          type string {
            tailf:info "WORD;;Named access list specifying access group range";
          }
        }
      }

      // interface * / no ipv6 redirects
      leaf redirects {
        tailf:info "Enable sending of ICMP Redirect messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / no ipv6 unreachables
      leaf unreachables {
        tailf:info "Enable sending of ICMP Unreachable messages";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / ipv6 tcp adjust-mss
      container tcp {
        tailf:info "TCP interface commands";
        leaf adjust-mss {
          tailf:info "Adjust the mss of IPV6 transit packets";
          type uint16 {
            tailf:info "<40-1454>;;Maximum segment size in bytes";
            range "40..1454";
          }
        }
      }

      // interface * / ipv6 router isis
      container router {
        tailf:info "IPv6 Router interface commands";
        container isis {
          tailf:info "isis  IS-IS Routing for IPv6";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / ipv6 ospf
      container ospf {
        tailf:info "OSPF interface commands";

        // interface * / ipv6 ospf network
        leaf network {
          tailf:info "Network type";
          tailf:cli-full-command;
          type enumeration {
            enum broadcast {
              tailf:info "Specify OSPF broadcast multi-access network";
            }
            enum non-broadcast {
              tailf:info "Specify OSPF NBMA network";
            }
            enum point-to-multipoint {
              tailf:info "Specify OSPF point-to-multipoint network";
            }
            enum point-to-point {
              tailf:info "Specify OSPF point-to-point network";
            }
          }
        }

        // interface * / ipv6 ospf *
        list process {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;Process ID";
              range "1..65535";
            }
          }
          leaf area {
            tailf:info "Set the OSPF area ID";
            type union {
              type uint32 {
                tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
                range "0..4294967295";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF area ID in IP address format";
              }
            }
          }
          leaf instance {
            tailf:info "Set the OSPF instance";
            type union {
              type uint8 {
                tailf:info "<0-31>;;Instance ID";
                range "0..31";
              }
              type uint8 {
                tailf:info "<32-255>;;Instance ID (DEPRECATED!)";
                range "32..255";
              }
            }
          }
        }

        // interface * / ipv6 ospf bfd
        container bfd {
          tailf:info "Enable BFD on this interface";
          presence true;
          leaf disable {
            tailf:info "Disable BFD on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf cost
        leaf cost {
          tailf:info "Route cost of this interface";
          type uint16 {
            tailf:info "<1-65535>;;Route cost of this interface";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf database-filter
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and flooding";
          choice database {
            leaf all {
              tailf:info "Filter all LSA";
              type enumeration {
                enum out {
                  tailf:info "Outgoing LSA";
                }
              }
            }
            leaf disable {
              tailf:info "Disable LSA Filter on this interface";
              type empty;
            }
          }
        }

        // interface * / ipv6 ospf dead-interval
        leaf dead-interval {
          tailf:info "Interval after which a neighbor is declared dead";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf demand-circuit
        container demand-circuit {
          tailf:info "OSPF demand circuit";
          presence true;
          leaf disable {
            tailf:info "Disable demand circuit on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf flood-reduction
        container flood-reduction {
          tailf:info "OSPF Flood Reduction";
          presence true;
          leaf disable {
            tailf:info "Disable Flood Reduction on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf hello-interval
        leaf hello-interval {
          tailf:info "Time between HELLO packets";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf mtu-ignore
        container mtu-ignore {
          tailf:info "Ignores the MTU in DBD packets";
          presence true;
          leaf disable {
            tailf:info "Disable Ingore MTU on this interface";
            type empty;
          }
        }

        // interface * / ipv6 ospf priority
        leaf priority {
          tailf:info "Router priority";
          type uint16 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf retransmit-interval {
          tailf:info "Time between retransmitting lost link state "+
            "advertisements";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 ospf retransmit-interval
        leaf transmit-delay {
          tailf:info "Link state transmit delay";
          type uint16 {
            tailf:info "<1-65535>;;Seconds";
            range "1..65535";
          }
        }
      }

      // interface * / ipv6 eigrp *
      leaf-list eigrp {
        tailf:cli-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;AS number";
          range "1..65535";
        }
      }

      // interface * / ipv6 mtu
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        type uint16 {
          tailf:info "<1280-9198>;;MTU (bytes)";
          range "1280..9198";
        }
      }

      // interface * / ipv6 crypto map
      container crypto {
        tailf:info "Encryption/Decryption commands";
        container map {
          tailf:info "Assign a Crypto Map";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-diff-dependency "/ios:crypto/map";
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy" {
              tailf:dependency "../redundancy";
            }
            type empty;
          }
        }
      }

      // interface * / ipv6 hold-time eigrp *
      container hold-time {
        tailf:info "Configures EIGRP-IPv6 hold time";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key as-no;
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
              range "1..65535";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds before neighbor is considered down";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ipv6 hello-interval eigrp *
      container hello-interval {
        tailf:info "Configures EIGRP-IPv6 hello interval";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key as-no;
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;AS number";
              range "1..65535";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-65535>;;Seconds between hello transmission";
              range "1..65535";
            }
          }
        }
      }

      // interface * / ipv6 verify
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";

          // interface * / ipv6 verify unicast source reachable-via
          container source {
            tailf:info "Validation of source address";
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source "+
                "address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which "+
                  "packet was received";
                }
              }
            }
          }

          // interface * / ipv6 verify unicast reverse-path
          container reverse-path {
            tailf:info "Reverse path validation of source address "+
              "(old command format)";
            tailf:cli-delete-when-empty;
            presence true;
            leaf access-list {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }

      // interface * / ipv6 dhcp
      container dhcp {
        tailf:info "IPv6 DHCP interface subcommands";

        // interface * / ipv6 dhcp relay
        container relay {
          tailf:info "Act as an IPv6 DHCP relay agent";

          // interface * / ipv6 dhcp relay destination *
          list destination {
            tailf:info "Configure relay destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key ipv6-address;
            leaf ipv6-address {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 address";
              }
            }
            leaf source-address {
              tailf:info "Configure source address to use for relay-forward";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 src address";
              }
            }
            leaf link-address {
              tailf:info "Configure link-address to use for relay-forward";
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 link address";
              }
            }
          }

          // interface * / ipv6 dhcp relay source-interface
          container source-interface {
            tailf:info "Set source interface for relayed messages";
            uses interface-name-grouping;
          }
        }

        // interface * / ipv6 dhcp client
        container client {
          tailf:info "Act as an IPv6 DHCP client";

          // interface * / ipv6 dhcp client information refresh minimum
          container information {
            tailf:info "Configure information refresh option";
            container refresh {
              tailf:info "Configure information refresh parameters";
              leaf minimum {
                tailf:info "Minimum information refresh time";
                type uint16 {
                  tailf:info "<60-3600>;;Seconds";
                  range "60..3600";
                }
              }
            }
          }
        }
      }

      // interface * / ipv6 nhrp
      container nhrp {
        tailf:info "NHRP interface subcommands";

        // interface * / ipv6 nhrp map
        container map {
          tailf:info "Map dest IPv6 address to NBMA address";

          // interface * / ipv6 nhrp map *
          list map-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key ipv6-address;
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/mask of destination";
              }
            }
            leaf nbma-address {
              tailf:cli-drop-node-name;
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP NBMA address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                }
              }
            }
          }

          // interface * / ipv6 nhrp map multicast
          container multicast {
            tailf:info "Use this NBMA mapping for broadcasts/multicasts";

            // interface * / ipv6 nhrp map multicast dynamic
            leaf dynamic {
              tailf:info "Dynamically learn destinations from client "+
                "registrations on hub";
              type empty;
            }

            // interface * / ipv6 nhrp map multicast *
            list multicast-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key nbma-address;
              leaf nbma-address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP NBMA address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 NBMA address";
                  }
                }
              }
            }
          }
        }

        // interface * / ipv6 nhrp network-id
        leaf network-id {
          tailf:info "NBMA network identifier";
          type uint32 {
            tailf:info "<1-4294967295>;;Network identifier";
            range "1..4294967295";
          }
        }

        // interface * / ipv6 nhrp holdtime
        leaf holdtime {
          tailf:info "Advertised holdtime";
          type uint16 {
            tailf:info "<1-65535>;;Number of seconds";
            range "1..65535";
          }
        }

        // interface * / ipv6 nhrp nhs
        container nhs {
          tailf:info "Specify a next hop server";

          // interface * / ipv6 nhrp nhs *
          list nhs-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key nhs-address;
            leaf nhs-address {
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Protocol IPv6 address of NHS";
              }
            }
            // interface * / ipv6 nhrp nhs * nbma
            leaf nbma {
              tailf:info "NBMA of NHS";
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
                type string {
                  tailf:info "WORD;;NHS FQDN string";
                }
              }
            }
            // interface * / ip nhrp nhs * multicast
            leaf multicast {
              when "../nbma" {
                tailf:dependency "../nbma";
              }
              tailf:info "Use this NBMA mapping for broadcasts/multicasts";
              type empty;
            }
          }
        }

        // interface * / ipv6 nhrp server-only
        container server-only {
          tailf:info "Disable NHRP requests";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-caching {
            tailf:info "Do not create NHRP cache entries";
            type empty;
          }
        }

        // interface * / ipv6 nhrp registration
        container registration {
          tailf:info "Settings for registration packets.";

          // interface * / ipv6 nhrp registration no-unique
          leaf no-unique {
            tailf:info "Do not set the 'Unique' flag in registration requests.";
            type empty;
          }

          // interface * / ipv6 nhrp registration timeout
          leaf timeout {
            tailf:info "Time between periodic Registration messages";
            type uint16 {
              tailf:info "<1-65535>;;Number of seconds";
              range "1..65535";
            }
          }
        }

        // interface * / ipv6 nhrp shortcut
        container shortcut {
          tailf:info "Enable shortcut switching";
          presence true;
        }

        // interface * / ipv6 nhrp redirect
        container redirect {
          tailf:info "Enable NHRP redirect traffic indication";
          tailf:cli-delete-when-empty;
          presence true;
          leaf timeout {
            tailf:info "Specify interval over which to throttle";
            type uint8 {
              tailf:info "<2-30>;;Interval in seconds";
              range "2..30";
            }
          }
        }
      }

      // interface * / ipv6 summary-address eigrp *
      container summary-address {
        tailf:info "Perform address summarization";
        tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
        list eigrp {
          tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          key "as-no ipv6-address";
          leaf as-no {
            type uint16 {
              tailf:info "<1-65535>;;Autonomous system number";
              range "1..65535";
            }
          }
          leaf ipv6-address {
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
            }
          }
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-255>;;Administrative distance";
              range "0..255";
            }
          }
        }
      }

      // interface * / ipv6 rip *
      list rip {
        tailf:info "Configure RIP routing protocol";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;User selected string identifying this RIP process";
          }
        }

        // interface * / ipv6 rip * enable
        leaf enable {
          tailf:info "Enable/disable RIP routing";
          type empty;
        }

        // interface * / ipv6 rip * default-information
        container default-information {
          tailf:info "Configure handling of default route";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf default-route {
            tailf:cli-drop-node-name;
            tailf:cli-reset-container;
            type enumeration {
              enum only {
                tailf:info "Advertise only the default route";
              }
              enum originate {
                tailf:info "Originate the default route";
              }
            }
          }
          leaf metric {
            tailf:info "Default route metric";
            type uint8 {
              tailf:info "<1-15>;;Metric value";
              range "1..15";
            }
          }
        }
      }

      // interface * / ipv6 wccp
      container wccp {
        tailf:info "WCCP IPv4 interface commands";
        tailf:cli-diff-dependency "/ios:ipv6/wccp";
        uses interface-ip-wccp-grouping;

        // interface * / ipv6 wccp vrf *
        list vrf {
          tailf:info "Configure WCCP for a VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "/ios:vrf/definition"; //FIXME: MODE
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          uses interface-ip-wccp-grouping;
        }
      }

      // interface * / ipv6 policy route-map
      container policy {
        tailf:info "Enable IPv6 policy routing";
        leaf route-map {
          tailf:info "IPv6 policy-based-routing routemap";
          type string {
            tailf:info "WORD;;Route-map name";
          }
        }
      }
    }

    // interface * / ospfv3
    container ospfv3 {
      tailf:info "OSPFv3 interface commands";
      tailf:cli-diff-dependency "/ios:ipv6/unicast-routing";
      uses interface-ospfv3-grouping;
      list ospfv3-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses interface-ospfv3-grouping;
        container ipv4 {
          tailf:info "Specify parameters for IPv4";
          uses interface-ospfv3-grouping;
        }
        container ipv6 {
          tailf:info "Specify parameters for IPv6";
          uses interface-ospfv3-grouping;
        }
      }
    }

    // interface * / nhrp
    container nhrp {
      tailf:info "NHRP Interface commands";

      // interface * / nhrp group
      leaf group {
        tailf:info "NHRP group name";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;group name string";
        }
      }

      // interface * / no nhrp route-watch
      leaf route-watch {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../ip/nhrp";
        type boolean;
        default true;
      }
    }

    // interface * / if-state nhrp
    container if-state {
      tailf:info "Allow applications to control interface state";
      leaf nhrp {
        tailf:info "Allow NHRP to control interface state";
        type empty;
      }
    }

    // interface * / delay
    leaf delay {
      tailf:info "Specify interface throughput delay";
      type uint32 {
        tailf:info "<1-16777215>;;Throughput delay (tens of microseconds)";
      }
    }

    // interface * / load-interval
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      type uint16 {
        tailf:info "<30-600>;;Load interval delay in seconds";
        range "0..600";
      }
    }

    // interface * / logging event
    container logging {
      tailf:info "Configure logging for interface";
      container event {
        tailf:info "Interface events";

        // interface * / logging event link-status
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / logging event trunk-status
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event bundle-status
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event subif-link-status
        leaf subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / logging event spanning-tree status
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf "status" {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }

        // interface * / logging event nfas-status
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / max-reserved-bandwidth
    leaf max-reserved-bandwidth {
      tailf:info "Maximum Reservable Bandwidth on an Interface";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-100>;;Max. reservable bandwidth as percent of "+
          "interface bandwidth";
        range "1..100";
      }
    }

    // interface * / mls
    container mls {
      tailf:info "mls sub/interface commands";

      // interface * / mls netflow sampling
      container netflow {
        tailf:info "netflow command keyword";
        leaf sampling {
          tailf:info "sampling keyword";
          type empty;
        }
      }

      // interface * / mls qos
      container qos {
        tailf:info "qos command keyword";

        // interface * / mls qos cos
        container cos {
          tailf:info "Configure interface COS parameters";
          leaf cos-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;Class of service value between 0 and 7";
              range "0..7";
            }
          }
          leaf override {
            tailf:info "Force default COS on all packets";
            type empty;
          }
        }

        // interface * / no mls qos channel-consistency
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / mls qos trust
        container trust {
          tailf:info "Configure trust state of interface";

          // interface * / mls qos trust device cisco-phone
          container device {
            tailf:info "trusted device class";
            leaf cisco-phone {
              tailf:info "Cisco IP Phone";
              type empty;
            }
          }

          choice trust-choice {

            // interface * / mls qos trust cos
            container cos {
              tailf:info "Classify by packet COS";
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // interface * / mls qos trust cos pass-through dscp
              container pass-through {
                tailf:info "cos pass-through mode";
                leaf dscp {
                  tailf:info "transmit without dscp modification";
                  type empty;
                }
              }
            }

            // interface * / mls qos trust dscp
            container dscp {
              tailf:info "Classify by packet DSCP";
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;

              // interface * / mls qos trust dscp pass-through cos
              container pass-through {
                tailf:info "dscp pass-through mode";
                leaf cos {
                  tailf:info "transmit without cos modification";
                  type empty;
                }
              }
            }

            // interface * / mls qos trust ip-precedence
            container ip-precedence {
              tailf:info "Classify by packet IP precedence";
              // dep: before this created, must change mls qos vlan-based
              tailf:cli-diff-dependency "../../vlan-based" {
                tailf:cli-trigger-on-set;
              }
              presence true;
            }
          }
        }

        // interface * / mls qos monitor
        container monitor {
          tailf:info "Collect QoS statistics";

          // interface * / mls qos monitor dscp
          leaf-list dscp {
            tailf:info "Collect DSCP statistics";
            tailf:cli-flat-list-syntax;
            tailf:meta-data "max-values" {
              tailf:meta-value "4 :: 8"; // values start after 4 words, max 8 per line
            }
            max-elements 15;
            type uint8 {
              tailf:info "<0-63>;;dscp (up to 15 values total)";
              range "0..63";
            }
          }
        }

        // interface * / mls qos vlan-based
        leaf vlan-based {
          tailf:info "vlan-based keyword";
          tailf:cli-full-command;
          // dep: before this created, must change service-policy
          tailf:cli-diff-dependency "../../../service-policy/input" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../service-policy/output" {
            tailf:cli-trigger-on-set;
          }
          type empty;
        }

        // interface * / mls qos bridged
        leaf bridged {
          tailf:info "bridged keyword";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / auto qos voip
    container auto {
      tailf:info "Configure Automation";
      container qos {
        tailf:info "Configure AutoQoS";
        container voip {
          tailf:info "Configure AutoQoS for VoIP";

          // interface * / auto qos voip cisco-phone
          leaf cisco-phone {
            tailf:info "Trust the QoS marking of Cisco IP Phone";
            type empty;
          }

          // interface * / auto qos voip trust
          leaf trust {
            tailf:info "Trust the COS marking";
            type empty;
          }
        }
      }
    }

    // interface * / mtu
    leaf mtu {
      tailf:info "Set the interface Maximum Transmission Unit (MTU)";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-18000>;;MTU size in bytes";
        range "64..18000";
      }
    }

    // interface * / ntp
    container ntp {
      tailf:info "Configure NTP";

      // interface * / ntp broadcast
      container broadcast {
        tailf:info "Configure NTP broadcast service";
        //tailf:cli-delete-when-empty;
        presence true;
        container client {
          tailf:info "Listen to NTP broadcasts";
          tailf:cli-full-command;
          presence true;
        }

        // interface * / ntp broadcast destination [version] [key] *
        list destination {
          tailf:info "Configure broadcast destination address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key address;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination broadcast IP address";
            }
          }
        }
        container version-key {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure broadcast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Broadcast key number";
            }
          }
        }
      }

      // interface * / ntp disable
      leaf disable {
        tailf:info "Disable NTP traffic (both IP and IPv6)";
        tailf:cli-full-command;
        type empty;
      }

      // interface * / ntp multicast
      container multicast {
        tailf:info "Configure NTP multicast service";
        tailf:cli-display-separated;
        tailf:cli-compact-syntax;
        presence true;

        // interface * / ntp multicast *
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key group-address;
          leaf group-address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast group IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast group IPv6 address";
              }
            }
          }
          leaf version {
            tailf:info "Configure NTP version";
            type uint8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
          leaf "key" {
            tailf:info "Configure multicast authentication key";
            type uint32 {
              tailf:info "<0-4294967295>;;Multicast key number";
            }
          }
          leaf ttl {
            tailf:info "TTL of the multicast packet";
            type uint8 {
              tailf:info "<1-255>;;TTL";
              range "1..255";
            }
          }
        }

        // interface * / ntp multicast version
        leaf version {
          tailf:info "Configure NTP version";
          type uint8 {
            tailf:info "<1-4>;;NTP version number";
            range "1..4";
          }
        }

        // interface * / ntp multicast key
        leaf "key" {
          tailf:info "Configure multicast authentication key";
          type uint32 {
            tailf:info "<0-4294967295>;;Multicast key number";
          }
        }

        // interface * / ntp multicast ttl
        leaf ttl {
          tailf:info "TTL of the multicast packet";
          type uint8 {
            tailf:info "<1-255>;;TTL";
            range "1..255";
          }
        }

        // interface * / ntp multicast client *
        container client-list {
          tailf:cli-drop-node-name;
          leaf-list client {
            tailf:info "Listen to NTP multicasts";
            tailf:cli-list-syntax;
            tailf:cli-suppress-list-no;
            tailf:cli-incomplete-no;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Multicast client IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
              }
            }
          }
        }

        // interface * / ntp multicast client
        leaf client {
          tailf:info "Listen to NTP multicasts";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / power
    container power {
      tailf:info "Power configuration";

      // interface * / power inline
      container inline {
        tailf:info "Inline power configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        // interface * / power inline consumption
        leaf consumption {
          tailf:info "Configure the inline device consumption";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<4000-15400>;;milli-watts";
            range "4000..15400";
          }
        }
        // interface * / power inline auto
        // interface * / power inline never
        // interface * / power inline static
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum auto {
              tailf:info "Automatically detect and power inline devices";
            }
            enum never {
              tailf:info "Never apply inline power";
            }
            enum static {
              tailf:info "High priority inline power interface";
            }
          }
          default auto;
        }
        leaf max {
          tailf:info "Maximum power allowed on this interface";
          when "../mode != 'never'" {
            tailf:dependency "../mode";
          }
          type uint16 {
            tailf:info "<4000-15400>;;milli-watts";
            range "4000..15400";
          }
        }
      }

      // interface * / power client local
      container client {
        tailf:info "Client radio requested maximum transmitter power level";
        leaf local {
          tailf:info "Set power to Access Point local power";
          type empty;
        }
      }
    }

    // interface * / rate-limit
    list rate-limit {
      tailf:info "Rate Limit";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "dir bps bc be conform-action exceed-action";
      leaf dir {
        type enumeration {
          enum "input" {
            tailf:info "Rate limit on input";
          }
          enum "output" {
            tailf:info "Rate limit on output";
          }
        }
      }
      leaf dscp {
        tailf:info "Match dscp value";
        type uint8 {
          tailf:info "<0-63>;;dscp";
          range "0..63";
        }
      }
      //todo: [access-group [rate-limit] acl-index]
      leaf bps {
        tailf:info "<8000-2000000000>;;Bits per second";
        type police-bps-type;
      }
      leaf bc {
        type uint32 {
          tailf:info "<1000-512000000>;;Normal burst bytes";
          range "1000..512000000";
        }
      }
      leaf be {
        type uint32 {
          tailf:info "<2000-1024000000>;;Maximum burst bytes";
          range "2000..1024000000";
        }
      }
      leaf conform-action {
        tailf:cli-expose-key-name;
        type enumeration {
          enum transmit;
        }
      }
      leaf exceed-action {
        tailf:cli-expose-key-name;
        type enumeration {
          enum drop;
        }
      }
    }

    // interface * / service-policy
    container service-policy {
      tailf:info "Configure QoS Service Policy";

      // interface * / service-policy history
      leaf history {
        tailf:cli-full-command;
        tailf:info "Keep history of QoS metrics";
        type empty;
      }

      // interface * / service-policy input
      // interface * / service-policy output
      uses service-policy-grouping;

      // interface * / service-policy type
      container "type" {
        tailf:info "Configure CPL Service Policy";

        // interface * / service-policy type control subscriber
        container control {
          tailf:info "Apply a control policy to the interface";
          leaf subscriber {
            tailf:info "Apply a subscriber control policy to the interfac";
            tailf:non-strict-leafref {
              path "/ios:policy-map-event-control/policy-map/name";
            }
            type string {
              tailf:info "WORD;;policy-map name";
            }
          }
        }

        // interface * / service-policy type performance-monitor
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          uses service-policy-grouping;
        }
      }
    }

    // interface * / service-insertion waas
    container service-insertion {
      tailf:info "Service-insertion AppNav Controller";
      leaf waas {
        tailf:info "Enable Service-insertion";
        type empty;
      }
    }

    // interface * / service-module / t1 timeslots
    container service-module {
      tailf:info "Configure service module";
      container t1 {
        tailf:info "Configure Serial T1 parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf-list timeslots {
          tailf:info "List of timeslots in the T1 group";
          tailf:cli-range-list-syntax;
          tailf:cli-replace-all;
          type uint8 {
            tailf:info "<1-24>;List of timeslots";
            range "1..24";
          }
        }
        leaf speed {
          type enumeration {
            enum "56" {}
            enum "64" {}
          }
        }
      }
    }

    // interface * / group
    leaf group {
      tailf:info "Add this subinterface to a group";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/ios:service-group";
      type uint16 {
        tailf:info "<1-65532>;;Group number";
        range "1..65532";
      }
    }

    // interface * / shutdown
    leaf shutdown {
      // Note: default to "no shutdown" in order to be able to bring if up.
      tailf:info "Shutdown the selected interface";
      tailf:cli-show-no;
      tailf:cli-full-command;
      type empty;
    }

    // interface * / standby
    container standby {
      tailf:info "HSRP interface configuration commands";

      // interface * / standby version
      leaf version {
        tailf:info "HSRP version";
        tailf:cli-full-command;
        type enumeration {
          tailf:info "<1-2>;;Version number";
          enum "1";
          enum "2";
        }
      }

      // interface * / no standby bfd
      leaf bfd {
        tailf:info "Enable HSRP BFD";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / standby delay
      container delay {
        tailf:info "HSRP initialisation delay";
        tailf:cli-compact-syntax;
        leaf minimum {
          tailf:info "Minimum delay";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
        leaf reload {
          tailf:info "Delay after reload";
          type uint16 {
            tailf:info "<0-10000>;;Delay in seconds";
            range "0..10000";
          }
        }
      }

      // interface * / standby mac-refresh
      leaf mac-refresh {
        tailf:info "Refresh MAC cache on switch by periodically sending packet "
          +"from virtual mac address";
        type uint8 {
          tailf:info "<0-255>;;Interval to refresh MAC cache";
          range "0..255";
        }
      }

      // interface * / standby use-bia
      container use-bia {
        tailf:info "HSRP uses interface's burned in address";
        presence true;
        container scope {
          tailf:info "Specify the scope of use-bia";
          leaf interface {
            tailf:info "Use-bia applies to all groups on this interface or sub-"
              +"interface";
            type empty;
          }
        }
      }

      // interface * / standby *
      list standby-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../version";
        key group-number;
        leaf group-number {
          tailf:key-default 0;
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<0-4095>;;group number";
          }
        }

        // interface * / standby * authentication
        container authentication {
          tailf:info "Authentication";
          choice auth {
            leaf word {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "md5|text";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
            container md5 {
              tailf:info "Use MD5 authentication";

              // interface * / standby * authentication md5 key-chain
              leaf key-chain {
                tailf:info "Set key chain";
                type string {
                  tailf:info "WORD;;Name of key-chain";
                }
              }

              // interface * / standby * authentication md5 key-string
              container key-string {
                tailf:info "Set key string";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses password-grouping;
                leaf timeout {
                  tailf:info "Set timeout";
                  type uint16 {
                    tailf:info "<0-32767>;;Timeout until only accepting "
                      +"new key (seconds)";
                    range "0..32767";
                  }
                }
              }
            }

            leaf text {
              tailf:info "Plain text authentication";
              type string {
                tailf:info "WORD;;Plain text authentication string "
                  +"(8 chars max)";
              }
            }
          }
        }

        // interface * / standby * follow
        leaf follow {
          tailf:info "Name of HSRP group to follow";
          type string {
            tailf:info "WORD;;name string (25 chars. max)";
          }
        }

        // interface * / standby * ip
        container ip {
          tailf:info "Enable HSRP and set the virtual IP address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-delete-when-empty;
          presence true;
          leaf address {
            tailf:cli-drop-node-name;
            // dep: before this created, must change below:
            tailf:cli-diff-dependency "../../../../ip-vrf/ip/vrf/forwarding" {
              tailf:cli-trigger-on-set;
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Virtual IP address";
            }
          }
          leaf secondary {
            tailf:info "Make this IP address a secondary virtual IP address";
            type empty;
          }
        }

        // interface * / standby * ipv6
        leaf ipv6 {
          tailf:info "Enable HSRP IPv6";
          type union {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 link-local address";
            }
            type ios:ipv6-prefix;
            type enumeration {
              enum autoconfig {
                tailf:info "Obtain address using autoconfiguration";
              }
            }
          }
        }

        // interface * / standby * mac-address
        leaf mac-address {
          tailf:info "Virtual MAC address";
          type string {
            tailf:info "H.H.H;;MAC address";
          }
        }

        // interface * / standby * name
        leaf name {
          tailf:info "Redundancy name string";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name string";
          }
        }

        // interface * / standby * redirect
        container redirect {
          tailf:info "Configure sending of ICMP Redirect messages with an HSRP "
            +"virtual IP address as the gateway IP address";

          // interface * / standby * redirect authentication md5
          container advertisement {
            tailf:info "Redirect advertisement messages";
            container authentication {
              tailf:info "Authentication";
              container md5 {
                tailf:info "Use MD5 authentication";

                // interface * / standby * redirect authentication md5 key-chain
                leaf key-chain {
                  tailf:info "Set key chain";
                  type string {
                    tailf:info "WORD;;Name of key-chain";
                  }
                }

                // interface * / standby * redirect advertisement authentication md5 key-string
                container key-string {
                  tailf:info "Set key string";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses password-grouping;
                  leaf timeout {
                    tailf:info "Set timeout";
                    type uint16 {
                      tailf:info "<0-32767>;;Timeout until only accepting "
                        +"new key (seconds)";
                      range "0..32767";
                    }
                  }
                }
              }
            }
          }

          // interface * / standby * redirect timers
          container timers {
            tailf:info "Adjust redirect timers";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf advertisement {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<10-180>;;Passive router advertisement interval in "
                  +"seconds";
                range "10..180";
              }
            }
            leaf holddown {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<30-3600>;;Passive router holddown interval in "
                  +"seconds";
                range "30..3600";
              }
            }
          }

          // interface * / standby * redirect unknown
          leaf unknown {
            tailf:info "Redirect to non-HSRP routers";
            type empty;
          }
        }

        // interface * / standby * timers
        container timers {
          tailf:info "Hello and hold timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container hello-interval {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hello-interval-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-254>;;Hello interval in seconds";
                  range "1..254";
                }
              }
              leaf msec {
                tailf:info "Specify hello interval in milliseconds";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<15-999>;;Hello interval in milliseconds";
                  range "15..999";
                }
              }
            }
          }
          container hold-time {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice hold-time-choice {
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Hold time in seconds";
                  range "1..255";
                }
              }
              leaf msec {
                tailf:info "Specify hold time in milliseconds";
                type uint16 {
                  tailf:info "<50-3000>;;Hello interval in milliseconds";
                  range "50..3000";
                }
              }
            }
          }
        }

        // interface * / standby * priority
        leaf priority {
          tailf:info "Priority level";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-255>;;Priority value";
          }
        }

        // interface * / standby * preempt
        container preempt {
          tailf:info "Overthrow lower priority Active routers";
          tailf:cli-compact-syntax;
          //tailf:cli-keep-when-empty;
          tailf:meta-data "trim-delete-when-empty" {
            tailf:meta-value "( preempt)";
          }
          tailf:ned-data "." {
            tailf:transaction to;
          }
          presence true;
          container delay {
            tailf:info "Wait before preempting";
            tailf:cli-compact-syntax;
            leaf minimum {
              tailf:info "Delay at least this long";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for minimum delay";
                range "0..3600";
              }
            }
            leaf reload {
              tailf:info "Delay after reload";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for reload delay";
                range "0..3600";
              }
            }
            leaf sync {
              tailf:info "Wait for IP redundancy client";
              type uint16 {
                tailf:info "<0-3600>;;Number of seconds for sync delay";
                range "0..3600";
              }
            }
          }
        }

        // interface * / standby * track *
        list track {
          //FIXME: key 0 can be ignored (default)
          tailf:info "Priority tracking";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-suppress-range;
            type union {
              type uint16 {
                tailf:info "<0-1000>;;Tracked object number";
              }
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
          }
          choice options {
            case interface {
              leaf priority-decrement {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
            }
            case group-number {
              leaf decrement {
                tailf:info "Priority decrement";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-255>;;Decrement value";
                }
              }
              leaf shutdown {
                tailf:info "Shutdown group";
                tailf:cli-full-command;
                type empty;
              }
            }
          }
        }
      }
    }

    // interface * / storm-control
    container storm-control {
      tailf:info "storm configuration";

      // interface * / storm-control action
      container action {
        tailf:info "Action to take for storm-control";
        leaf shutdown {
          tailf:info "Shutdown this interface if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf trap {
          tailf:info "Send SNMP trap if a storm occurs";
          tailf:cli-full-command;
          type empty;
        }
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          tailf:cli-full-command;
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
      }

      // interface * / storm-control broadcast
      container broadcast {
        tailf:info "Broadcast address storm control";
        // interface * / storm-control broadcast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage "+
              "of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
        // interface * / storm-control broadcast include multicast
        container "include" {
          tailf:info "include other traffic types";
          leaf multicast {
            tailf:info "Suppress broadcast and multicast traffic";
            type empty;
          }
        }
      }

      // interface * / storm-control multicast
      container multicast {
        tailf:info "Multicast address storm control";
        // interface * / storm-control multicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
      }

      // interface * / storm-control unicast
      container unicast {
        tailf:info "Unicast address storm control";
        // interface * / storm-control unicast level
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as "+
              "percentage of bandwidth";
            range "0..100";
          }
        }
        uses storm-control-level-bps-pps-grouping;
      }
    }

    // interface * / wrr-queue
    container wrr-queue {
      tailf:info "Configure weighted round-robin xmt queues";

      // interface * / wrr-queue bandwidth
      container bandwidth {
        tailf:info "Configure WRR minimum bandwidth with weights or "
          +"percentages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice bandwidth-choice {
          case a {
            leaf weight-1 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-2 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-3 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-4 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-5 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-6 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
            leaf weight-7 {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-255>;;enter bandwidth weight";
                range "0..255";
              }
            }
          }
          case b {
            container percent {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf percent-1 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-2 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-3 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-4 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-5 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-6 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
              leaf percent-7 {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-100>;;enter bandwidth percent";
                  range "0..100";
                }
              }
            }
          }
        }
      }

      // interface * / wrr-queue dscp-map *
      list dscp-map {
        tailf:info "Configure dscp-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "queue threshold";
        leaf queue {
          type uint8 {
            tailf:info "<1-7>;;enter dscp-map queue id";
          }
        }
        leaf threshold {
          type uint8 {
            tailf:info "<1-4>;;enter dscp-map threshold id";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "value";
          leaf "value" {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }

      // interface * / wrr-queue cos-map *
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-4>;;enter cos-map queue id";
            range "1..4";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "0..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          tailf:meta-data "max-values-copy-meta" {
            tailf:meta-value "4 :: 1"; // values start after 4 words, max 1 value per line
          }
          tailf:meta-data "default-value" {
            tailf:meta-value "$1 $2<NL> <DEFAULT><NL>exit<NL> :: MAP=WRR-QUEUE-COSMAP";
          }
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values total)";
            range "0..7";
          }
        }
      }

      // interface * / wrr-queue queue-limit
      container queue-limit {
        tailf:info "Configure queue-limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf weight-a {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-b {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-c {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-d {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-e {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-f {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
        leaf weight-g {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-100>;;enter queue size weight";
            range "0..100";
          }
        }
      }

      // interface * / wrr-queue random-detect
      container random-detect {
        tailf:info "Configure random-detect";
        list max-threshold {
          tailf:info "Max threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }
          uses queue-size-grouping;
        }
        list min-threshold {
          tailf:info "Min threshold for WRED";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;enter queue id";
              range "1..3";
            }
          }
          uses queue-size-grouping;
        }
      }

      // interface * / wrr-queue threshold *
      list threshold {
        tailf:info "Configure queue tail-drop thresholds";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;enter queue id";
            range "1..3";
          }
        }
        uses queue-size-grouping;
      }

      // interface * / wrr-queue min-reserve *
      list min-reserve {
        tailf:info "Configure min-reserve level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-4>;;queue id";
            range "1..4";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-8>;;min-reserve level";
            range "1..8";
          }
        }
      }
    }

    // interface * / no wrr-queue random-detect *
    container no-list {
      tailf:info "no wrr-queue random-detect entry";
      container wrr-queue {
        tailf:info "Configure weighted round-robin xmt queues";
        list random-detect {
          tailf:info "Configure random-detect";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
            }
          }
        }
      }
    }

    // interface * / priority-queue
    container priority-queue {
      tailf:info "Configure priority scheduling";

      // interface * / priority-queue queue-limit
      leaf queue-limit {
        tailf:info "configure priority queue limit";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;enter queue size weight";
          range "0..100";
        }
      }

      // interface * / priority-queue dscp-map *
      list dscp-map {
        tailf:info "Configure dscp-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-1>;;enter priority queue id";
            range "1";
          }
        }
        list values {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "value";
          leaf "value" {
            tailf:cli-multi-word-key;
            type string;
          }
        }
      }

      // interface * / priority-queue cos-map *
      container cos-map {
        tailf:info "Configure cos-map for a queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf id {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-1>;;enter cos-map queue id";
            range "1";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          tailf:meta-data "default-value" {
            tailf:meta-value "$1 $2<NL> <DEFAULT><NL>exit<NL> :: priority-queue cos-map 1 5";
          }
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces (up to 8 values total)";
            range "0..7";
          }
        }
      }

      // interface * / priority-queue out
      leaf out {
        tailf:info "egress priority queue";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / rep
    container rep {
      tailf:info "Resilient Ethernet Protocol characteristics";

      // interface * / rep block
      container block {
        tailf:info "Block port & VLANs for VLAN Load-balancing";
        container port {
          tailf:info "Specify port for VLAN Load-balancing";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          choice port-choice {
            leaf neighbor-offset {
              tailf:cli-drop-node-name;
              type int16 {
                tailf:info "<-256 - 256>;;Neighbor offset";
                range "-256..256";
              }
            }
            leaf id {
              tailf:info "REP port ID";
              type string {
                tailf:info "WORD;;REP port ID (16 digit hexadecimal number)";
              }
            }
            leaf preferred {
              tailf:info "Preferred flag";
              type empty;
            }
          }
          leaf vlan {
            tailf:info "VLANs to block";
            type union {
              type string {
                tailf:info "WORD;;VLAN list (1-4094) ex: 1-65,72,300-320";
              }
              type enumeration {
                enum all {
                  tailf:info "All VLANs";
                }
              }
            }
          }
        }
      }

      // interface * / rep preempt
      container preempt {
        tailf:info "Preemption options";
        leaf delay {
          tailf:info "Delay timer in seconds";
          type uint16 {
            tailf:info "<15-300>;;number of seconds before automatic "
              +"preemption takes place";
            range "15..300";
          }
        }
      }

      // interface * / rep segment
      container segment {
        tailf:info "REP segment ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-1024>;;Between 1 and 1024";
            range "1..1024";
          }
        }
        leaf edge {
          tailf:info "Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf no-neighbor {
          tailf:info "No-Neighbor Edge Port";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf primary {
          tailf:info "Primary Edge Port";
          tailf:cli-optional-in-sequence;
          when "../edge" {
            tailf:dependency "../edge";
          }
          type empty;
        }
        leaf preferred {
          tailf:info "Preferred Alternate Port";
          type empty;
        }
      }
      container stcn {
        tailf:info "Segment Topology Change Notification";
        leaf segment {
          tailf:info "for REP segment";
          type string {
            tailf:info "WORD;;segment ID list (1-1024) ex: 1-3,6-9";
          }
        }
        leaf stp {
          tailf:info "for STP network";
          type empty;
        }
      }
    }

    // interface * / rcv-queue
    container rcv-queue {
      tailf:info "Configure receive queue(s)";
      list cos-map {
        tailf:info "Configure cos-map for a queue threshold";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "queue-id threshold-id";
        leaf queue-id {
          type uint8 {
            tailf:info "<1-3>;;enter cos-map queue id";
            range "1..3";
          }
        }
        leaf threshold-id {
          type uint8 {
            tailf:info "<1-8>;;enter cos-map threshhold id";
            range "1..8";
          }
        }
        leaf-list cos-values {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          max-elements 8;
          type uint8 {
            tailf:info "<0-7>;;cos values separated by spaces "+
              "(up to 8 values total)";
            range "0..7";
          }
        }
      }
    }

    // interface * / udld
    container udld {
      tailf:info "Configure UDLD enabled or disabled and ignore global UDLD "
        +"setting";
      container port {
        tailf:info "Enable UDLD protocol on this interface despite global UDLD "
          +"setting";
        tailf:cli-delete-when-empty;
        presence true;
        choice port-choice {
          leaf aggressive {
            tailf:info "Enable UDLD protocol in aggressive mode on this "
              +"interface despite global UDLD setting";
            type empty;
          }
          leaf disable {
            tailf:info "Disable UDLD protocol on this interface despite global "
              +"UDLD setting";
            type empty;
          }
        }
      }
    }

    // interface * / peer
    container peer {
      tailf:info "Peer parameters for point to point interfaces";

      // interface * / no peer neighbor-route
      leaf neighbor-route {
        tailf:info "Create neighbor route to peer if needed";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // interface * / peer default ip address
      container "default" {
        tailf:info "Specify default parameters";
        container ip {
          tailf:info "Specify default IP parameters";
          container address {
            tailf:info "Specify default IP address";
            choice address-choice {
              leaf dhcp {
                tailf:info "Use DHCP proxy client mechanism to allocate a peer "
                  +"IP address";
                type empty;
              }
              container dhcp-pool {
                tailf:info "Use local DHCP pools to allocate a peer IP address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
              container pool {
                tailf:info "Use IP pool mechanism to allocate a peer IP "
                  +"address";
                presence true;
                leaf pools {
                  tailf:cli-drop-node-name;
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;List of one or more DHCP address pools";
                  }
                }
              }
            }
          }
        }
      }
    }

    // interface * / clns
    container clns {
      tailf:info "CLNS interface subcommands";

      // interface * / clns mtu
      leaf mtu {
        tailf:info "Set MTU packet size for interface";
        type uint32 {
          tailf:info "<512-4294967295>;;CLNS MTU packet size for interface";
        }
      }

      // interface * / clns router
      container router {
        tailf:info "Enable CLNS routing protocol on interface";

        // interface * / clns router isis
        container isis {
          tailf:info "ISO IS-IS routing protocol";
          tailf:cli-delete-when-empty;
          presence true;
          leaf tag {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }

      // interface * / no clns route-cache
      leaf route-cache {
        tailf:info "Enable fast switching through the cache";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / dsu
    container dsu {

      // interface * / dsu bandwidth
      leaf bandwidth {
        tailf:cli-full-command;
        type uint32;
      }

      // interface * / dsu mode
      leaf mode {
        tailf:cli-full-command;
        type enumeration {
          enum 1 {
            tailf:info "DSU mode 1";
          }
          enum 2 {
            tailf:info "DSU mode 2";
          }
        }
      }
    }

    // interface * / framing
    leaf framing {
      tailf:info "Framing interface subcommands";
      tailf:cli-full-command;
      type enumeration {
        enum bypass {
        }
        enum g751 {
          tailf:info "G.751 framing";
        }
        enum c-bit {
        }
        enum m13 {
        }
      }
    }

    // interface * / cablelength
    leaf cablelength {
      tailf:cli-full-command;
      type uint32;
    }

    // interface * / isdn
    container isdn {
      tailf:info "ISDN Interface configuration commands";

      // interface * / isdn switch-type
      leaf switch-type {
        tailf:info "Select the Interface ISDN switch type";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Switch type";
        }
      }

      // interface * / isdn protocol-emulate
      leaf protocol-emulate {
        tailf:info "Protocol (L2/L3) emulation network/user side";
        tailf:cli-full-command;
        type enumeration {
          enum network {
            tailf:info "ISDN protocol emulation network side";
          }
          enum user {
            tailf:info "ISDN protocol emulation user side (default)";
          }
        }
      }

      // interface * / isdn incoming-voice
      container incoming-voice {
        tailf:info "Specify options for incoming calls.";
        choice incoming-voice-choice {
          leaf voice {
            tailf:info "Incoming voice calls will be handled as voice.";
            type empty;
          }
          container data {
            tailf:info "Incoming voice calls will be handled as data.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "B Channel Bandwidth of 56Kb/s";
                }
                enum "64" {
                  tailf:info "B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
          container modem {
            tailf:info "Incoming voice calls will be handled as modems.";
            tailf:cli-delete-when-empty;
            presence true;
            leaf kbps {
              tailf:cli-drop-node-name;
              type enumeration {
                enum "56" {
                  tailf:info "56  B Channel Bandwidth of 56Kb/s  ";
                }
                enum "64" {
                  tailf:info "64  B Channel Bandwidth of 64Kb/s";
                }
              }
            }
          }
        }
      }

      // interface * / isdn supp-service
      container supp-service {
        tailf:info "Specify the subscribed supplementary service";
        container name {
          tailf:info "Specify the subscribed name service";
          container calling {
            tailf:info "calling name service";
            tailf:cli-delete-when-empty;
            presence true;
          }
        }
      }

      // interface * / isdn termination multidrop
      container termination {
        tailf:info "To connect the TR pair and to in turn enable internal termination";
        leaf multidrop {
          tailf:info "Enable multidrop Internal termination";
          type empty;
        }
      }

      // interface * / isdn termination point-to-point-setup
      leaf point-to-point-setup {
        tailf:info "Bri send point-to-point SETUP";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / scramble
    leaf scramble {
      tailf:cli-full-command;
      type empty;
    }

      // interface * / clock source
    container clock {
      tailf:info "Configure interface clock source";
      leaf source {
        type enumeration {
          enum internal {
            tailf:info "Internal clock source";
          }
          enum external {
            tailf:info "External clock source";
          }
          enum line {
            tailf:info "Line clock source";
          }
        }
      }

      // interface * / clock rate
      leaf rate {
        tailf:info "Clock rate";
        type uint32 {
          tailf:info "NUM;;Clock rate, round of to the nearest supported "+
            "value by device. Please set exact to avoid diff.";
        }
      }
    }

    // interface * / down-when-looped
    leaf down-when-looped {
      tailf:info "Force looped serial interface down";
      tailf:cli-full-command;
      type empty;
    }

    // interface * / crc
    leaf crc {
      tailf:info "CRC interface subcommands";
      tailf:cli-full-command;
      type enumeration {
        enum 16 {
          tailf:info "Setting CRC-16";
        }
        enum 32 {
          tailf:info "Setting CRC-32";
        }
      }
    }

    // interface * / carrier-delay
    container carrier-delay {
      tailf:info "Specify delay for interface transitions";
      uses carrier-delay-grouping;
      // interface * / carrier-delay up
      container up {
        tailf:info "Carrier Up Transitions";
        uses carrier-delay-grouping;
      }
      // interface * / carrier-delay down
      container down {
        tailf:info "Carrier Down Transitions";
        uses carrier-delay-grouping;
      }
    }

    // interface * / trunk-group
    leaf trunk-group {
      tailf:info "Configure interface to be in a trunk group";
      tailf:non-strict-leafref {
        path "/ios:trunk/group/name";
      }
      type string {
        tailf:info "WORD;;Trunk group label";
      }
    }

    // interface * / crypto
    container crypto {
      tailf:info "Encryption/Decryption commands";

      // interface * / crypto engine
      container engine {
        tailf:info "";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf slot {
          tailf:info "WORD;;<integer>/<integer>";
          type string;
        }
        leaf location {
          tailf:info "";
          tailf:cli-drop-node-name;
          type enumeration {
            enum "inside";
            enum "outside";
          }
        }
      }

      // interface * / crypto map
      container map {
        tailf:info "Assign a Crypto Map";
        container ipv4 {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "ipv6";
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy" {
              tailf:dependency "../redundancy";
            }
            type empty;
          }
        }
        container ipv6 {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf map-name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "/ios:crypto/map/name";
            }
            type string {
              tailf:info "WORD;;Crypto Map tag";
            }
          }
          leaf redundancy {
            tailf:info "enable redundancy";
            type string {
              tailf:info "WORD;;Name of IP Redundancy Group";
            }
          }
          leaf stateful {
            tailf:info "enable stateful failover";
            when "../redundancy" {
              tailf:dependency "../redundancy";
            }
            type empty;
          }
        }
      }
    }

    // interface * / no routing dynamic
    container routing {
      tailf:info "Per-interface routing configuration";
      leaf dynamic {
        tailf:info "participates in routing protocols";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // interface * / autonomic connect
    container autonomic {
      tailf:info "Autonomic Networking";
      leaf connect {
        tailf:info "Connect to External Device";
        type empty;
      }
    }

    // interface * / performance monitor context
    container performance {
      tailf:info "Global performance monitor configuration";
      container monitor {
        tailf:info "monitor";
        leaf context {
          tailf:info "Select ezPM context";
          tailf:cli-diff-dependency "/ios:performance/monitor/context[name=current()]/exporter/destination";
          tailf:non-strict-leafref {
            path "/ios:performance/monitor/context/name";
          }
          type string {
            tailf:info "WORD;;User defined ezPM context";
          }
        }
      }
    }

    // interface * / qos
    container qos {
      tailf:info "QoS configuration";

      // interface * / qos trust
      container trust {
        tailf:info "Trust state of the interface";
        choice trust-choice {
          leaf dscp {
            tailf:info "Trust DSCP";
            type empty;
          }
          leaf cos {
            tailf:info "Trust CoS";
            type empty;
          }
          leaf device {
            tailf:info "trusted device class";
            type enumeration {
              enum cisco-phone {
                tailf:info "Cisco IP Phone";
              }
            }
          }
        }
      }

      // interface * / qos pre-classify
      leaf pre-classify {
        tailf:info "Enable QOS classification before packets are tunnel "+
          "encapsulated";
        type empty;
      }
    }

    // interface * / tx-queue *
    list tx-queue {
      tailf:info "Configure interface transmit queue";
      tailf:cli-mode-name "config-if-tx-queue";
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-4>;;Transmit queue number";
          range "1..4";
        }
      }

      // interface * / tx-queue * / bandwidth
      container bandwidth {
        tailf:info "Bandwidth for this queue";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        choice bandwidth-choice {
          // interface * / tx-queue * / bandwidth
          case numeric {
            leaf "value" {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<16000-1000000000>;;Bandwidth (Sharing rate) "+
                  "(postfix k, m, g optional; decimal point allowed)";
              }
            }
            leaf unit {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "UNIT;;kbps | mbps | gbps";
              }
            }
          }
          // interface * / tx-queue * / bandwidth percent
          leaf percent {
            tailf:info "% of the link bandwidth";
            type uint8 {
              tailf:info "<1-100>;;percent";
              range "1..100";
            }
          }
        }
      }

      // interface * / tx-queue * / priority high
      leaf priority {
        tailf:info "Priority of this queue";
        type enumeration {
          enum high {
            tailf:info "High priority queue";
          }
        }
      }
    }

    // interface * / link state group
    container link {
      tailf:info "Configure Link";
      container state {
        tailf:info "Configure link state";
        container group {
          tailf:info "Configure link state group";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-10>;;Link state group number";
              range "1..10";
            }
          }
          leaf direction {
            tailf:cli-drop-node-name;
            type enumeration {
              enum downstream {
                tailf:info "Downstream interface";
              }
              enum upstream {
                tailf:info "Upstream interface";
              }
            }
          }
        }
      }
    }

    // interface * / source template
    container source {
      tailf:info "Get config from another source";
      leaf template {
        tailf:info "Get config from a template";
        tailf:non-strict-leafref {
          path "/ios:template/name";
        }
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // interface * / l2protocol
    container l2protocol {
      tailf:info "Configure l2 control protocol processing";

      // interface * / l2protocol peer
      container peer {
        tailf:info "peer L2 control protocol packets as data";
        tailf:cli-delete-when-empty;
        presence true;
        leaf-list protocol {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type l2protocol-type;
        }
      }

      // interface * / l2protocol forward
      container forward {
        tailf:info "forward L2 control protocol packets as data";
        tailf:cli-delete-when-empty;
        presence true;
        leaf-list protocol {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type l2protocol-type;
        }
      }
    }

    // interface * / zone-member security
    container zone-member {
      tailf:info "Apply zone name";
      leaf security {
        tailf:info "Security zone";
        tailf:cli-diff-dependency "../../vrf/forwarding";
        tailf:non-strict-leafref {
          path "/ios:zone/security/id";
        }
        type string {
          tailf:info "WORD;;Zone";
        }
      }
    }

  } // grouping interface-common-grouping0

  grouping interface-common-grouping {
    uses interface-common-grouping0 {
      refine "ip/helper-address/vrf/vrf" {
        tailf:cli-diff-dependency "../../../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../../../vrf/definition";
      }
      refine "crypto/map/ipv4/map-name" {
        tailf:cli-diff-dependency "../../../../../../crypto/map";
      }
      refine "crypto/map/ipv6/map-name" {
        tailf:cli-diff-dependency "../../../../../../crypto/map";
      }
      refine "ip/mobile/router-service/roam" {
        tailf:cli-diff-dependency "../../../../../../router/mobile";
      }
      refine "ip/pim/mode" {
        tailf:cli-diff-dependency "../../../../../ip/multicast-routing";
      }
    }
  }

  grouping sub-interface-common-grouping {
    uses interface-common-grouping0 {
      refine "ip/helper-address/vrf/vrf" {
        tailf:cli-diff-dependency "../../../../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../../../../vrf/definition";
      }
      refine "crypto/map/ipv4/map-name" {
        tailf:cli-diff-dependency "../../../../../../../crypto/map";
      }
      refine "crypto/map/ipv6/map-name" {
        tailf:cli-diff-dependency "../../../../../../../crypto/map";
      }
      refine "ip/mobile/router-service/roam" {
        tailf:cli-diff-dependency "../../../../../../../router/mobile";
      }
      refine "ip/pim/mode" {
        tailf:cli-diff-dependency "../../../../../../ip/multicast-routing";
      }
    }
  }


  // grouping interface-common-switch-grouping
  grouping interface-common-switch-grouping {
    uses interface-common-grouping {
      // LAYER 2 config (switchport set)
      refine "ip/dhcp/snooping" {
        tailf:cli-diff-dependency "../../../switchport";
      }
      refine "ip/verify" {
        tailf:cli-diff-dependency "../../switchport";
      }
      // LAYER 3 config (switchport not set)
      refine "ip/igmp" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../switchport";
      }
      refine "ip/ospf" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "ip/redirects" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "standby" {
        tailf:cli-diff-dependency "../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "service-policy/input" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "service-policy/output" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "udld" {
        tailf:cli-diff-dependency "../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
    }
  }

  // grouping sub-interface-common-switch-grouping
  grouping sub-interface-common-switch-grouping {
    uses sub-interface-common-grouping {
      // LAYER 2 config (switchport set)
      refine "ip/dhcp/snooping" {
        tailf:cli-diff-dependency "../../../switchport";
      }
      refine "ip/verify" {
        tailf:cli-diff-dependency "../../switchport";
      }
      // LAYER 3 config (switchport not set)
      // dep: before switchport deleted, must change below
      refine "ip/igmp" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../switchport";
      }
      refine "ip/ospf" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "ip/redirects" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "standby" {
        tailf:cli-diff-dependency "../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "service-policy/input" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "service-policy/output" {
        tailf:cli-diff-dependency "../../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
      refine "udld" {
        tailf:cli-diff-dependency "../switchport" {
          tailf:cli-trigger-on-set;
        }
      }
    }
  }

  // interface-tunnel-grouping
  grouping interface-tunnel-grouping {

    // interface * / tunnel
    container tunnel {
      tailf:info "protocol-over-protocol tunneling";

      // interface * / tunnel source
      leaf source {
        tailf:info "source of tunnel packets";
        type string; // interface or address
      }

      // interface * / tunnel destination
      leaf destination {
        tailf:info "destination of tunnel";
        type inet:host {
          tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Destination address";
        }
      }

      // interface * / tunnel mode
      container mode {
        tailf:info "tunnel encapsulation method";
        choice mode-choice {

          // interface * / tunnel mode ipsec
          container ipsec {
            tailf:info "IPSec tunnel encapsulation";
            container ipv4 {
              tailf:info "over IPv4";
              tailf:cli-delete-when-empty;
              presence true;
            }
          }

          // interface * / tunnel mode mpls traffic-eng
          container mpls {
            tailf:info "MPLS encapsulations";
            container traffic-eng {
              tailf:info "Traffic engineering tunnels";
              tailf:cli-delete-when-empty;
              presence true;
              leaf gre-ip {
                type empty;
              }
              leaf point-to-multipoint {
                tailf:info "point-to-multipoint tunnel mode";
                tailf:cli-full-command;
                type empty;
              }
            }
          }

          // interface * / tunnel mode gre
          container gre {
            tailf:info "generic route encapsulation protocol";
            choice gre-choice {
              container multipoint {
                tailf:info "over IPv4 (multipoint)";
                presence true;
                leaf ipv6 {
                  tailf:info "over IPv6";
                  type empty;
                }
              }
              leaf ip {
                tailf:info "over IP";
                type empty;
              }
              leaf ipv6 {
                tailf:info "over IPv6";
                type empty;
              }
              default ip;
            }
          }

          // interface * / tunnel mode eon
          leaf eon {
            tailf:info "EON compatible CLNS tunnel";
            type empty;
          }

          // interface * / tunnel mode ipv6
          leaf ipv6 {
            tailf:info "Generic packet tunneling in IPv6";
            type empty;
          }
        }
      }

      // interface * / tunnel key
      leaf "key" {
        tailf:info "security or selector key";
        type uint32 {
          tailf:info "<0-4294967295>;;key";
          range "0..4294967295";
        }
      }

      // interface * / tunnel vrf
      leaf vrf {
        tailf:info "set tunnel vrf membership";
        tailf:cli-diff-dependency "../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../vrf/definition";
        type string {
          tailf:info "WORD;;vrf table name";
        }
      }

      // interface * / tunnel path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable Path MTU Discovery on tunnel";
        presence true;
      }

      // interface * / tunnel protection ipsec profile
      container protection {
        tailf:info "Enable tunnel protection";
        container ipsec {
          tailf:info "Use ipsec to protect this tunnel interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf profile {
            tailf:info "Determine the ipsec policy profile to use.";
            tailf:non-strict-leafref {
              path "../../../../../../crypto/ipsec/profile/name";
            }
            type string {
              tailf:info "WORD;;IPSec policy profile";
            }
          }
          choice profile-choice {
            // interface * / tunnel protection ipsec profile ? isakmp-profile
            leaf isakmp-profile {
              tailf:info "Specify isakmp profile for the crypto connection.";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/isakmp/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name.";
              }
            }
            // interface * / tunnel protection ipsec profile ? ikev2-profile
            leaf ikev2-profile {
              tailf:info "Specify ikev2 profile for the crypto connection.";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name.";
              }
            }
            // interface * / tunnel protection ipsec profile ? shared
            leaf shared {
              tailf:info "Use a shared socket for the crypto connection.";
              type empty;
            }
          }
        }
      }

      // interface * / tunnel mpls
      container mpls {
        tailf:info "MPLS tunnel commands";

        // interface * / tunnel mpls traffic-eng
        container traffic-eng {
          tailf:info "Configure traffic engineering tunnel parameters";
          tailf:cli-diff-dependency "../../mode/mpls/traffic-eng";

          // interface * / tunnel mpls traffic-eng name
          leaf name {
            tailf:info "specify a name describing the TE tunnel";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Name of tunnel (max of 63 characters)";
            }
          }

          // interface * / tunnel mpls traffic-eng affinity
          container affinity {
            tailf:info "desired link attributes for links comprising tunnel";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf attributes {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity value";
              }
            }
            leaf mask {
              tailf:info "mask on desired link attributes";
              type string {
                tailf:info "<0x0-0xFFFFFFFF>;;affinity mask value";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng autoroute
          container autoroute {
            tailf:info "parameters for routing over tunnel";
            leaf announce {
              tailf:info "announce tunnel to IGP";
              tailf:cli-full-command;
              type empty;
            }
          }

          // interface * / tunnel mpls traffic-eng priority
          container priority {
            tailf:info "tunnel priority";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf setup-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;setup priority";
                range "0..7";
              }
            }
            leaf hold-priority {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;hold priority";
                range "0..7";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng bandwidth
          container bandwidth {
            tailf:info "tunnel bandwidth requirement";
            leaf requirement {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;bandwidth requirement in kbps";
              }
            }
          }

          // interface * / tunnel mpls traffic-eng path-option *
          list path-option {
            tailf:info "a primary or fallback path setup option";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-1000>;;preference for this path option";
              }
            }
            leaf protect {
              tailf:info "a path protection setup option";
              tailf:cli-optional-in-sequence;
              tailf:cli-prefix-key;
              type empty;
            }
            choice path-option-choice {
              container dynamic {
                tailf:info "setup based on dynamically calculcated path";
                presence true;
              }
              container explicit {
                tailf:info "setup based on preconfigured path";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                choice explicit-choice {
                  leaf name {
                    tailf:info "Specify an IP explicit path by name";
                    type string {
                      tailf:info "WORD;;Name of ip explicit path";
                    }
                  }
                  leaf identifier {
                    tailf:info "Specify an IP explicit path by number";
                    type uint16 {
                      tailf:info "<1-65535>;;Number of ip explicit path";
                    }
                  }
                }
              }
            }
            leaf lockdown {
              tailf:info "not a candidate for reoptimization";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf verbatim {
              type empty;
            }
          }

          // interface * / tunnel mpls traffic-eng auto-bw
          container auto-bw {
            tailf:info "Specify mpls tunnel should automatically change bw";
            presence true;
          }

          // interface * / tunnel mpls traffic-eng fast-reroute
          container fast-reroute {
            tailf:info "Specify mpls tunnel can be fast-rerouted";
            presence true;
          }
        }
      }
    }

    // interface * / domain
    container domain {
      tailf:info "Specify a domain";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf domain-name {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "/ios:domain/name";
        }
        type string {
          tailf:info "WORD;;Domain name"; // default: default
        }
      }
      leaf "path" {
        tailf:info "Specify a service provider for this interface";
        type string {
          tailf:info "WORD;;Specify the color of service provider";
        }
      }
      leaf path-id {
        tailf:cli-break-sequence-commands;
        tailf:info "Specify Path ID";
        type uint8 {
          tailf:info "<1-62>;;Path ID";
          range "1..62";
        }
      }
      leaf internet-bound {
        tailf:info "Specify Internet-bound interface";
        tailf:cli-full-command;
        type empty;
      }
      leaf zero-sla {
        tailf:info "Specify if you want this interface to be a 0-sla interface";
        tailf:cli-full-command;
        type empty;
      }
      leaf path-last-resort {
        tailf:info "Specify if you want this interface to be a path of last resort";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  // interface-ethernet-pre-grouping
  grouping interface-ethernet-pre-grouping {

    // interface * / port-type
    leaf port-type {
      tailf:info "Set port type";
      type enumeration {
        enum eni {
          tailf:info "Set port-type to ENI";
        }
        enum nni {
          tailf:info "Set port-type to NNI";
        }
        enum uni {
          tailf:info "Set port-type to UNI";
        }
      }
    }

    // interface * / platform ring
    container platform {
      tailf:info "Configure platform";
      container ring {
        tailf:info "Configure ring entries commands";
        leaf rx {
          tailf:info "Configure receiver ring entries";
          type uint16 {
            tailf:info "<1-4096>;;Number of ring entries for the Rx ring";
            range "1..4096";
          }
        }
        leaf tx {
          tailf:info "Configure transmit ring entries";
          type uint16 {
            tailf:info "<1-4096>;;Number of ring entries for the Tx ring";
            range "1..4096";
          }
        }
      }
    }

    // interface * / encapsulation
    container encapsulation {
      tailf:info "Set encapsulation type for an interface";

      // interface * / encapsulation dot1Q
      container dot1Q {
        tailf:info "IEEE 802.1Q Virtual LAN";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;IEEE 802.1Q VLAN ID required";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:info "Configure this subinterface as a 1Q-in-1Q subinterface";
          tailf:cli-optional-in-sequence;
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum any {
                tailf:info "All Inner VLAN IDs not configured on another "+
                "subinterface";
              }
            }
            type string {
              tailf:info "Second (inner) VLAN IDs e.g. "+
                "100,200-300,400,500-600";
            }
          }
        }
        leaf native {
          tailf:info "Make this as native vlan";
          type empty;
        }
      }
    }
  }

  // interface-ethernet-grouping0
  grouping interface-ethernet-grouping0 {

    // interface * / mac access-group * in
    // interface * / mac access-group * out
    container mac {
      tailf:info "MAC interface commands";
      list access-group {
        tailf:info "MAC access-group configuration commands";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Apply to Ingress";
            }
            enum out {
              tailf:info "Apply to Egress";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "/ios:mac/access-list/extended/id";
          }
          type string {
            tailf:info "WORD;;ACL name";
          }
        }
      }
    }

    // interface * / spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";

      // interface * / spanning-tree bpdufilter
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }

      // interface * / spanning-tree bpduguard
      container bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        choice bpduguard-choice {
          leaf disable {
            tailf:info "Disable BPDU guard for this interface";
            type empty;
          }
          leaf enable {
            type empty;
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }

      // interface * / spanning-tree cost
      leaf cost {
        tailf:info "To set the path cost of the interface";
        tailf:cli-full-command;
        type uint32 {
          range "1..200000000";
        }
      }

      // interface * / spanning-tree guard
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        tailf:cli-full-command;
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on "
            +"interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on "
            +"interface";
          }
        }
      }

      // interface * / spanning-tree link-type
      leaf link-type {
        tailf:info "Specify a link type for spanning tree tree "
          +"protocol use";
        tailf:cli-full-command;
        type enumeration {
          enum auto {
            tailf:code-name link_type_auto;
            tailf:info "Determine link type based on media "
            +"duplex of this interface";
          }
          enum none {
            tailf:info "Consider the interface as point-to-"
            +"point";
          }
          enum point-to-point {
            tailf:info "Consider the interface as point-to-"
              +"point";
          }
          enum root {
            tailf:info "Consider the interface as shared";
          }
        }
      }

      // interface * / spanning-tree mst
      container mst {
        tailf:info "Multiple spanning tree";
        choice mst-choice {
          list instance-range {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-range-list-syntax;
            key id;
            leaf id {
              type uint16 {
                tailf:info "MST instance list, example 0,2-4,6,8-12";
              }
            }
            leaf cost {
              tailf:info "Change the interface spanning tree path cost for an instance";
              type uint32 {
                tailf:info "<1-200000000>;;Change the interface spanning tree "+
                  "path cost for an instance";
                range "1..200000000";
              }
            }
            leaf port-priority {
              tailf:info "Change the spanning tree port priority for an instance";
              type uint16 {
                tailf:info "<0-240>;;port priority in increments of 16";
                range "0..240" {
                  tailf:step 16;
                }
              }
            }
          }
          leaf pre-standard {
            tailf:info "Force pre-standard MST BPDU transmission on port";
            type empty;
          }
        }
      }

      // interface * / spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        choice portfast-choice {
          leaf disable {
            tailf:info "Disable portfast for this interface";
            type empty;
          }
          leaf network {
            tailf:info "Enable portfast network on the interface";
            type empty;
          }
          case trunk-mode {
            leaf edge {
              tailf:info "Enable portfast edge on the interface";
              type empty;
            }
            leaf trunk {
              tailf:info "Enable portfast edge on the interface even in trunk mode";
              type empty;
            }
          }
        }
      }

      // interface * / spanning-tree loopguard default
      container loopguard {
        tailf:info "Spanning tree loopguard options";
        leaf "default" {
          tailf:info "Enable loopguard by default on all ports";
          type empty;
        }
      }
    }

    // interface * / srr-queue bandwidth
    container srr-queue {
      tailf:info "Configure shaped round-robin transmit queues";
      container bandwidth {
        tailf:info "Configure shared bandwidth";

        // interface * / srr-queue bandwidth limit
        leaf limit {
          tailf:info "Configure bandwidth-limit for this interface";
          type uint8 {
            tailf:info "<10-90>;;enter bandwidth limit for interface as "+
              "percentage";
            range "10..90";
          }
        }

        // interface * / srr-queue bandwidth shape
        container shape {
          tailf:info "Configure shaping on transmit queues";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 1";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 2";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 3";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-65535>;;enter bandwidth weight for queue id 4";
            }
          }
        }

        // interface * / srr-queue bandwidth share
        container share {
          tailf:info "Configure shared bandwidth";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf weight1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 1";
              range "1..255";
            }
          }
          leaf weight2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 2";
              range "1..255";
            }
          }
          leaf weight3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 3";
              range "1..255";
            }
          }
          leaf weight4 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;enter bandwidth weight for queue id 4";
              range "1..255";
            }
          }
        }
      }
    }

    // interface * / queue-set
    leaf queue-set {
      tailf:info "Choose a queue set for this queue";
      type uint8 {
        tailf:info "<1-2>;;the qset to which this port is mapped";
      }
    }

    // interface * / dot1x
    container dot1x {
      tailf:info "Interface Config Commands for IEEE 802.1X";

      // interface * / dot1x pae authenticator
      container pae {
        tailf:info "Set 802.1x interface pae type";
        leaf authenticator {
          tailf:info "Set pae type as Authenticator";
          type empty;
        }
      }

      // interface * / dot1x timeout
      container timeout {
        tailf:info "Various Timeouts";

        // interface * / dot1x timeout quiet-period
        leaf quiet-period {
          tailf:info "QuietPeriod in Seconds";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout tx-period
        leaf tx-period {
          tailf:info "Timeout for supplicant retries";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout supp-period
        leaf supp-period {
          tailf:info "Timeout for supplicant reply";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout ratelimit-period
        leaf ratelimit-period {
          tailf:info "Ratelimit Period in seconds";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }

        // interface * / dot1x timeout held-period
        leaf held-period {
          tailf:info "Timeout for authentication retries";
          type uint16 {
            tailf:info "<1-65535>;;Enter a value between 1 and 65535";
            range "1..65535";
          }
        }
      }
    }

    // interface * / media-type
    leaf media-type {
      tailf:info "Media type";
      tailf:cli-full-command;
      tailf:meta-data "inject-interface-config-duplex" {
        tailf:meta-value "duplex :: duplex :: after :: create";
      }
      tailf:meta-data "inject-interface-config-speed" {
        tailf:meta-value "speed :: speed :: after :: create";
      }
      tailf:ned-data "../duplex" {
        tailf:transaction to;
      }
      tailf:ned-data "../speed" {
        tailf:transaction to;
      }
      type enumeration {
        enum rj45 {
          tailf:info "Copper";
        }
        enum sfp {
          tailf:info "Fiber";
        }
        enum auto-select {
          tailf:info "Auto Select";
        }
        enum gbic {
        }
      }
      default auto-select;
    }

    // interface * / no mdix auto
    // DEP: media-type rj45, [no] mdix auto
    // DEP: [no] mdix auto, media-type sfp
    container mdix {
      tailf:info "Set Media Dependent Interface with Crossover";
      leaf auto {
        tailf:info "Enable automatic MDI crossover detection on this interface";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // interface * / channel-protocol
    leaf channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      type enumeration {
        enum lacp {
          tailf:info "Prepare interface for LACP protocol";
        }
        enum pagp {
          tailf:info "Prepare interface for PAgP protocol";
        }
      }
    }

    // interface * / lacp
    container lacp {
      tailf:info "LACP interface subcommands";

      // interface * / lacp rate
      leaf rate {
        tailf:info "Rate at which the LACP packets are requested to be "+
          "ingressed to this interface";
        type enumeration {
          enum fast {
            tailf:info "Request LACP packets to be ingressed at the 1 "+
            "second rate for this interface";
          }
          enum normal {
            tailf:info "Request LACP packets to be ingressed at the 30 "+
            "second rate once the link is established";
          }
        }
        default normal;
      }

      // interface* / lacp fast-switchover
      leaf fast-switchover {
        tailf:info "Enable LACP fast switchover on this port channel";
        type empty;
      }

      // interface * / lacp min-bundle
      leaf min-bundle {
        tailf:info "LACP minimum number of ports to bundle in this port channel";
        type uint8 {
          tailf:info "<1-8>;;Minimum number of ports to bundle in this "+
            "Port Channel";
          range "1..8";
        }
      }

      // interface * / lacp max-bundle
      leaf max-bundle {
        tailf:info "LACP maximum number of ports to bundle in this "+
          "port channel";
        type uint8 {
          tailf:info "<1-8>;;Max number of ports to bundle in this "+
            "Port Channel";
          range "1..8";
        }
      }
    }

    // interface * / ethernet
    container ethernet {
      tailf:info "Ethernet interface parameters";

      container oam-conf {
        tailf:cli-drop-node-name;
        container oam {
          tailf:info "To enable Ethernet Link OAM";

          // interface * / ethernet oam max-rate
          leaf max-rate {
            tailf:info "Maximum transmission rate(number of OAMPDUs per second)";
            type uint8 {
              tailf:info "<1-10>;;Set the rate in number of packets per second";
              range "1..10";
            }
          }

          // interface * / ethernet oam min-rate
          leaf min-rate {
            tailf:info "Minimum transmission rate(one OAMPDU per number of seconds)";
            type uint8 {
              tailf:info "<1-10>;;Set the rate in number of seconds";
              range "1..10";
            }
          }

          // interface * / ethernet oam mode
          leaf mode {
            tailf:info "Ethernet OAM client mode";
            type enumeration {
              enum "active" {
                tailf:info "Active mode";
              }
              enum "passive" {
                tailf:info "Passive mode";
              }
            }
          }

          // interface * / ethernet oam remote-loopback
          container remote-loopback {
            tailf:info "Ethernet OAM Remote Loopback";

            // interface * / ethernet oam remote-loopback supported
            leaf supported {
              tailf:info "Support remote loopback functionality";
              type empty;
            }
          }

          // interface * / ethernet oam timeout
          leaf timeout {
            tailf:info "Ethernet OAM client link timeout setting";
            type uint8 {
              tailf:info "<2-30>;;Set timeout value in number of seconds";
              range "2..30";
            }
            default 5;
          }

          // interface * / ethernet oam link-monitor
          container link-monitor {
            tailf:info "Ethernet OAM Link Monitor";

            // interface * / no ethernet oam link-monitor supported
            leaf supported {
              tailf:info "Support link monitoring on the interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface * / no ethernet oam link-monitor on
            leaf on {
              tailf:info "Enable link monitoring on the interface";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface * / ethernet oam link-monitor receive-crc
            container receive-crc {
              tailf:info "Received frames with CRC errors in a period";

              // interface * / ethernet oam link-monitor receive-crc window
              leaf window {
                tailf:info "Window size of a polling period";
                type uint16 {
                  tailf:info "<10-1800>;;Set window size in multiple of 100 "+
                    "milliseconds (will be rounded off to second)";
                  range "10..1800";
                }
              }
            }
          }
        }
      }

      // interface * / ethernet oam
      leaf oam {
        tailf:info "Operations, Administration and Maintenance";
        type empty;
      }

      // interface * / ethernet dot1ad
      container dot1ad {
        tailf:info "dot1ad port";
        choice dot1ad-choice {
          leaf nni {
            tailf:info "dot1ad nni port";
            type empty;
          }
          container uni {
            tailf:info "dot1ad uni";
            choice uni-choice {
              container c-port {
                tailf:info "dot1ad uni customer bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
              container s-port {
                tailf:info "dot1ad uni s bridge port";
                tailf:cli-delete-when-empty;
                presence true;
                leaf isolate {
                  tailf:info "split horizon";
                  type empty;
                }
              }
            }
          }
        }
      }

      // interface * / ethernet cfm
      container cfm {
        tailf:info "Ethernet CFM interface commands";

        // interface * / ethernet cfm mip level *
        container mip {
          tailf:info "Maintenance Intermediate Point";
          list level {
            tailf:info "Maintenance Level";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key level;
            leaf level {
              type uint8 {
                tailf:info "<0-7>;;maintenance level number";
                range "0..7";
              }
            }
            leaf-list vlan {
              tailf:info "Specify vlan (range 1-4094)";
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }
        }

        // interface * / ethernet cfm mep domain ? mpid *
        container mep {
          tailf:info "Maintenance End Point";
          list mep-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key mpid;
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }
            leaf domain {
              tailf:info "maintenance domain";
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            // interface * / ethernet cfm mep domain ? mpid * vlan
            leaf vlan {
              tailf:info "Specify vlan (range 1-4094)";
              tailf:cli-optional-in-sequence;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
              }
            }
            // interface * / ethernet cfm mep domain ? mpid * service
            container service {
              tailf:info "Maintenance Association within Domain";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              choice service-choice {
                leaf short-ma-name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;service instance id - short MA name";
                  }
                }
                leaf number {
                  tailf:info "Maintenance Association number value";
                  type uint16 {
                    tailf:info "<0-65535>;;Maintenance Association number";
                  }
                }
              }
            }
          }
        }

        // interface * / no ethernet cfm enable
        leaf enable {
          tailf:info "CFM interface enabling";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / ethernet cfm interface
        // interface * / no ethernet cfm interface
        leaf interface {
          tailf:info "CFM interface enable";
          tailf:cli-boolean-no;
          type boolean;
        }
      }

      // interface * / ethernet uni
      container uni {
        tailf:info "Configure Ether UNI";

        // interface * / ethernet uni id
        leaf id {
          tailf:info "Configure Ether UNI ID";
          type string {
            tailf:info "WORD;;UNI ID of length <1-64>";
            length "0..64";
          }
        }

        // interface * / ethernet uni bundle
        container bundle {
          tailf:info "bundling service without multiplexing";
          tailf:cli-delete-when-empty;
          presence true;
          leaf all-to-one {
            tailf:info "all-to-one bundling service";
            type empty;
          }
        }
      }

      // interface * / ethernet lmi
      container lmi {
        tailf:info "Ethernet LMI interface commands";

        // interface * / ethernet lmi interface
        // interface * / no ethernet lmi interface
        // note: visibility depends on global "ethernet lmi global"
        leaf interface {
          tailf:info "Enable Ethernet LMI on this interface";
          tailf:cli-boolean-no;
          type boolean;
        }
      }
    }

    // interface * / negotiation auto
    // interface * / no negotiation auto
    container negotiation {
      tailf:info "Select autonegotiation mode";
      leaf auto {
        tailf:info "Enable link autonegotiation";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // interface * / synchronous
    container synchronous {
      tailf:info "Synchronous";
      leaf mode {
        tailf:info "Mode";
        type empty;
      }
    }

    // interface * / esmc mode
    container esmc {
      tailf:info "Ethernet Synchronization Messaging Channe";
      container mode {
        tailf:info "ESMC mode";

        // interface * / esmc mode rx
        // interface * / esmc mode tx
        leaf direction {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum rx {
              tailf:info "ESMC receive-only mode";
            }
            enum tx {
              tailf:info "ESMC transmit-only mode";
            }
          }
        }

        // interface * / esmc mode ql-disabled
        leaf ql-disabled {
          tailf:info "QL disabled";
          type empty;
        }
      }
    }

    // interface * / speed
    leaf speed {
      tailf:info "Configure speed operation.";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../negotiation";
      tailf:cli-diff-dependency "../media-type" {
        tailf:cli-trigger-on-set;
      }
      tailf:meta-data "patch-interface-speed";
      type enumeration {
        enum "10" {
          tailf:info "Force 10 Mbps operation";
        }
        enum "100" {
          tailf:info "Force 100 Mbps operation";
        }
        enum "1000" {
          tailf:info "Force 1000 Mbps operation";
        }
        enum "10000" {
          tailf:info "Force 10000 Mbps operation";
        }
        enum "auto" {
          tailf:info "Enable AUTO speed configuration";
        }
        enum "nonegotiate" {
          tailf:info "Do not negotiate speed";
        }
      }
      default auto;
    }

    // interface * / duplex
    leaf duplex {
      tailf:info "Configure duplex operation.";
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../negotiation";
      tailf:cli-diff-dependency "../speed";
      type enumeration {
        enum auto {
          tailf:code-name "duplex_auto";
          tailf:info "Enable AUTO duplex configuration";
        }
        enum full {
          tailf:code-name "duplex_full";
          tailf:info "Force full duplex operation";
        }
        enum half {
          tailf:code-name "duplex_half";
          tailf:info "Force half-duplex operation";
        }
      }
      default auto;
    }

    // interface * / xconnect
    uses xconnect-interface-grouping;

    // interface * / pppoe
    container pppoe {
      tailf:info "pppoe interface subcommands";

      // interface * / pppoe enable
      container enable {
        tailf:info "Enable pppoe";
        presence true;
        leaf group {
          tailf:info "attach a BBA group";
          type union {
            type string {
              tailf:info "WORD;;BBA Group name";
            }
            type enumeration {
              enum global {
                tailf:info "Attach global PPPoE group";
              }
            }
          }
        }
      }

      // interface * / pppoe max-sessions
      leaf max-sessions {
        tailf:info "Maximum PPPOE sessions";
        type uint16 {
          tailf:info "<1-4085>;;Maximum PPPOE sessions";
          range "1..4085";
        }
      }
    }

    // interface * / vlan-id dot1q *
    container vlan-id {
      tailf:info "Process VLAN-encapsulated packets with a specific VLAN ID";
      list dot1q {
        tailf:info "802.1Q VLAN";
        tailf:cli-mode-name "config-if-vlan-id";
        tailf:cli-exit-command "exit-vlan-config" {
          tailf:info "Exit from VLAN configuration mode";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID";
            range "1..4094";
          }
        }
      }
    }

    // interface * / service instance * ethernet
    container service {
      tailf:info "Configure Ether Service";
      list instance {
        tailf:info "Configure Ether Service Instance";
        tailf:cli-mode-name "config-if-srv";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          // dep: before this created, must change below:
          tailf:cli-diff-dependency "../../../service-policy/output" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../service-policy/input" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../cdp/enable" {
            tailf:cli-trigger-on-set;
          }
          tailf:cli-diff-dependency "../../../ip/no-address/address" {
            tailf:cli-trigger-on-set;
          }
          type uint32 {
            tailf:info "<1-4294967295>;;Service Instance Identifier";
            range "1..4294967295";
          }
        }
        leaf trunk {
          tailf:cli-optional-in-sequence;
          tailf:cli-prefix-key;
          type empty;
        }
        leaf ethernet {
          tailf:info "Configure an Ethernet Instance";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf ethernet-evc-name {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:non-strict-leafref {
            path "/ios:ethernet/evc/name";
          }
          type string {
            tailf:info "WORD;;Attach an EVC to the service instance";
          }
        }

        // interface * / service instance * ethernet / description
        leaf "description" {
          tailf:cli-break-sequence-commands;
          tailf:info "Service instance specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this "+
              "service instance";
            length "0..240";
          }
        }

        // interface * / service instance * ethernet / encapsulation
        container encapsulation {
          tailf:info "Configure ethernet frame match criteria";
          choice encapsulation-choice {

            // interface * / service instance * ethernet / encapsulation dot1q
            container dot1q {
              tailf:info "IEEE 802.1Q Virtual LAN or S-VLAN";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              // dep: before this created, must change below:
              tailf:cli-diff-dependency "../untagged" {
                tailf:cli-trigger-on-set;
              }
              uses if-srv-encapsulation-dot1q-grouping;
            }

            // interface * / service instance * ethernet / encapsulation dot1ad
            container dot1ad {
              tailf:info "IEEE 802.1ad VLAN-tagged packets";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf-list id {
                tailf:cli-drop-node-name;
                tailf:cli-replace-all;
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "<1-4094>;;VLAN id";
                  range "1..4094";
                }
              }

              leaf-list dot1q {
                tailf:info "IEEE 802.1Q VLAN-tagged packets";
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
              }
            }

            // interface * / service instance * ethernet / encapsulation untagged
            container untagged {
              tailf:info "Untagged encapsulation";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-delete-when-empty;
              // dep: before this created, must change below:
              tailf:cli-diff-dependency "../dot1q" {
                tailf:cli-trigger-on-set;
              }
              tailf:meta-data "diff-interface-move-encap-untagged-1" {
                //FIXME: test with multiple service instances
                tailf:meta-value "no rewrite ingress tag pop \\d+ symmetric :: before :: encapsulation untagged";
              }
              presence true;
              leaf comma {
                tailf:info "comma";
                tailf:alt-name ",";
                type empty;
              }
              container dot1q {
                tailf:info "IEEE 802.1Q Virtual LAN or S-VLAN";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses if-srv-encapsulation-dot1q-grouping;
              }
            }

            // interface * / service instance * ethernet / encapsulation default
            container "default" {
              tailf:info "catch-all unconfigured encapsulation";
              presence true;
            }
          }
        }

        // interface * / service instance * ethernet / rewrite ingress tag
        container rewrite {
          tailf:info "Configure ethernet rewrite criteria";
          container ingress {
            tailf:info "Ingress Rewrite";
            container tag {
              tailf:info "Configure Rewrite Tag";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-diff-dependency "../../../encapsulation";
              // dep: before this created, must change below:
              //tailf:cli-diff-dependency "../../../xconnect" {
              //tailf:cli-trigger-on-set;
              //}
              choice tag-choice {

                // interface * / service instance * ethernet / rewrite ingress tag pop
                leaf pop {
                  tailf:info "Pop the tag";
                  type enumeration {
                    enum "1" {
                      tailf:info "Pop the outermost tag";
                    }
                    enum "2" {
                      tailf:info "Pop two outermost tags";
                    }
                  }
                }

                // interface * / service instance * ethernet / rewrite ingress tag push
                case push {
                  leaf push {
                    tailf:info "Rewrite Operation of push";
                    type enumeration {
                      enum dot1ad {
                        tailf:info "Push dot1ad tag";
                      }
                      enum dot1q {
                        tailf:info "Push dot1q tag";
                      }
                    }
                  }
                  leaf vlan-id {
                    tailf:cli-drop-node-name;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                }

                // interface * / service instance * ethernet / rewrite ingress tag translate
                case translate {
                  leaf translate {
                    tailf:info "Translate Tag";
                    tailf:cli-incomplete-command;
                    type enumeration {
                      enum "1-to-1" {
                        tailf:info "Translate 1-to-1";
                      }
                      enum "1-to-2" {
                        tailf:info "Translate 1-to-2";
                      }
                      enum "2-to-1" {
                        tailf:info "Translate 2-to-1";
                      }
                      enum "2-to-2" {
                        tailf:info "Translate 2-to-2";
                      }
                    }
                  }
                  leaf dot1ad {
                    tailf:info "Ethertype dot1ad of the translation";
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf dot1q {
                    tailf:info "Ethertype dot1q of the translation";
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf second-dot1q {
                    tailf:info "Second dot1q tag";
                    tailf:cli-optional-in-sequence;
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                  }
                  leaf vlan-type {
                    tailf:info "Vlan protocol type";
                    tailf:cli-optional-in-sequence;
                    type enumeration {
                      enum "0x88A8" {
                        tailf:info "vlan protocol type 0x88A8";
                      }
                      enum "0x9100" {
                        tailf:info "vlan protocol type 0x9100";
                      }
                      enum "0x9200" {
                        tailf:info "vlan protocol type 0x9200";
                      }
                    }
                  }
                }
              }
              leaf mode {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum symmetric {
                    tailf:info "Tag egress packets as specified in encapsulation";
                  }
                }
              }
            }
          }
        }

        // interface * / service instance * ethernet / storm-control
        container storm-control {
          tailf:info "storm configuration";

          // interface * / service instance * ethernet / storm-control broadcast cir
          container broadcast {
            tailf:info "Broadcast address storm control";
            leaf cir {
              tailf:info "Committed Information Rate";
              type string {
                tailf:info "<8000-1000000000>;;Target Bit Rate (biTs per second)";
              }
            }
          }

          // interface * / service instance * ethernet / storm-control multicast cir
          container multicast {
            tailf:info "Multicast address storm control";
            leaf cir {
              tailf:info "Committed Information Rate";
              type string {
                tailf:info "<8000-1000000000>;;Target Bit Rate (biTs per second)";
              }
            }
          }
        }

        // interface * / service instance * ethernet / group
        leaf group {
          tailf:info "Join a service group";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "/ios:service-group";
          type uint16 {
            tailf:info "<1-65532>;;Service group ID number";
            range "1..65532";
          }
        }

        // interface * / service instance * ethernet / errdisable
        container errdisable {
          tailf:info "Configure error disable";
          container recovery {
            tailf:info "enable auto recovery";
            container cause {
              tailf:info "error disable cause";
              leaf mac-security {
                tailf:info "mac-security violation";
                type uint32 {
                  tailf:info "<30-86400>;;timer interval(sec)";
                  range "30..86400";
                }
              }
            }
          }
        }

        // interface * / service instance * ethernet / snmp
        container snmp {
          tailf:info "Modify SNMP service instance parameters";
          container trap {
            tailf:info "Allow a specific SNMP trap";
            leaf link-status {
              tailf:info "Allow SNMP LINKUP and LINKDOWN traps";
              type empty;
            }
          }
          container ifindex {
            tailf:info "Persist ifindex for the service instance";
            leaf persist {
              tailf:info "Enable/Disable ifIndex persistence";
              type empty;
            }
          }
        }

        // interface * / service instance * ethernet / shutdown
        leaf shutdown {
          tailf:info "Take the Service Instance out of Service";
          type empty;
        }

        // interface * / service instance * ethernet / mac
        container mac {
          tailf:info "Commands for MAC Address-based features";

          // interface * / service instance * ethernet / mac security
          container security {
            tailf:info "MAC Security commands";
            tailf:cli-display-separated;
            tailf:cli-delete-when-empty;
            presence true;
            // interface * / service instance * ethernet /
            // .. mac security address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "operation mac-address";
              leaf operation {
                type enumeration {
                  enum deny {
                    tailf:info "Specify an address that must not be learnt";
                  }
                  enum permit {
                    tailf:info "Specify an address to statically configure "+
                    "in the MAC table";
                  }
                }
              }
              leaf mac-address {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit MAC Address to "+
                    "deny/permit";
                }
              }
            }
            // interface * / service instance * ethernet / mac security maximum
            container maximum {
              tailf:info "Configure an upper bound";
              leaf addresses {
                tailf:info "Maximum addresses that can be learnt on "+
                  "this service instance";
                type uint16 {
                  tailf:info "<1-1000>;;Address count";
                  range "1..1000";
                }
              }
            }
            // interface * / service instance * ethernet /
            // .. mac security violation
            leaf violation {
              tailf:info "Configure the response when a MAC security "+
                "policy is violated";
              tailf:cli-full-command;
              type enumeration {
                enum protect {
                  tailf:info "Protect mode - don't report violations, "+
                  "drop violating frames";
                }
                enum restrict {
                  tailf:info "Restrict mode - report violations, "+
                  "drop violating frames";
                }
              }
            }
          }

          // interface * / service instance * ethernet / mac static
          container static {
            tailf:info "static MAC address";
            // interface * / service instance * ethernet / mac static address *
            list address {
              tailf:info "MAC Address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key mac-addr;
              leaf mac-addr {
                type string {
                  tailf:info "H.H.H;;Specify the 48-bit Static MAC Address";
                }
              }
            }
          }

          // interface * / service instance * ethernet / mac access-group *
          list access-group {
            tailf:info "Specify access control for packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key direction;
            leaf direction {
              type enumeration {
                enum in {
                  tailf:info "Apply to Ingress";
                }
                enum out {
                  tailf:info "Apply to Egress";
                }
              }
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type string {
                tailf:info "WORD;;ACL name";
              }
            }
          }
        }

        // interface * / service instance * ethernet / l2protocol
        container l2protocol {
          tailf:info "Configure l2 control protocol processing";

          // interface * / service instance * ethernet / l2protocol peer
          container peer {
            tailf:info "peer L2 control protocol packets as data";
            tailf:cli-delete-when-empty;
            presence true;
            leaf-list protocol {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type l2protocol-type;
            }
          }

          // interface * / service instance * ethernet / l2protocol forward
          container forward {
            tailf:info "forward L2 control protocol packets as data";
            tailf:cli-delete-when-empty;
            presence true;
            leaf-list protocol {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type l2protocol-type;
            }
          }

          // interface * / service instance * ethernet / l2protocol tunnel
          container tunnel {
            tailf:info "tunnel L2 control protocol packets as data";
            tailf:cli-delete-when-empty;
            presence true;
            leaf-list protocol {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type l2protocol-type;
            }
          }
        }

        // interface * / service instance * ethernet / bridge-domain
        container bridge-domain {
          tailf:info "Bridge-domain";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-diff-dependency "../encapsulation";
          // bridge-domain from-encapsulation
          leaf from-encapsulation {
            tailf:info "Derive bridge domains from encapsulation vlan list,";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          leaf bridge-id {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "/ios:bridge-domain/bridge-domain-list/id";
            }
            type uint16 {
              tailf:info "<1-16384>;;Bridge-domain number";
              range "1..16384";
            }
          }
          container split-horizon {
            tailf:info "Configure this port as a member of a split "+
              "horizon group";
            tailf:cli-flatten-container;
            leaf group {
              tailf:info "Split-horizon group";
              type uint8 {
                tailf:info "<0-2>;;Split-horizon group number";
                range "0..2";
              }
            }
          }
        }

        // interface * / service instance * ethernet / service-policy
        container service-policy {
          tailf:info "Attach a policy-map to an EFP";
          list "input" {
            tailf:info "service policy input";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
              type string {
                tailf:info "WORD;;input Policy-map name";
              }
            }
          }
          list "output" {
            tailf:info "service policy output";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key name;
            leaf name {
              tailf:non-strict-leafref {
                path "/ios:policy-map/name";
              }
              type string {
                tailf:info "WORD;;output Policy-map name";
              }
            }
          }
        }

        // interface * / service instance * ethernet / xconnect
        uses xconnect-grouping {
          refine "xconnect-choice/xconnect/xconnect" {
            tailf:cli-diff-dependency "../encapsulation";
          }
          refine "xconnect-choice/xconnect/xconnect/mtu" {
            tailf:cli-diff-dependency "../../../../mtu";
          }
        }

        // interface * / service instance * ethernet / cfm
        container cfm {
          tailf:info "Ethernet CFM EFP subcommands";

          // interface * / service instance * ethernet / cfm mip level
          container mip {
            leaf level {
              type uint8 {
                tailf:info "<0-7>;;maintenance level number";
                range "0..7";
              }
            }
          }

          // interface * / service instance * ethernet / cfm mep
          container mep {
            tailf:info "Maintenance End Point";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-if-srv-ecfm-mep";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf domain {
              tailf:info "Configure a domain for this mep";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "/ios:ethernet/cfm/domain";
              type string {
                tailf:info "WORD;;maintenance domain name";
              }
            }
            leaf mpid {
              tailf:info "Maintenance End Point Identifier";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;Maintenance End Point Identifier";
                range "1..8191";
              }
            }

            // interface * / service instance * ethernet / cfm mep /
            // .. continuity-check
            container continuity-check {
              tailf:info "Enable Continuity Check for this local MEP";
              tailf:cli-break-sequence-commands;
              container static {
                tailf:info "Verify MEP in received CCM is valid";
                leaf rmep {
                  tailf:info "MEP defined using rmep mpid";
                  type empty;
                }
              }
            }

            // interface * / service instance * ethernet / cfm mep / rmep mpid
            container rmep {
              tailf:info "Static Remote MEP associated with this DOWN MEP";
              leaf mpid {
                tailf:info "Maintenance End Point Identifier";
                type uint16 {
                  tailf:info "<1-8191>;;Identifier value";
                  range "1..8191";
                }
              }
            }

            // interface * / service instance * ethernet / cfm mep / cos
            leaf cos {
              tailf:info "Specify Class of Service sent in CFM mssages for "+
                "EFP MEP";
              type uint8 {
                tailf:info "<0-7>;;CoS value";
                range "0..7";
              }
            }
          }
        }

        // interface * / service instance * ethernet / ethernet
        container ethernet-if-srv {
          tailf:cli-drop-node-name;
          container ethernet {
            tailf:info "ethernet";

            // interface * / service instance * ethernet / ethernet lmi
            container lmi {
              tailf:info "Configure ether lmi parameters";
              container ce-vlan {
                tailf:info "Configure ether lmi customer vlans";
                leaf-list map {
                  tailf:info "Configure ether lmi ce-vlan/evc map";
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  type union {
                    type uint16 {
                      tailf:info "<1-4094>;;VLAN id";
                      range "1..4094";
                    }
                    type enumeration {
                      enum "default" {
                        tailf:info "Default EFP";
                      }
                      enum untagged {
                        tailf:info "Untagged frames";
                      }
                    }
                  }
                }
              }
            }

            // interface * / service instance * ethernet / ethernet loopback
            container loopback {
              tailf:info "Ethernet Dataplane Loopback";
              container permit {
                tailf:info "Allow data plane loopback to be activated";
                leaf external {
                  tailf:info "Allow to loopback the traffic from the wire";
                  type empty;
                }
                leaf internal {
                  tailf:info "Allow to loopback the traffic from the relay";
                  type empty;
                }
              }
            }
          }
        }
      }
    }

    // interface * / channel-group
    container channel-group {
      tailf:info "Add this interface to an Etherchannel group";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-diff-dependency "../../mls/qos/trust";
        tailf:cli-diff-dependency "../../mls" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../ip" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../ipv6" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../service-policy" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../mtu" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../storm-control" {
          tailf:cli-trigger-on-set;
        }
        tailf:cli-diff-dependency "../../port-type";
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }

    // interface * / soak link notification
    container soak {
      tailf:info "Soak hardware link notification";
      container link {
        tailf:info "link";
        leaf "notification" {
          tailf:info "notification";
          type uint16 {
            tailf:info "<0-300>;;duration";
            range "0..300";
          }
        }
      }
    }

  } // interface-ethernet-grouping0

  grouping interface-ethernet-grouping {
    uses interface-ethernet-grouping0 {
      refine "service/instance/service-policy" {
        tailf:cli-diff-dependency "../../../../../policy-map";
      }
      refine "service/instance/bridge-domain/bridge-id" {
        tailf:cli-diff-dependency "../../../../../../vlan/vlan-list";
      }
      refine "channel-group/number" {
        tailf:cli-diff-dependency "../../../../interface/Port-channel";
      }
    }
  }

  grouping sub-interface-ethernet-grouping {
    uses interface-ethernet-grouping0 {
      refine "service/instance/service-policy" {
        tailf:cli-diff-dependency "../../../../../../policy-map";
      }
      refine "service/instance/bridge-domain/bridge-id" {
        tailf:cli-diff-dependency "../../../../../../../vlan/vlan-list";
      }
      refine "channel-group/number" {
        tailf:cli-diff-dependency "../../../../../interface/Port-channel";
      }
    }
  }

  grouping interface-ethernet-switch-grouping {
    uses interface-ethernet-grouping {
      // dep: before switchport deleted, must delete this
      refine "service/instance" {
        tailf:cli-diff-dependency "../../switchport";
      }
      refine "channel-group/number" {
        tailf:cli-diff-dependency "../../switchport";
      }
    }
  }

  grouping sub-interface-ethernet-switch-grouping {
    uses sub-interface-ethernet-grouping {
      // dep: before switchport deleted, must delete this
      refine "service/instance" {
        tailf:cli-diff-dependency "../../switchport";
      }
      refine "channel-group/number" {
        tailf:cli-diff-dependency "../../switchport";
      }
    }
  }

  // interface-ethernet-post-grouping0
  grouping interface-ethernet-post-grouping0 {

    // interface * / bridge-group *
    leaf bridge-group {
      tailf:info "Transparent bridging interface parameters";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-255>;;Assign an interface to a Bridge Group.";
        range "1..255";
      }
    }

    // interface * / bridge-group * / ?
    container bridge-group-conf {
      tailf:cli-drop-node-name;
      when "../bridge-group" {
        tailf:dependency "../bridge-group";
      }
      list bridge-group {
        tailf:info "Transparent bridging interface parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        max-elements 1;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Assign an interface to a Bridge Group.";
            range "1..255";
          }
        }

        // interface * / bridge-group * / subscriber-loop-control
        leaf subscriber-loop-control {
          tailf:info "Configure subscriber loop control";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / bridge-group * / block-unknown-source
        leaf block-unknown-source {
          tailf:info "block traffic which come from unknown source MAC address";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / bridge-group * / no source-learning
        leaf source-learning {
          tailf:info "learn source MAC address";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / bridge-group * / no unicast-flooding
        leaf unicast-flooding {
          tailf:info "flood packets with unknown unicast destination MAC "+
            "addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / bridge-group * / spanning-disabled
        leaf spanning-disabled {
          tailf:info "Disable spanning tree on a bridge group";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // interface * / vrrp *
    list vrrp {
      tailf:info "VRRP Interface configuration commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Group number";
          range "1..255";
        }
      }

      // interface * / vrrp * authentication
      container authentication {
        tailf:info "Authentication";
        choice auth {
          leaf word {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "md5|text";
            type string {
              tailf:info "WORD;;Plain text authentication string";
            }
          }
          container md5 {
            tailf:info "Use MD5 authentication";
            leaf key-chain {
              tailf:info "Set key chain";
              type string {
                tailf:info "WORD;;Name of key-chain";
              }
            }

            // interface * / vrrp * authentication md5 key-string
            container key-string {
              tailf:info "Set key string";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping;
              leaf timeout {
                tailf:info "Set timeout";
                type uint16 {
                  tailf:info "<0-32767>;;Timeout until only accepting "
                    +"new key (seconds)";
                  range "0..32767";
                }
              }
            }
          }
          leaf text {
            tailf:info "Plain text authentication";
            type string {
              tailf:info "WORD;;Plain text authentication string "
                +"(8 chars max)";
            }
          }
        }
      }

      uses interface-vrrp-grouping;

      // interface * / vrrp * ip
      container ip {
        tailf:info "Enable Virtual Router Redundancy Protocol (VRRP) for IP";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;VRRP group IP address";
          }
        }
        leaf secondary {
          tailf:info "Specify an additional VRRP address for this group";
          type empty;
        }
      }
    }

    // interface * / vrrp * address-family ipv4
    // interface * / vrrp * address-family ipv6
    container vrrv3p-v3 {
      when "/ios:fhrp/version/vrrp = 'v3'" {
        tailf:dependency "/ios:fhrp/version/vrrp";
      }
      tailf:cli-drop-node-name;
      list vrrp {
        tailf:cli-mode-name "config-if-vrrp";
        tailf:cli-full-command;
        tailf:cli-exit-command "exit-vrrp" {
          tailf:info "Exit from VRRP group configuration mode";
        }
        key "id address-family";
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Group number";
            range "1..255";
          }
        }
        leaf address-family {
          tailf:cli-expose-key-name;
          tailf:info "Address family of the group";
          type enumeration {
            enum ipv4 {
              tailf:info "ipv4 Address family";
            }
            enum ipv6 {
              tailf:info "ipv6 Address family";
            }
          }
        }

        uses interface-vrrp-grouping;

        // interface * / vrrp * address-family / address
        container address {
          tailf:info "IPv4 address config";

          // interface * / vrrp * address-family / address ? primary
          list primary-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            max-elements 1;
            key address;
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 address";
                }
              }
            }
            leaf primary {
              tailf:info "Primary Address";
              type empty;
            }
          }

          // interface * / vrrp * address-family / address * secondary
          list secondary-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key address;
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
                type ios:ipv6-prefix {
                  tailf:info "X:X:X:X::X/<0-128>;;IPv6 address and prefix";
                }
              }
            }
            leaf secondary {
              tailf:info "Secondary Address";
              type empty;
            }
          }
        }
      }
    }

    // interface * / vrrs
    container vrrs {
      tailf:info "VRRS Interface configuration commands";

      // interface * / vrrs pathway *
      list pathway {
        tailf:info "Configure a VRRS pathway";
        tailf:cli-mode-name "config-if-vrrs-pw";
        tailf:cli-exit-command "exit-vrrs-pw" {
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the VRRS tag to associate with pathway";
          }
        }

        // interface * / vrrs pathway * / description
        uses description-grouping;

        // interface * / vrrs pathway * / address *
        list address {
          tailf:info "IPv4/IPv6 Address configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key address;
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 link-local address";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 address and prefix";
              }
            }
          }
        }
      }
    }
  } // interface-ethernet-post-grouping0

  grouping interface-ethernet-post-grouping {
    uses interface-ethernet-post-grouping0 {
      refine "vrrv3p-v3" {
        tailf:cli-diff-dependency "../../../fhrp/version/vrrp";
      }
    }
  }

  grouping sub-interface-ethernet-post-grouping {
    uses interface-ethernet-post-grouping0 {
      refine "vrrv3p-v3" {
        tailf:cli-diff-dependency "../../../../fhrp/version/vrrp";
      }
    }
  }

  // interface-pointtopoint-grouping
  grouping interface-pointtopoint-grouping {

    // interface * / encapsulation
    container encapsulation-pointtopoint {
      tailf:cli-drop-node-name;
      container encapsulation {
        tailf:info "Set encapsulation type for an interface";

        // interface * / encapsulation isl
        container isl {
          tailf:info "Inter Switch Link - Virtual LAN encapsulation";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf vlan-id {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4095>;;Virtual LAN Identifier.";
              range "1..4095";
            }
          }
        }

        // interface * / encapsulation ppp
        container ppp {
          tailf:info "Point-to-Point protocol";
          presence true;
        }

        // interface * / encapsulation slip
        container slip {
          tailf:info "Serial Line IP";
          presence true;
        }

        // interface * / encapsulation frame-relay
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            tailf:cli-full-command;
            type empty;
          }
          leaf MFR {
            tailf:info "Multilink Frame Relay bundle interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "/ios:interface/MFR/name";
            }
            type uint32 {
              tailf:info "<0-2147483647>;;MFR interface number";
            }
          }
        }

        // interface * / encapsulation hdlc
        container hdlc {
          tailf:cli-delete-when-empty;
          presence true;
        }
      }
    }

    // interface * / dialer
    container dialer {
      tailf:info "Dial-on-demand routing (DDR) commands";

      // interface * / dialer in-band
      container in-band {
        tailf:info "Set v.25bis dialing for interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf parity {
          tailf:cli-drop-node-name;
          type enumeration {
            enum no-parity {
              tailf:info "No parity";
            }
            enum odd-parity {
              tailf:info "Odd parity";
            }
          }
        }
      }

      // interface * / dialer idle-timeout
      container idle-timeout {
        tailf:info "Specify idle timeout before disconnecting line";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483>;;Idle timeout before disconnecting a call";
          }
        }
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum either {
              tailf:info "Reset idle timer based on both inbound and outbound "+
              "traffic";
            }
            enum inbound {
              tailf:info "Reset idle timer based on inbound traffic only";
            }
          }
        }
      }

      // interface * / dialer enable-timeout
      leaf enable-timeout {
        tailf:info "Set length of time an interface stays down before it is "+
          "available for dialing";
        type uint32 {
          tailf:info "<1-2147483>;;Enable timeout in seconds";
          range "1..2147483";
        }
      }

      // interface * / dialer string
      leaf "string" {
        tailf:info "Specify telephone number to be passed to DCE device";
        type string {
          tailf:info "WORD;;Dialer string (quote strings containing #)";
        }
      }

      // interface * / dialer pool
      leaf pool {
        tailf:info "Specify dialer pool to be used";
        type uint8 {
          tailf:info "<1-255>;;Dialer pool number";
          range "1..8";
        }
      }

      // interface * / dialer map
      container map {
        tailf:info "Define multiple dial-on-demand numbers";

        // interface * / dialer map ip *
        list ip {
          tailf:info "IP";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Protocol specific address";
            }
          }

          // interface * / dialer map ip * name
          leaf name {
            tailf:info "Map to a host";
            type string {
              tailf:info "WORD;;Hostname to map";
            }
          }

          // interface * / dialer map ip * class
          leaf class {
            tailf:info "dialer map class";
            type string {
              tailf:info "WORD;;name of dialer map class";
            }
          }
        }
      }

      // interface * / dialer watch-group
      leaf watch-group {
        tailf:info "Assign interface to dialer-watch-list";
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
        tailf:non-strict-leafref {
          path "/ios:dialer/watch-list/id";
        }
      }
    }

    // interface * / dialer-group
    leaf dialer-group {
      tailf:info "Assign interface to dialer-list";
      type uint8 {
        tailf:info "<1-128>;;Dialer list number";
        range "1..128";
      }
    }

    // interface * / ppp
    container ppp {
      tailf:info "Point-to-Point Protocol";

      // interface * / ppp mtu adaptive
      container mtu {
        tailf:info "PPP MTU configuration";
        leaf adaptive {
          tailf:info "Adapt MTU to peer's MRU";
          tailf:cli-diff-dependency "../../../dialer";
          type empty;
        }
      }

      // interface * / ppp pcf local
      container pfc {
        tailf:info "Options for Protocol Field Compression";
        leaf local {
          tailf:info "Specify use of PFC option in outbound Config-Requests";
          type enumeration {
            enum forbid {
              tailf:info "Do not include PFC option in our Config-Requests"+
              ", ever";
            }
            enum request {
              tailf:info "Include PFC option in our Config-Requests";
            }
          }
        }
      }

      // interface * / ppp acfc
      container acfc {
        tailf:info "Options for HDLC Address & Control Field Compression";

        // interface * / ppp acfc local
        leaf local {
          tailf:info "Specify use of ACFC option in outbound Config-Requests";
          type enumeration {
            enum forbid {
              tailf:info "Do not include ACFC option in our Config-Requests"+
              ", ever";
            }
            enum request {
              tailf:info "Include ACFC option in our Config-Requests";
            }
          }
        }

        // interface * / ppp acfc remote
        leaf remote {
          tailf:info "Specify handling of ACFC option in inbound "+
            "Config-Requests";
          type enumeration {
            enum apply {
              tailf:info "Do ACFC if peer indicates it can receive such frames";
            }
            enum ignore {
              tailf:info "Accept ACFC option, but do not apply ACFC on "+
              "outbound frames";
            }
            enum reject {
              tailf:info "Explicitly reject the ACFC option and disallow ACFC";
            }
          }
        }
      }

      // interface * / ppp accounting
      leaf accounting {
        tailf:info "Set PPP network accounting method";
        type union {
          type string {
            tailf:info "WORD;;Named accounting list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default accounting list.";
            }
          }
        }
      }

      // interface * / ppp authentication
      container authentication {
        tailf:info "Set PPP link authentication method";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf method {
          tailf:cli-drop-node-name;
          type enumeration {
            enum chap {
              tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
            }
            enum eap {
              tailf:info "Extensible Authentication Protocol (EAP)";
            }
            enum ms-chap {
              tailf:info "Microsoft Challenge Handshake Authentication "
                +"Protocol (MS-CHAP)";
            }
            enum ms-chap-v2 {
              tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
            }
            enum pap {
              tailf:info "Password Authentication Protocol (PAP)";
            }
          }
        }
        leaf list-name {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Use an authentication list with this name";
          }
          tailf:cli-disallow-value "(callback)|(callin)|(callout)|(default)|"
            +"(eap)|(ms-chap)|(ms-chap-v2)|(one-time)|(optional)|(pap)";
        }
        leaf chap {
          when "not(../method = 'chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Challenge Handshake Authentication Protocol (CHAP)";
          type empty;
        }
        leaf callback {
          tailf:info "Authenticate remote on callback only";
          type empty;
        }
        leaf callin {
          tailf:info "Authenticate remote on incoming call only";
          type empty;
        }
        leaf callout {
          tailf:info "Authenticate remote on outgoing call only";
          type empty;
        }
        leaf "default" {
          tailf:info "Use the default authentication list";
          type empty;
        }
        leaf eap {
          when "not(../method = 'eap')" {
            tailf:dependency "../method";
          }
          tailf:info "Extensible Authentication Protocol (EAP)";
          type empty;
        }
        leaf ms-chap {
          when "not(../method = 'ms-chap')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft Challenge Handshake Authentication Protocol ("
            +"MS-CHAP)";
          type empty;
        }
        leaf ms-chap-v2 {
          when "not(../method = 'ms-chap-v2')" {
            tailf:dependency "../method";
          }
          tailf:info "Microsoft CHAP Version 2 (MS-CHAP-V2)";
          type empty;
        }
        leaf one-time {
          tailf:info "Allow use of username*OTP for one-time passwords";
          type empty;
        }
        leaf optional {
          tailf:info "Allow peer to refuse to authenticate";
          type empty;
        }
        leaf pap {
          when "not(../method = 'pap')" {
            tailf:dependency "../method";
          }
          tailf:info "Password Authentication Protocol (PAP)";
          type empty;
        }
      }

      // interface * / ppp authorization
      leaf authorization {
        tailf:info "Set PPP network authorization method";
        type union {
          type string {
            tailf:info "WORD;;Named authorization list.";
          }
          type enumeration {
            enum "default" {
              tailf:info "The default authorization list.";
            }
          }
        }
      }

      // interface * / ppp chap
      container chap {
        tailf:info "Set CHAP authentication parameters";

        // interface * / ppp chap hostname
        leaf hostname {
          tailf:info "Set alternate CHAP hostname";
          type string {
            tailf:info "WORD;;Alternate CHAP hostname";
          }
        }

        // interface * / ppp chap password
        container password {
          tailf:info "Set default CHAP password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }
      }

      // interface * / ppp ipcp
      container ipcp {
        tailf:info "Set IPCP negotiation options";

        // interface * / ppp ipcp address
        container address {
          tailf:info "Additional ipcp address options";
          tailf:cli-compact-syntax;

          // interface * / ppp ipcp address accept
          leaf accept {
            tailf:info "Accept any non zero IP address from our peer";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp ipcp address proxy
          leaf proxy {
            tailf:info "Peer proxy IP address (XCONNECT)";
            tailf:cli-full-command;
            type inet:ipv4-address;
          }

          // interface * / ppp ipcp address request
          leaf request {
            tailf:info "Request any address from our peer";
            tailf:cli-full-command;
            type enumeration {
              enum "ignore" {
                tailf:info "Ignore negotiated address";
              }
            }
          }

          // interface * / ppp ipcp address required
          leaf required {
            tailf:info "Disconnect peers with no IP address negotiated";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp ipcp address unique
          leaf unique {
            tailf:info "Disconnect if peer IP address already in use";
            tailf:cli-full-command;
            type empty;
          }
        }

        // interface * / ppp ipcp dns
        container dns {
          tailf:info "Specify DNS negotiation options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice dns-choice {
            case dns-address {
              leaf primary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Primary DNS IP address";
                }
              }
              leaf secondary {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Secondary DNS IP address";
                }
              }
            }
            // interface * / ppp ipcp dns request
            container request {
              tailf:info "Request server addresses from peer";
              tailf:cli-delete-when-empty;
              presence true;
              leaf accept {
                tailf:info "Accept any non zero DNS address";
                type empty;
              }
            }
          }
        }
      }

      // interface * / ppp multilink
      container multilink {
        tailf:info "Make interface multilink capable";
        tailf:cli-display-separated;
        presence true;

        // interface * / ppp multilink interleave
        leaf interleave {
          tailf:info "Allow interleaving of small packets with fragments";
          type empty;
        }

        // interface * / ppp multilink links
        container links {
          tailf:info "Specify the limits on the number of links in a bundle";
          container minimum {
            tailf:info "Minimum number of links desired in the bundle";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf minimum-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Specify minimum desired number of "+
                  "links in a bundle";
              }
            }
            leaf mandatory {
              tailf:info "Disable network layer until minimum number of "+
                "links is reach";
              type empty;
            }
          }
        }

        // interface * / ppp multilink group
        leaf group {
          tailf:info "Put interface in a multilink bundle";
          type uint32 {
            tailf:info "<1-2147483647>;;Multilink group number";
            range "1..2147483647";
          }
        }

        // interface * / ppp multilink fragment
        container fragment {
          tailf:info "Specify fragmentation parameters";

          // interface * / ppp multilink fragment disable
          leaf disable {
            tailf:info "Suppress multilink fragmentation when possible";
            tailf:cli-full-command;
            type empty;
          }

          // interface * / ppp multilink fragment size
          leaf size {
            tailf:info "Specify the maximum size of a multilink fragment";
            type uint16 {
              tailf:info "<42-65535>;;Maximum fragment size in bytes";
              range "42..65535";
            }
          }

          // interface * / ppp multilink fragment delay
          container delay {
            tailf:info "Specify the maximum delay for each fragment";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<0-1000>;;Delay in milliseconds";
                range "0..1000";
              }
            }
            leaf additional-delay-value {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-999>;;Additional delay in microseconds";
                range "1..999";
              }
            }
          }
        }

        // interface * / no ppp multilink fragmentation
        leaf fragmentation {
          tailf:info "Enable/Disable multilink fragmentation";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // interface * / ppp multilink queue depth
        container queue {
          tailf:info "Specify link queuing parameters";
          container depth {
            tailf:info "Specify maximum depth for link transmit queues";
            leaf fifo {
              tailf:info "Set max depth for link queues when bundle "+
                "has FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
            leaf qos {
              tailf:info "Set max depth for link queues when bundle has "+
                "non-FIFO queuing";
              type uint8 {
                tailf:info "<2-255>;;Max queue depth for link";
                range "2..255";
              }
            }
          }
        }

        // interface * / ppp multilink min-links
        container min-links {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf links {
            tailf:cli-drop-node-name;
            type uint8;
          }
          leaf "mandatory" {
            type empty;
          }
        }
      }
    }

    // interface * / multilink-group
    leaf multilink-group {
      tailf:info "Put interface in a multilink bundle";
      type uint32 {
        tailf:info "<1-2147483647>;;Multilink group number";
        range "1..2147483647";
      }
    }

    // interface * / physical-layer
    leaf physical-layer {
      tailf:info "Configure sync or async physical layer on serial interface";
      type enumeration {
        enum async {
          tailf:info "Configure asynchronous physical layer on serial "+
          "interface";
        }
        enum sync {
          tailf:info "Configure synchronous physical layer on serial "+
          "interface";
        }
      }
    }

    // interface * / async
    container async {
      tailf:info "Async interface parameters";
      container mode {
        tailf:info "Specify line mode (interactive or dedicated "+
          "interface use)";
        leaf dedicated {
          tailf:info "Line is dedicated as an async interface";
          type empty;
        }
        leaf interactive {
          tailf:info "Line may be switched between interactive use and "+
            "async interface";
          type empty;
        }
      }
    }

    // interface * / pulse-time
    container pulse-time {
      tailf:info "Force DTR low during resets";
      choice pulse-time-choice {
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-60>;;DTR low time in seconds";
            range "0..60";
          }
        }
        leaf msec {
          tailf:info "millisecond (resolution)";
          type uint16 {
            tailf:info "<1-59999>;;DTR low time in milliseconds";
            range "1..59999";
          }
        }
      }
    }

    // interface * / serial restart-delay
    container serial {
      tailf:info "serial interface commands";
      container restart-delay {
        tailf:info "Configure serial interface restart-delay";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-900>;;Restart delay (seconds)";
            range "0..900";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Restart delay (milliseconds)";
            range "0..999";
          }
        }
      }
    }
  }


  // interface-switch-grouping0
  grouping interface-switch-grouping0 {

    // interface * / switchport
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-display-separated;
      tailf:cli-recursive-delete;
      tailf:cli-show-no;
      presence true;
      tailf:callpoint interface-switchport-hook { tailf:set-hook node; }
      // YANG order:
      //  no service-policy
      //  ip route-cache
      //  switchport
      //  ip address
      //  ip ospf

      // LAYER 3 config (switchport not set):
      tailf:cli-diff-dependency "../ip/address" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../ip/no-address/address" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../ip/redirects" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../ip/ospf" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../standby" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../service-policy/output" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../service-policy/input" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../udld" {
        tailf:cli-trigger-on-set;
      }
      tailf:meta-data "inject-interface-config-sp-input" {
        tailf:meta-value "service-policy/input :: service-policy input :: after :: any";
      }
      tailf:meta-data "inject-interface-config-sp-output" {
        tailf:meta-value "service-policy/output :: service-policy output :: after :: any";
      }
      tailf:meta-data "inject-interface-config-lacp-rate" {
        tailf:meta-value "lacp/rate :: lacp rate :: after :: any";
      }
      tailf:ned-data "../service-policy" {
        tailf:transaction to;
      }
      tailf:ned-data "../lacp/rate" {
        tailf:transaction to;
      }

      // interface * / switchport mode
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {

          // interface * / switchport mode access
          container access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            presence true;
          }

          // interface * / switchport mode dot1q-tunnel
          container dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            presence true;
          }

          // interface * / switchport mode dynamic
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access "+
              "or trunk mode";
            // dep: before this created, must show changes to below:
            tailf:cli-diff-dependency "../../nonegotiate" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../../port-security" {
              tailf:cli-trigger-on-set;
            }
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                "to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter "+
                "to DESIRABLE";
              }
            }
          }

          // interface * / switchport mode trunk
          container trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            tailf:cli-diff-dependency "../../trunk/encapsulation" {
              tailf:cli-trigger-on-set;
            }
            presence true;
          }

          // interface * / switchport mode private-vlan
          container private-vlan {
            tailf:info "Set private-vlan mode";
            choice private-vlan-choice {
              leaf host {
                tailf:info "Set the mode to private-vlan host";
                type empty;
              }
              leaf promiscuous {
                tailf:info "Set the mode to private-vlan promiscuous";
                type empty;
              }
              container trunk {
                tailf:info "Set the mode to private-vlan trunk";
                presence true;
              }
            }
          }
        }
      }

      // interface * / switchport trunk
      container trunk {
        tailf:info "Set trunking characteristics of the interface";

        // interface * / switchport trunk encapsulation
        leaf encapsulation {
          tailf:info "Set encapsulation format on trunk port";
          // dep: before this created, must change mode dynamic'
          tailf:cli-diff-dependency "../../mode/dynamic" {
            tailf:cli-trigger-on-set;
          }
          type enumeration {
            enum "dot1q" {
              tailf:info "Interface uses only 802.1q trunking encapsulation "+
              "when trunking";
            }
            enum "isl" {
              tailf:info "Interface uses only ISL trunking encapsulation "+
              "when trunking";
            }
            enum "negotiate" {
              tailf:info "Device will negotiate trunking encapsulation "+
              "with peer on interface";
            }
          }
          default negotiate;
        }

        // interface * / switchport trunk native
        container native {
          tailf:info "Set trunking native characteristics when interface "+
            "is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                  +"this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }

        // interface * / switchport trunk allowed
        // Note: Java code makes a single entry of all 'add' entries.
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface "+
            "is in trunking mode";

          // interface * / switchport trunk allowed vlan
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            tailf:cli-delete-when-empty;
            tailf:cli-display-separated;
            tailf:cli-incomplete-command;
            presence true;
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                tailf:cli-diff-dependency "../../../../mode";
                tailf:cli-diff-dependency "../../vlan";
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                  range "1..4094";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }

        // interface * / switchport trunk pruning vlan
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in "+
            "trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in "+
              "trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-drop-node-name;
                tailf:cli-range-list-syntax;
                tailf:cli-replace-all;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs "
                    +"when this port is in trunking mode";
                  range "1..4094";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }

      // interface * / switchport autostate
      container autostate {
        tailf:info "Include or exclude this port from vlan link up calculation";
        leaf exclude {
          tailf:info "Exclude this port from vlan link up calculation";
          type empty;
        }
      }

      // interface * / switchport private-vlan
      container private-vlan {
        tailf:info "Set the private VLAN configuration";

        // interface * / switchport private-vlan trunk
        container trunk {
          tailf:info "Set the private vlan trunking configuration";

          // interface * / switchport private-vlan trunk native vlan
          container native {
            tailf:info "Set the private vlan trunking native configuration";
            leaf vlan {
              tailf:info "Set native VLAN configuration";
              type union {
                type enumeration {
                  enum "tag" {
                    tailf:info "Set native VLAN tagging state";
                  }
                }
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID of the native VLAN when "
                    +"this port is in trunking mode";
                  range "1..4094";
                }
              }
            }
          }

          // interface * / switchport private-vlan trunk allowed vlan
          // Note: Java code makes a single entry of all 'add' entries.
          container allowed {
            tailf:info "Set allowed VLAN characteristics when interface "+
              "is in private-vlan trunking mode";
            container vlan {
              tailf:info "Set allowed VLANs when interface is in "+
                "private-vlan trunking mode";
              choice vlan-choice {
                leaf-list vlans {
                  tailf:cli-replace-all;
                  tailf:cli-range-list-syntax;
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "WORD;;VLAN IDs of the allowed VLANs when "+
                      "interface is in private-vlan trunking mode";
                    range "1..4094";
                  }
                }
                leaf none {
                  tailf:info "no VLANs";
                  type empty;
                }
              }
            }
          }
        }

        // interface * / switchport private-vlan association
        container association {
          tailf:info "Set the private VLAN association";

          // interface * / switchport private-vlan association trunk *
          list trunk {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key primary-vlan-id;
            leaf primary-vlan-id {
              type uint16 {
                tailf:info "<2-4094>;;Primary VLAN ID of the private VLAN "+
                  "trunk association";
                range "2..4094";
              }
            }
            leaf secondary-vlan-id {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<2-4094>;;Secondary VLAN ID of the private VLAN "+
                  "port/trunk association";
                range "2..4094";
              }
            }
          }
        }
      }

      // interface * / switchport access vlan
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          // dep: before this is created, show changes to 'instance first'
          tailf:cli-diff-dependency "../../../service/instance" {
            tailf:cli-trigger-on-set;
          }
          type union {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID of the VLAN when this port "+
                "is in access mode";
              range "1..4094";
            }
            type enumeration {
              enum dynamic {
                tailf:info "When in access mode, this interfaces VLAN is "+
                "controlled by VMPS";
              }
            }
          }
          default 1;
        }
      }

      // interface * / switchport backup interface *
      container backup {
        tailf:info "Set backup for the interface";
        list interface {
          tailf:info "Specify an interface as backup";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }

          // interface * / switchport backup interface * preemption
          container preemption {
            tailf:info "preemption parameters";

            // interface * / switchport backup interface * preemption mode
            leaf mode {
              tailf:info "set the preemption mode";
              type enumeration {
                enum bandwidth {
                  tailf:info "higher bandwidth interface preferred";
                }
                enum forced {
                  tailf:info "active interface preferred";
                }
                enum off {
                  tailf:info "turn off preemption";
                }
              }
            }

            // interface * / switchport backup interface * preemption delay
            leaf delay {
              tailf:info "preemption parameters";
              type uint16 {
                tailf:info "<1-300>;;preemption delay in seconds";
                range "1..300";
              }
            }
          }
        }
      }

      // interface * / switchport nonegotiate
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol "+
          "on this interface";
        tailf:cli-diff-dependency "../trunk";
        tailf:cli-diff-dependency "../mode/trunk";
        tailf:cli-diff-dependency "../mode/access";
        type empty;
      }

      // interface * / switchport block
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }

      // interface * / switchport port-security
      container port-security {
        tailf:info "Security related command";
        tailf:cli-display-separated;
        tailf:cli-diff-dependency "../mode/access";
        tailf:cli-diff-dependency "../mode/trunk";
        //tailf:cli-diff-dependency "../trunk";
        //tailf:cli-diff-dependency "../private-vlan/trunk";
        presence true;

        // interface * / switchport port-security aging
        container aging {
          tailf:info "Port-security aging commands";
          leaf time {
            tailf:info "Port-security aging time";
            type uint16 {
              tailf:info "<1-1440>;;Aging time in minutes. Enter a value "
                +"between 1 and 1440";
              range "1..1440";
            }
          }
          leaf "type" {
            tailf:info "Port-security aging type";
            type enumeration {
              enum absolute {
                tailf:info "Absolute aging (default)";
              }
              enum inactivity {
                tailf:info "Aging based on inactivity time period";
              }
            }
          }
        }

        // interface * / switchport port-security mac-address
        container mac-address {
          tailf:info "Secure mac address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf sticky {
            tailf:info "Configure dynamic secure addresses as sticky";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf hw-address {
            tailf:cli-drop-node-name;
            type yang:mac-address {
              tailf:info "H.H.H;;48 bit mac address";
            }
          }
          leaf vlan {
            tailf:info "set VLAN ID of the VLAN on which this address can be "
              +"learned";
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID on which this address can be "
                +"learned";
              range "1..4094";
            }
          }
        }

        // interface * / switchport port-security maximum
        leaf maximum {
          tailf:info "Max secure addresses";
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-8192>;;Maximum addresses";
            range "1..8192";
          }
        }

        // interface * / switchport port-security maximum ? vlan
        container maximum-vlan {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maximum {
            tailf:cli-no-value-on-delete;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-8192>;;Maximum addresses";
              range "1..8192";
            }
          }
          leaf vlan {
            tailf:info "Max secure addresses per vlan";
            type empty;
          }
        }

        // interface * / switchport port-security maximum * vlan *
        container maximum-vlan-list {
          tailf:cli-drop-node-name;
          list maximum {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "max-addresses vlan";
            leaf max-addresses {
              type uint16 {
                tailf:info "<1-8192>;;Maximum addresses";
                range "1..8192";
              }
            }
            leaf vlan {
              tailf:info "Max secure addresses per vlan";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;VLAN IDs to which this maximum applies";
              }
            }
          }
        }

        // interface * / switchport port-security violation
        leaf violation {
          tailf:info "Security violation mode";
          type enumeration {
            enum protect {
              tailf:info "Security violation protect mode";
            }
            enum restrict {
              tailf:info "Security violation restrict mode";
            }
            enum shutdown {
              tailf:info "Security violation shutdown mode";
            }
          }
        }
      }

      // interface * / switchport priority
      container priority {
        tailf:info "Set appliance 802.1p priority";
        tailf:cli-incomplete-command;

        container extend {
          tailf:info "Set appliance 802.1p priority";
          tailf:cli-incomplete-command;
          choice trust-choice {
            leaf trust {
              tailf:cli-full-command;
              tailf:info "Trust 802.1p priorities of devices on appliance";
              type empty;
            }
            leaf cos {
              tailf:info "Override 802.1p priority of devices on appliance";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Priority for devices on appliance";
                range "0..7";
              }
            }
          }
        }
      }

      // interface * / switchport protected
      leaf protected {
        tailf:info "Configure an interface to be a protected port";
        type empty;
      }

      // interface * / switchport voice
      container voice {
        tailf:info "Voice appliance attributes";
        leaf vlan {
          tailf:info "Vlan for voice traffic";
          type union {
            type enumeration {
              enum dot1p {
                tailf:info "Priority tagged on PVID";
              }
              enum none {
                tailf:info "Don't tell telephone about voice vlan";
              }
              enum untagged {
                tailf:info "Untagged on PVID";
              }
            }
            type uint16 {
              tailf:info "<1-4094>;;Vlan for voice traffic";
              range "1..4094";
            }
          }
        }
        container detect {
          tailf:info "detection enhancement keyword";
          tailf:cli-incomplete-command;
          container cisco-phone {
            tailf:info "Cisco IP phone";
            presence true;
            leaf full-duplex {
              tailf:info "full duplex keyword";
              type empty;
            }
          }
        }
      }

      // interface * / switchport host
      leaf host {
        tailf:info "Set port host";
        type empty;
      }
    }

    // interface * / l2protocol-tunnel
    container l2protocol-tunnel {
      tailf:info "Tunnel Layer2 protocols";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../switchport";
      presence true;

      // interface * / l2protocol-tunnel cdp
      leaf cdp {
        tailf:info "Cisco Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel drop-threshold
      container drop-threshold {
        tailf:info "Set drop threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which protocol "
              +"packets will be dropped";
            range "1..4096";
          }
        }
      }

      // interface * / l2protocol-tunnel shutdown-threshold
      container shutdown-threshold {
        tailf:info "Set shutdown threshold for protocol packets";
        leaf packet-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf cdp {
          tailf:info "Cisco Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf stp {
          tailf:info "Spanning Tree Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf vtp {
          tailf:info "Vlan Trunking Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
        leaf lldp {
          tailf:info "Link Layer Discovery Protocol";
          type uint16 {
            tailf:info "<1-4096>;;Packets/sec rate beyond which interface is "
              +"put to err-disable";
            range "1..4096";
          }
        }
      }

      // interface * / l2protocol-tunnel stp
      leaf stp {
        tailf:info "Spanning Tree Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel vtp
      leaf vtp {
        tailf:info "Vlan Trunking Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel lldp
      leaf lldp {
        tailf:info "Link Layer Discovery Protocol";
        type empty;
      }

      // interface * / l2protocol-tunnel point-to-point
      container point-to-point {
        tailf:info "point-to-point L2 Protocol";
        leaf lacp {
          tailf:info "Link Aggregation Control Protocol";
          type empty;
        }
        leaf pagp {
          tailf:info "Port Aggregation Protocol";
          type empty;
        }
        leaf udld {
          tailf:info "Unidirectional Link Detection";
          type empty;
        }
      }
    }
  } // interface-switch-grouping0

  grouping interface-switch-grouping {
    uses interface-switch-grouping0 {
      refine "switchport" {
        tailf:cli-diff-dependency "../../../vlan/vlan-list";
      }
    }
  }

  grouping sub-interface-switch-grouping {
    uses interface-switch-grouping0 {
      refine "switchport" {
        tailf:cli-diff-dependency "../../../../vlan/vlan-list";
      }
    }
  }


  // crypto pki token grouping
  grouping crypto-pki-token-grouping {
    // max-retries  maximum number of consecutive login failures permitted
    container removal {
      tailf:info "actions to take after token removal";
      leaf timeout {
        tailf:info "seconds after token removal at which keys "
          +"from the token are cleared";
        type uint16 {
          tailf:info "<0-480>;;Token key timeout in seconds";
          range "0..480";
        }
      }
    }
  }


  // router bgp * /
  grouping router-bgp-max-path-grouping {

    // router bgp * / maximum-paths
    container paths {
      tailf:cli-drop-node-name;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number-of-paths {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-16>;;Number of paths";
          range "1..16";
        }
        default "1";
      }
      leaf "import" {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }
  }


  grouping router-bgp-redistribute-isis-grouping {
    choice osi-ip-choice {
      leaf ip {
        tailf:info "Redistribution of IP dynamic routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type empty;
      }
      leaf clns {
        tailf:info "Redistribution of OSI dynamic routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type empty;
      }
    }
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
      }
    }
  }


  // router-bgp-redistribute-grouping
  grouping router-bgp-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-remove-before-change;
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into BGP";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf include-connected {
      tailf:info "Include connected";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }
  }


  grouping router-bgp-redistribute-ospf-grouping {

    leaf metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-remove-before-change;
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }

    leaf subnets {
      tailf:info "Consider subnets for redistribution into BGP";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    leaf route-map {
      tailf:info "Route map reference";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    leaf include-connected {
      tailf:info "Include connected";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    leaf match {
      tailf:info "Redistribution of OSPF routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      tailf:cli-incomplete-command;
      type empty;
    }

    leaf internal {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:info "Redistribute OSPF internal routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    container external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "1" {
            tailf:info "Redistribute external type 1 routes";
          }
        }
      }
    }

    container external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf external {
        tailf:info "Redistribute OSPF external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "2" {
            tailf:info "Redistribute external type 2 routes";
          }
        }
      }
    }

    container nssa-external-1 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "1" {
            tailf:info "Redistribute NSSA external type 1 routes";
          }
        }
      }
    }

    container nssa-external-2 {
      when "../match" {
        tailf:dependency "../match";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf nssa-external {
        tailf:info "Redistribute OSPF NSSA external routes";
        tailf:cli-no-name-on-delete;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum "2" {
            tailf:info "Redistribute NSSA external type 2 routes";
          }
        }
      }
    }
  }


  // route-map-metric-grouping
  grouping route-map-metric-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
        range "0..4294967295";
      }
    }
  }


  // router bgp * / neighbor * distribute-list *
  grouping router-bgp-neighbor-distribute-list-grouping {

    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-remove-before-change;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      key direction;
      leaf direction {
        type enumeration {
          enum "in" {
            tailf:info "Filter incoming routing updates";
          }
          enum "out" {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      uses distribute-list-content-grouping;
    }

    container distribute-list-interface {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-remove-before-change;
        tailf:cli-diff-dependency "../../inherit/peer-session";
        tailf:cli-diff-dependency "../../peer-group";
        tailf:cli-diff-dependency "../../remote-as";
        tailf:cli-diff-dependency "../../activate";
        key "direction interface";
        leaf direction {
          type enumeration {
            enum "in" {
              tailf:info "Filter incoming routing updates";
            }
            enum "out" {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface"; // NESTED
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        uses distribute-list-content-grouping;
      }
    }
  }


  // router bgp * / neighbor *
  // router bgp * / peer-policy * /
  grouping router-bgp-peer-policy-grouping {

    // router bgp * / neighbor * advertisement-interval
    leaf advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type uint16 {
        tailf:info "<0-600>;;time in seconds";
        range "0..600";
      }
    }

    // router bgp * / neighbor * next-hop-self
    leaf next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }

    // router bgp * / neighbor * aigp
    container aigp {
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
    }

    // router bgp * / neighbor * send-community
    container send-community {
      tailf:info "Send Community attribute to this neighbor";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf send-community-where {
        tailf:cli-drop-node-name;
        type enumeration {
          enum both {
            tailf:info "Send Standard and Extended Community "
            +"attributes";
          }
          enum extended {
            tailf:info "Send Extended Community attribute";
          }
          enum standard {
            tailf:code-name "send_standard";
            tailf:info "Send Standard Community attribute";
          }
        }
      }
    }

    // router bgp * / neighbor * send-label
    container send-label {
      tailf:info "Send NLRI + MPLS Label to this peer";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        type empty;
      }
    }

    // router bgp * / neighbor * maximum-prefix
    container maximum-prefix {
      tailf:info "Maximum number of prefixes accepted from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf max-prefix-no {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-2147483647>;;maximum no. of prefix limit";
          range "1..2147483647";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to "
            +"generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:cli-full-command;
        tailf:info "Restart bgp connection after limit is exceeded";
        type uint16 {
          tailf:info "<1-65535>;;Restart interval in minutes";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:cli-full-command;
        tailf:info "Only give warning message when limit "
          +"is exceeded";
        type empty;
      }
    }

    // router bgp * / neighbor * allowas-in
    container allowas-in {
      tailf:info "Accept as-path with my AS present in it";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf as-no {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurances of AS number";
          range "1..10";
        }
      }
    }

    // router bgp * / neighbor * as-override  [peergroup only]
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf disable {
        type empty;
      }
    }

    // router bgp * / neighbor * route-map *
    list route-map {
      tailf:info "Apply route map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply map to incoming routes";
          }
          enum out {
            tailf:info "Apply map to outbound routes";
          }
        }
      }
      leaf route-map-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Name of route map";
        }
      }
    }

    // router bgp * / neighbor * advertise-map * exist-map *
    list advertise-map {
      tailf:info "Apply advertise map to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of route map";
        }
      }
      list exist-map {
        tailf:info "advertise prefix only if prefix is in the condition exists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;condition route-map name";
          }
        }
      }
    }

    // router bgp * / neighbor * default-originate
    container default-originate {
      tailf:info "Originate default route to this neighbour";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf route-map {
        tailf:info "Route-map to specify criteria to originate default";
        type string {
          tailf:info "WORD;;route-map name";
        }
      }
    }

    // router bgp * / neighbor * prefix-list *
    list prefix-list {
      tailf:info "Filter updates to/from this neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming updates";
          }
          enum out {
            tailf:info "Filter outgoing updates";
          }
        }
      }
      leaf prefix-list-name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:non-strict-leafref {
          path "/ios:ip/prefix-list/prefixes/name";
        }
        type string {
          tailf:info "WORD;;Name of a prefix list";
        }
      }
    }

    // router bgp * / neighbor * route-reflector-client
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }

    // router bgp * / neighbor * soft-reconfiguration
    leaf soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type enumeration {
        enum inbound {
          tailf:info "Allow inbound soft reconfiguration for this neighbor";
        }
      }
    }

    // router bgp * / neighbor * remove-private-as
    container remove-private-as {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf all {
        tailf:info "Remove all private AS numbers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace all private AS numbers with local AS";
        type empty;
      }
    }
  }

  // router bgp * / neighbor *
  // router bgp * / peer-session * /
  grouping router-bgp-peer-session-grouping {

    // router bgp * / neighbor * local-as
    container local-as {
      tailf:info "Specify a local-as number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf as-no {
        tailf:cli-drop-node-name;
        type bgp-as-no-type;
      }
      leaf no-prepend {
        tailf:info "Do not prepend local-as to updates from ebgp peers";
        type empty;
      }
      leaf replace-as {
        tailf:info "Replace real AS with local AS in the EBGP updates";
        type empty;
      }
      leaf dual-as {
        tailf:info "Accept either real AS or local AS from the ebgp peer";
        type empty;
      }
    }

    // router bgp * / neighbor * password
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf enctype {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-7>;;Encryption type (0 to disable encryption, 7 for proprietary)";
          range "0..7";
        }
        default 0;
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|1|2|3|4|5|6|7";
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }

    // router bgp * / neighbor * ttl-security hops
    container ttl-security {
      tailf:info "BGP ttl security check";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf hops {
        tailf:info "IP hops";
        type uint8 {
          tailf:info "<1-254>;;maximum number of hops";
          range "1..254";
        }
      }
    }

    // router bgp * / neighbor * timers
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          range "0..65535";
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Holdtime";
          range "0..65535";
        }
      }
      leaf minimum-neighbor-hold {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Minimum hold time from neighbor";
          range "0..65535";
        }
      }
    }

    // router bgp * / neighbor * fall-over
    // router bgp * / neighbor * fall-over route-map
    container fall-over {
      tailf:info "session fall on peer route lost";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf route-map {
        tailf:info "Route map for peer route";
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / neighbor * fall-over bfd
    container fall-over-bfd {
      tailf:cli-drop-node-name;
      container fall-over {
        tailf:info "session fall on peer route lost";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:cli-diff-dependency "../../inherit/peer-session";
        tailf:cli-diff-dependency "../../peer-group";
        tailf:cli-diff-dependency "../../remote-as";
        tailf:cli-diff-dependency "../../activate";
        tailf:cli-diff-dependency "../../fall-over";
        leaf bfd {
          tailf:info "Use BFD to detect failure";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * ebgp-multihop
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      presence true;
      leaf max-hop {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
    }

    // router bgp * / neighbor * update-source
    container update-source {
      tailf:info "Source of routing updates";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      uses interface-name-grouping;
    }

    // router bgp * / neighbor * path-attribute
    container path-attribute {
      tailf:info "BGP optional attribute filtering";

      // router bgp * / neighbor * path-attribute discard * in
      list discard {
        tailf:info "Discard matching path-attribute for this neighbor";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;path attribute type";
            range "1..255";
          }
        }
        leaf in {
          tailf:info "Perform inbound path-attribute filtering";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * version
    leaf version {
      tailf:info "Set the BGP version to match a neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type uint8 {
        tailf:info "<4-4>;;Neighbor's BGP version";
        range "4";
      }
    }

    // router bgp * / neighbor * transport
    container transport {
      tailf:info "Transport options";

      // router bgp * / neighbor * transport connection-mode
      leaf connection-mode {
        tailf:info "Specify passive or active connection";
        type enumeration {
          enum active {
            tailf:info "Actively establish the TCP session";
          }
          enum passive {
            tailf:info "Passively establish the TCP session";
          }
        }
      }

      // router bgp * / neighbor * transport path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Use transport path MTU discovery";
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "disable";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * disable-connected-check
    leaf disable-connected-check {
      tailf:info "One-hop away EBGP peer using loopback address";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }
  }


  // router bgp * / neighbor *
  grouping router-bgp-neighbor-grouping {

    // router bgp * / neighbor * remote-as
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      type string {
        tailf:info "AS of remote neighbor";
      }
    }

    // router bgp * / neighbor * activate
    leaf activate {
      tailf:info "Enable the Address Family for this Neighbor";
      tailf:cli-delete-container-on-delete;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      type empty;
    }

    // router bgp * / neighbor * local-as
    // router bgp * / neighbor * password
    // router bgp * / neighbor * ttl-security hops
    // router bgp * / neighbor * timers
    // router bgp * / neighbor * fall-over
    // router bgp * / neighbor * ebgp-multihop
    // router bgp * / neighbor * update-source
    // router bgp * / neighbor * version
    // router bgp * / neighbor * transport
    // router bgp * / neighbor * disable-connected-check
    uses router-bgp-peer-session-grouping;

    // router bgp * / neighbor * advertisement-interval
    // router bgp * / neighbor * maximum-prefix
    // router bgp * / neighbor * next-hop-self
    // router bgp * / neighbor * send-community
    // router bgp * / neighbor * allowas-in
    // router bgp * / neighbor * as-override
    // router bgp * / neighbor * route-map *
    // router bgp * / neighbor * default-originate
    // router bgp * / neighbor * prefix-list *
    // router bgp * / neighbor * route-reflector-client
    // router bgp * / neighbor * soft-reconfiguration
    // router bgp * / neighbor * remote-private-as
    uses router-bgp-peer-policy-grouping;

    // router bgp * / neighbor * soo
    leaf soo {
      tailf:info "Site-of-Origin extended community";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type string {
        tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
      }
    }

    // router bgp * / neighbor * capability orf prefix-list
    container capability {
      tailf:info "Advertise capability to the peer";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf-list prefix-list {
          tailf:info "Advertise prefixlist ORF capability to this neighbor";
          tailf:cli-flat-list-syntax;
          max-elements 1;
          type enumeration {
            enum both {
              tailf:info "Capability to SEND and RECEIVE the "
              +"ORF to/from this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from "
              +"this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this "
              +"neighbor";
            }
          }
        }
      }
    }

    // router bgp * / neighbor * description
    leaf "description" {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }

    // router bgp * / neighbor * distribute-list *
    uses router-bgp-neighbor-distribute-list-grouping;

    // router bgp * / neighbor * dmzlink-bw
    leaf dmzlink-bw {
      tailf:info "Propagate the DMZ link bandwidth";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }

    // router bgp * / neighbor * filter-list *
    list filter-list {
      tailf:info "Establish BGP filters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routes";
          }
          enum out {
            tailf:info "Filter outgoing routes";
          }
        }
      }
      leaf as-path-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list number or name";
        }
      }
    }

    // router bgp * / neighbor * inherit
    container inherit {
      tailf:info "Inherit a template";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";

      // router bgp * / neighbor * inherit peer-policy
      leaf peer-policy {
        tailf:info "Inherit a peer-policy template";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:router/bgp/template/peer-policy"; // NESTED
        tailf:cli-diff-dependency "../../activate";
        type string {
          tailf:info "WORD;;Template name";
        }
      }

      // router bgp * / neighbor * inherit peer-session
      leaf peer-session {
        tailf:info "Inherit a peer-session template";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "/ios:router/bgp/template/peer-session"; // NESTED
        tailf:cli-diff-dependency "/ios:router/bgp/template/peer-session/remote-as"; // NESTED
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // router bgp * / neighbor * next-hop-self ?
    container next-hop-self-arg {
      tailf:cli-drop-node-name;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf next-hop-self {
        type string;
      }
    }

    // router bgp * / neighbor * next-hop-unchanged
    leaf next-hop-unchanged {
      tailf:info "Propagate the iBGP paths's next hop unchanged for this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }

    // router bgp * / neighbor * shutdown
    leaf shutdown {
      tailf:info "Administratively shut down this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type empty;
    }

    // router bgp * / neighbor * translate-update
    container translate-update {
      tailf:info "Translate Update to MBGP format";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      container ipv4 {
        tailf:info "Address Family";
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence "Address Family modifier";
          leaf unicast {
            tailf:info "Address Family modifier";
            type empty;
          }
        }
      }
    }

    // router bgp * / neighbor * unsuppress-map
    leaf unsuppress-map {
      tailf:info "Route-map to selectively unsuppress suppressed routes";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type string {
        tailf:info "WORD;;Name of route map";
      }
    }

    // router bgp * / neighbor * weight
    leaf weight {
      tailf:info "Set default weight for routes from this neighbor";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type uint16 {
        tailf:info "<0-65535>;;default weight";
        range "0..65535";
      }
    }

    // router bgp * / neighbor * ha-mode
    container ha-mode {
      tailf:info "high availability mode";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      container graceful-restart {
        tailf:info "graceful-restart for this peer";
        presence true;
        leaf disable {
          tailf:info "disable graceful-restart";
          type empty;
        }
      }
      container sso {
        tailf:info "stateful-switchover support for this peer";
        presence true;
        leaf disable {
          tailf:info "disable stateful-switchover";
          type empty;
        }
      }
    }

    // router bgp * / neighbor * suppress-signaling-protocol
    container suppress-signaling-protocol {
      tailf:info "suppress VPLS signaling protocol";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      leaf ldp {
        tailf:info "suppress ldp signaling, enable bgp signaling";
        tailf:cli-full-command;
        type empty;
      }
    }

    // router bgp * / neighbor * prefix-length-size
    leaf prefix-length-size {
      tailf:info "Packet Level storage size for Prefixes";
      tailf:cli-diff-dependency "../inherit/peer-session";
      tailf:cli-diff-dependency "../peer-group";
      tailf:cli-diff-dependency "../remote-as";
      tailf:cli-diff-dependency "../activate";
      type uint8 {
        tailf:info "<1-2>;;Storage size in bytes";
        range "1..2";
      }
    }
  }


  // router bgp * / address-family *
  grouping router-bgp-af-grouping {

    // router bgp * / address-family * / synchronization
    leaf synchronization {
      tailf:info "Perform IGP synchronization";
      tailf:cli-full-command;
      type empty;
    }

    // router bgp * / address-family * / table-map
    leaf table-map {
      tailf:info "Map external entry attributes into routing table";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;route-map name";
      }
    }

    // router bgp * / address-family * / bgp
    container bgp-af {
      tailf:cli-drop-node-name;
      container bgp {
        tailf:info "BGP specific commands";

        // router bgp * / address-family * / bgp redistribute-internal
        leaf redistribute-internal {
          tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp dampening
        container dampening {
          tailf:info "Enable route-flap dampening";
          presence true;
          choice dampening-choice {
            leaf route-map {
              tailf:info "Route-map to specify criteria for dampening";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            container dampen {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf half-life-time {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-45>;;Half-life time for the penalty";
                  range "1..45";
                }
              }
              leaf reuse-time {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-20000>;;Value to start reusing a route";
                  range "1..20000";
                }
              }
              leaf suppress-time {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-20000>;;Value to start suppressing a route";
                  range "1..20000";
                }
              }
              leaf max-suppress-time {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-255>;;Maximum duration to suppress a "+
                    "stable route";
                  range "1..255";
                }
              }
            }
          }
        }

        // router bgp * / address-family * / bgp additional-paths
        container additional-paths {
          tailf:info "Additional paths in the BGP table";
          choice send-receive-choice {
            // router bgp * / address-family * / bgp additional-paths receive
            leaf receive {
              tailf:info "Receive additional paths from neighbors";
              tailf:cli-full-command;
              type empty;
            }
            // router bgp * / address-family * / bgp additional-paths send
            container send {
              tailf:info "Send additional paths to neighbors";
              tailf:cli-delete-when-empty;
              presence true;
              leaf receive {
                tailf:info "Receive additional paths from neighbors";
                type empty;
              }
            }
          }
          // router bgp * / address-family * / bgp additional-paths install
          leaf install {
            tailf:info "Additional paths to install into RIB";
            tailf:cli-full-command;
            type empty;
          }
        }

        // router bgp * / address-family * / bgp bestpath igp-metric ignore
        container bestpath {
          tailf:info "Change the default bestpath selection";
          container igp-metric {
            tailf:info "igp metric";
            leaf ignore {
              tailf:info "Ignore igp metric in bestpath selection";
              type empty;
            }
          }
        }

        // router bgp * / address-family * / bgp suppress-inactive
        leaf suppress-inactive {
          tailf:info "Suppress routes that are not in the routing table";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp dmzlink-bw
        leaf dmzlink-bw {
          tailf:info "Use DMZ Link Bandwidth as weight for BGP multipaths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp soft-reconfig-backup
        leaf soft-reconfig-backup {
          tailf:info "Use soft-reconfiguration inbound only when route-"
            +"refresh is not negotiated";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / address-family * / bgp nexthop
        container nexthop {
          tailf:info "Nexthop tracking commands";

          // router bgp * / address-family * / bgp nexthop route-map
          leaf route-map {
            tailf:info "Route map for valid nexthops";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;route-map name";
            }
          }

          // router bgp * / address-family * / bgp nexthop trigger
          container trigger {
            tailf:info "Nexthop triggering";

            // router bgp * / address-family * / bgp nexthop trigger delay
            leaf delay {
              tailf:cli-full-command;
              tailf:info "Set the delay to tigger nexthop tracking";
              type uint8 {
                tailf:info "<0-100>;;Delay value (seconds)";
                range "0..100";
              }
            }

            // router bgp * / address-family * / no bgp nexthop trigger enable
            leaf enable {
              tailf:info "Enable nexthop tracking";
              tailf:cli-full-command;
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }

        // router bgp * / address-family * / bgp scan-time
        leaf scan-time {
          tailf:cli-full-command;
          tailf:info "Configure background scanner interval";
          type uint8 {
            tailf:info "<5-60>;;Scanner interval (seconds)";
            range "5..60";
          }
        }

        // router bgp * / address-family * / bgp inject-map *
        list inject-map {
          tailf:info "Routemap which specifies prefixes to inject";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          leaf exist-map {
            tailf:info "Routemap which specifies exist condition";
            type string {
              tailf:info "WORD;;route-map name";
            }
          }
          leaf copy-attributes {
            tailf:info "Copy attributes from aggregate";
            type empty;
          }
        }

        // router bgp * / address-family * / bgp recursion host
        container recursion {
          tailf:info "recursion rule for the nexthops";
          leaf host {
            tailf:info "recursion via host for the nexthops";
            type empty;
          }
        }
      }
    }

    // router bgp * / address-family * / network *
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key number;
      leaf number {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        tailf:cli-full-command;
        type empty;
      }
      leaf mask {
        tailf:info "Network mask";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network mask";
        }
      }
      leaf route-map {
        tailf:info "Route-map to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the route map";
        }
      }
    }

    // router bgp * / address-family * / aggregate-address *
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "address mask";
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Aggregate mask";
        }
      }
      uses router-bgp-aggregate-address-content-grouping;
    }

    // router bgp * / address-family * / aggregate-address *
    container aggregate-addres-ipv6 {
      tailf:cli-drop-node-name;
      list aggregate-address {
        tailf:info "Configure BGP aggregate entries";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key address;
        leaf address {
          type ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 Network number";
          }
        }
        uses router-bgp-aggregate-address-content-grouping;
      }
    }

    // router bgp * / address-family * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router bgp * / address-family * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-delete-when-empty;
        leaf as-no {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type bgp-as-no-type;
        }
        uses router-bgp-redistribute-grouping {
          refine "metric" {
            tailf:cli-break-sequence-commands;
          }
        }
      }

      // router bgp * / address-family * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute dvmrp
      container dvmrp {
        tailf:info "Redistribution of DVMRP into BGP IPv4 Multicast";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-delete-when-empty;
        presence true;
        uses route-map-metric-grouping;
      }

      // router bgp * / address-family * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-isis-grouping;
        uses router-bgp-redistribute-grouping;

        // router bgp * / address-family * / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|clns|ip"+
              "|route-map|subnets|include-connected";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-bgp-redistribute-isis-grouping;
          uses router-bgp-redistribute-grouping;
        }
      }

      // router bgp * / address-family * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        uses route-map-metric-grouping;
        list iso-igrp-area {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
              // match any but route-map
              pattern '^([^r].*)|(r^[o].*)|(ro[^u].*)|'
                +'(rou[^t].*)|(rout[^e].*)|(route[^\-].*)|'
                +'(route-[^m].*)|(route-m[^a].*)|'
                +'(route-ma[^p])|(route-map..*)';
            }
          }
          uses route-map-metric-grouping;
        }
      }

      // router bgp * / address-family * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-remove-before-change;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        leaf vrf {
          // Note: only one vrf per entry, since must match af vrf
          tailf:info "VPN Routing/Forwarding Instance";
          tailf:cli-diff-dependency "/ios:ip/vrf"; // NESTED
          tailf:cli-diff-dependency "/ios:vrf/definition"; // NESTED
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
          }
        }
        uses router-bgp-redistribute-ospf-grouping;
      }

      // router bgp * / address-family * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }

      // router bgp * / address-family * / redistribute lisp
      container lisp {
        tailf:info "Locator ID Separation Protocol (LISP)";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-bgp-redistribute-grouping;
      }
    }

    // router bgp * / address-family * / neighbor *
    container neighbor-tag {
      tailf:cli-drop-node-name;
      list neighbor {
        tailf:info "Specify a neighbor router";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Neighbor tag";
          }
        }
        // router bgp * / address-family * / neighbor * peer-group
        leaf peer-group {
          tailf:info "Configure peer-group";
          tailf:cli-delete-container-on-delete;
          tailf:cli-full-command;
          type empty;
        }
        uses router-bgp-neighbor-grouping;
      }
    }

    // router bgp * / address-family * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../neighbor-tag/neighbor";
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      // router bgp * / address-family * / neighbor * peer-group
      leaf peer-group {
        tailf:info "Member of the peer-group";
        tailf:cli-delete-container-on-delete;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
      uses router-bgp-neighbor-grouping;
    }

    // router bgp * / address-family * / maximum-paths
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";

      // router bgp * / address-family * / maximum-paths
      uses router-bgp-max-path-grouping;

      // router bgp * / address-family * / maximum-paths eibgp
      container eibgp {
        tailf:info "Both eBGP and iBGP paths as multipath";
        uses router-bgp-max-path-grouping;
      }

      // router bgp * / address-family * / maximum-paths ibgp
      container ibgp {
        tailf:info "iBGP-multipath";
        choice ibgp-choice {
          default b;
          case a {
            container unequal-cost {
              tailf:info "Perform Un-Equal cost multipath selection";
              uses router-bgp-max-path-grouping;
            }
          }
          case b {
            uses router-bgp-max-path-grouping;
          }
        }
      }

      // router bgp * / address-family * / maximum-paths import
      leaf "import" {
        tailf:info "Maximum import paths";
        type uint16 {
          tailf:info "<1-16>;;Number of import paths";
          range "1..16";
        }
      }
    }

    // router bgp * / import path
    container "import" {
      tailf:info "Configure path import";
      container "path" {
        tailf:info "Path selection and path limit";

        // router bgp * / import path selection
        container selection {
          tailf:info "Path selection policy";
          choice selection-choice {
            leaf all {
              tailf:info "Import all available paths";
              type empty;
            }
            container bestpath {
              tailf:info "Import the best available path.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
            container multipaths {
              tailf:info "Import all multipaths.";
              tailf:cli-delete-when-empty;
              presence true;
              leaf strict {
                tailf:info "Do not fallback to best available path";
                type empty;
              }
            }
          }
        }

        // router bgp * / import path limit
        leaf limit {
          tailf:info "Per net imported path limit";
          type uint8 {
            tailf:info "<2-255>;;Maximum number of paths that can be "+
              "imported into a net";
            range "2..255";
          }
        }
      }
    }

    // router bgp * / address-family * / default-information originate
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }

    // router bgp * / address-family * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router bgp * / address-family * / distribute-list *
    uses router-distribute-list-grouping;

    // router bgp * / address-family * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router bgp * / address-family * / distance bgp
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf extern-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal-as {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }

      // router bgp * / address-family * / distance *
      list adm-distance {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "srcip wildbits";
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint16 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf srcip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildbits {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router bgp * / address-family * / auto-summary
    // router bgp * / address-family * / no auto-summary
    leaf auto-summary {
      // Cisco doc node: Disabled by default
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }
  }

  // router bgp * / bgp
  grouping router-bgp-bgp-grouping {

    // router bgp * / bgp
    container bgp {

      // router bgp * / bgp router-id
      leaf router-id {
        tailf:info "Override configured router identifier (peers will reset)";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }

      // router bgp * / no bgp fast-external-fallover
      leaf fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly "
          +"connected external peer goes down";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / bgp always-compare-med
      leaf always-compare-med {
        tailf:info "Allow comparing MED from different neighbors";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / bgp cluster-id
      leaf cluster-id {
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id "
              +"as 32 bit quantity";
            range "1..4294967295";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP "
              +"address format";
          }
        }
      }

      // router bgp * / no bgp transport path-mtu-discovery
      container transport {
        tailf:info "global enable/disable transport session parameters";
        leaf path-mtu-discovery {
          tailf:info "transport path MTU discovery";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router bgp * / no bgp enforce-first-as
      leaf enforce-first-as {
        tailf:info "Enforce the first AS for EBGP routes(default)";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router bgp * / bgp client-to-client
      container client-to-client {
        tailf:info "Configure client to client route reflection";

        // router bgp * / no bgp client-to-client reflection
        leaf reflection {
          tailf:info "reflection of routes allowed";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router bgp * / bgp log-neighbor-changes
      // router bgp * / no bgp log-neighbor-changes
      leaf log-neighbor-changes {
        tailf:info "Log neighbor up/down and reset reason";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // router bgp * / bgp confederation
      container confederation {
        tailf:info "AS confederation parameters";

        // router bgp * / bgp confederation identifier
        leaf identifier {
          tailf:info "as number";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Set routing domain confederation AS";
            range "1..65535";
          }
        }

        // router bgp * / bgp confederation peers
        container peers {
          tailf:info "Peer ASs in BGP confederation";
          leaf-list as-no {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            type bgp-as-no-type;
          }
        }
      }

      // router bgp * / bgp deterministic-med
      leaf deterministic-med {
        tailf:cli-full-command;
        tailf:info "Pick the best-MED path among paths advertised from "
          +"the neighboring AS";
        type empty;
      }

      // router bgp * / bgp listen
      container listen {
        tailf:info "Neighbor subnet range listener";

        // router bgp * / bgp listen range *
        list "range" {
          tailf:info "Subnet network range";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key network-length;
          leaf network-length {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;Subnet range <network>/<length>, e.g., 10.0.0.0/24";
            }
          }
          leaf peer-group {
            tailf:info "Member of the peer-group";
            type string {
              tailf:info "WORD;;peer-group name";
            }
          }
        }

        // router bgp * / bgp listen limit
        leaf limit {
          tailf:info "Set the max limit for the dynamic subnet range neighbors";
          type uint32 {
            tailf:info "<1-5000>;;max number";
            range "1..5000";
          }
        }
      }

      // router bgp * / bgp update-delay
      leaf update-delay {
        tailf:info "Set the max initial delay for sending update";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-3600>;;Delay value (seconds)";
          range "1..3600";
        }
      }

      // router bgp * / bgp graceful-restart
      container graceful-restart-conf {
        tailf:cli-drop-node-name;
        container graceful-restart {
          tailf:info "Graceful restart capability parameters";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;

          // router bgp * / bgp graceful-restart restart-time
          leaf restart-time {
            tailf:info "Set the max time needed to restart and come back up";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-3600>;;Delay value (seconds)";
              range "1..3600";
            }
            default 120;
          }

          // router bgp * / bgp graceful-restart stalepath-time
          leaf stalepath-time {
            tailf:info "Set the max time to hold onto restarting "
              +"peer's stale paths";
            type uint16 {
              tailf:info "<1-3600>;;Delay value (seconds)";
              range "1..3600";
            }
            default 360;
          }
        }
      }
      // router bgp * / bgp graceful-restart
      leaf graceful-restart {
        tailf:info "Graceful restart capability parameters";
        tailf:cli-full-command;
        type empty;
      }

      // router bgp * / no bgp regexp deterministic
      container regexp {
        tailf:info "Select regular expression engine";
        leaf deterministic {
          tailf:info "Enable bounded-execution-time regular expression engine";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // router bgp * / bgp bestpath
      container bestpath {
        tailf:info "Change the default bestpath selection";

        // router bgp * / bgp bestpath compare-routerid
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }

        // router bgp * / bgp bestpath cost-community ignore
        container cost-community {
          tailf:info "cost community";
          leaf ignore {
            tailf:info "Ignore cost communities in bestpath selection";
            type empty;
          }
        }

        // router bgp * / bgp bestpath med
        container med {
          tailf:info "MED attribute";
          choice med-choice {
            container confed {
              tailf:info "Compare MED among confederation paths";
              presence "Compare MED among confederation paths";
              leaf missing-at-worst {
                tailf:info "Treat missing MED as the least "
                  +"preferred one";
                type empty;
              }
            }
            leaf missing-at-worst {
              tailf:info "Treat missing MED as the least "
                +"preferred one";
              type empty;
            }
          }
        }

        // router bgp * / bgp bestpath as-path multipath-relax
        container as-path {
          leaf multipath-relax {
            type empty;
          }
        }
      }

      // router bgp * / bgp maxas-limit
      leaf maxas-limit {
        tailf:info "Allow AS-PATH attribute from any neighbor imposing "
          +"a limit on number of ASes";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-2000>;;Number of ASes in the AS-PATH attribute";
          range "1..2000";
        }
      }

      // router bgp * / bgp default
      container "default" {
        tailf:info "Configure BGP defaults";

        // router bgp * / no bgp default ipv4-unicast
        leaf ipv4-unicast {
          tailf:info "Activate ipv4-unicast for a peer by default";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / no bgp default ipv4-activate
        leaf ipv4-activate {
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        // router bgp * / bgp default local-preference
        leaf local-preference {
          tailf:info "local preference (higher=more preferred)";
          type uint32 {
            tailf:info "<0-4294967295>;;Configure default "
              +"local preference value";
            range "1..4294967295";
          }
        }

        // no bgp default route-target filter
        container route-target {
          tailf:info "Control behavior based on Route-Target attributes";
          leaf filter {
            tailf:info "Control automatic VPN Route-Target filtering";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
      }
    }

    // router bgp * / timers bgp
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:info "BGP timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Holdtime";
            range "0..65535";
          }
        }
        leaf min-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;Minimum hold time from neighbor";
            range "0..65535";
          }
        }
      }
    }
  }

  // router ospfv3 * / address-family ipv4 XX
  grouping router-ospf-af-grouping {
  }

  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospfv3-af-grouping {

    // router ospfv3 * / address-family * / capability
    container capability {
      tailf:info "Enable a specific feature";
      leaf vrf-lite {
        tailf:info "Do not perform PE specific checks";
        type empty;
      }
    }

    // router ospfv3 * / address-family * / discard-route
    container discard-route {
      tailf:info "Enable or disable discard-route installation";

      // router ospfv3 * / address-family * / no discard-route external
      leaf external {
        tailf:info "Discard route for summarised redistributed routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospfv3 * / address-family * / no discard-route internal
      leaf internal {
        tailf:info "Discard route for summarised inter-area routes";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  // router ospf * /
  // router ospf * vrf * /
  // router ospfv3 * / address-family ipv4 unicast /
  // router ospfv3 * / address-family ipv6 /
  // router ospfv3 * / address-family ipv4 unicast vrf * /
  grouping router-ospf-common-af-grouping {

    // router ospf * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        tailf:meta-data "trim-delete-when-empty" {
          tailf:meta-value "( originate)";
        }
        tailf:ned-data "." {
          tailf:transaction to;
        }
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        leaf metric {
          tailf:info "OSPF default metric";
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          type ospf-metric-type;
          default 2;
        }
        leaf route-map {
          tailf:info "Route map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router ospf * / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-16777214>;;OSPF default metric";
        range "1..16777214";
      }
    }

    // router ospf * / distance
    container distance {
      tailf:info "Define an administrative distance";
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
      // router ospf * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf weight {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }

      // router ospf * / distance ospf
      container ospf {
        tailf:info "OSPF routes Administrative distance";
        tailf:cli-compact-syntax;
        leaf intra-area {
          tailf:info "Intra-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for intra-area routes";
            range "1..255";
          }
        }
        leaf inter-area {
          tailf:info "Inter-area routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for inter-area routes";
            range "1..255";
          }
        }
        leaf external {
          tailf:info "External routes";
          type uint32 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }
    }

    // router ospf * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        range "1..32";
        tailf:info "<1-32>;;Number of paths";
      }
    }

    // router ospf * / nsr
    leaf nsr {
      tailf:info "Enable non-stop routing";
      type empty;
    }

    // router ospf * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router ospf * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf as-no {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          tailf:cli-delete-container-on-delete;
          tailf:cli-diff-dependency "/ios:router/bgp";
          type bgp-as-no-type;
        }
        uses router-ospf-redistribute-grouping {
          refine metric {
            tailf:cli-break-sequence-commands;
          }
        }
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        presence true;
        uses router-isis-level-grouping;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
        list isis-area {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2|metric|"
              +"metric-type|route-map|nssa-only|subnets|tag";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-isis-level-grouping;
          uses router-ospf-redistribute-grouping;
          uses router-ospf-route-map-grouping;
        }
      }

      // router ospf * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        presence true;
        leaf area-tag {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value "route-map";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses router-ospf-route-map-grouping;
        uses router-ospf-redistribute-grouping;
      }

      // router ospf * / redistribute maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of IP "
              +"prefixes redistributed";
            range "1..4294967295";
          }
        }
        container threshold-warning-only-container {
          tailf:cli-drop-node-name;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-100>;;Threshold value (%) at which "
                +"to generate a warning message";
              range "1..100";
            }
          }
          leaf warning-only {
            tailf:info "Only give warning message when limit is exceeded";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // router ospf * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;
      }

      // router ospf * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-ospf-redistribute-grouping;
        uses router-ospf-route-map-grouping;

        // router ospf * / redistribute rip *
        list redistribute-list-rip {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this process";
            }
          }
          uses router-ospf-redistribute-grouping;
          uses router-ospf-route-map-grouping;
        }
      }

      // router ospf * / redistribute lisp subnets
      container lisp {
        tailf:info "Locator ID Separation Protocol (LISP)";
        container subnets {
          tailf:info "Consider subnets for redistribution into OSPF";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
        }
      }
    }
  }

  // router ospf * /
  // router ospfv3 * /
  // router ospf * vrf * /
  // router ospfv3 * / address-family ipv4 unicast
  // router ospfv3 * / address-family ipv6 unicast
  grouping router-ospf-common-grouping {

    // router ospf * / area
    list area {
      tailf:info "OSPF area parameters";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type ospf-area-type;
      }

      // router ospf * / area * authentication
      container authentication {
        tailf:info "Enable authentication";
        presence true;

        // router ospf * / area * authentication message-digest
        leaf message-digest {
          tailf:info "Use message-digest authentication";
          type empty;
        }

        // router ospf * / area * authentication null
        choice authentication-choice {
          leaf "null" {
            tailf:info "Use no authentication";
            tailf:cli-full-command;
            type empty;
          }
          // router ospf * / area * authentication key-chain
          leaf key-chain {
            tailf:info "Use a key-chain for cryptographic authentication keys";
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;name of key-chain";
            }
          }
        }
      }

      // router ospf * / area * nssa
      container nssa {
        tailf:info "Specify a NSSA area";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        tailf:meta-data "trim-delete-when-empty" {
          tailf:meta-value "( nssa)";
        }
        tailf:ned-data "." {
          tailf:transaction to;
        }
        tailf:cli-diff-dependency "../stub" {
          tailf:cli-trigger-on-set;
        }
        presence true;

        // router ospf * / area * nssa no-redistribution
        leaf no-redistribution {
          tailf:info "No redistribution into this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa default-information-originate
        leaf default-information-originate {
          tailf:info "Originate Type 7 default into NSSA area";
          type empty;
        }

        // router ospf * / area * nssa metric
        leaf metric {
          tailf:info "OSPF default metric";
          when "../default-information-originate" {
            tailf:dependency "../default-information-originate";
          }
          type uint32 {
            tailf:info "<0-16777214>;;OSPF metric";
            range "0..16777214";
          }
        }

        // router ospf * / area * nssa metric-type
        leaf metric-type {
          tailf:info "OSPF metric type for default routes";
          //FIXME:BUG NCS: when "../default-information-originate";
          type ospf-metric-type;
          default 2;
        }

        // router ospf * / area * nssa nssa-only
        leaf nssa-only {
          tailf:info "Limit default advertisement to this NSSA area";
          type empty;
        }

        // router ospf * / area * nssa no-ext-capability
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into NSSA";
          type empty;
        }

        // router ospf * / area * nssa no-summary
        leaf no-summary {
          tailf:info "Do not send summary LSA into NSSA";
          type empty;
        }

        // router ospf * / area * nssa translate
        container translate {
          tailf:info "Translate LSA";
          container type7 {
            tailf:info "From Type 7 to Type 5";
            tailf:cli-compact-syntax;
            leaf always {
              tailf:info "Always translate LSAs on this ABR";
              type empty;
            }
            leaf suppress-fa {
              tailf:info "Suppress forwarding address in translated LSAs";
              type empty;
            }
          }
        }
      }

      // router ospf * / area * default-cost
      leaf default-cost {
        tailf:info "Set the summary default-cost of a NSSA/stub area";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<0-16777215;;Stub's advertised external route metric";
          range "0..16777215";
        }
      }

      // router ospf * / area * filter-list
      list filter-list {
        tailf:info "Filter networks between OSPF areas";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key direction;
        leaf direction {
          type enumeration {
            enum in {
              tailf:info "Filter networks sent to this area";
            }
            enum out {
              tailf:info "Filter networks sent from this area";
            }
          }
        }
        leaf "prefix" {
          tailf:cli-prefix-key;
          tailf:info "Filter prefixes between OSPF areas";
          type string {
            tailf:info "WORD;;Name of an IP prefix-list";
          }
        }
      }

      // router ospf * / area * range
      list "range" {
        tailf:info "Summarize routes matching address/mask (border routers only)";
        tailf:cli-compact-syntax;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to match";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP mask for address";
          }
        }
        leaf advertise {
          tailf:cli-drop-node-name;
          type enumeration {
            enum advertise {
              tailf:info "Advertise this range (default)";
            }
            enum not-advertise {
              tailf:info "DoNotAdvertise this range";
            }
          }
          default advertise;
        }
        leaf cost {
          tailf:info "User specified metric for this range";
          type uint32 {
            tailf:info "<0-16777215>;;Advertised metric for this range";
            range "0..16777215";
          }
        }
      }

      // router ospf * / address-family ipv6 unicast / area * range
      container range-ipv6 {
        tailf:cli-drop-node-name;
        list "range" {
          tailf:info "Summarize routes matching address/mask"
            +"(border routers only)";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "prefix";
          leaf "prefix" {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix to match";
            }
          }
          leaf advertise {
            tailf:cli-drop-node-name;
            type enumeration {
              enum advertise {
                tailf:info "Advertise this range (default)";
              }
              enum not-advertise {
                tailf:info "DoNotAdvertise this range";
              }
            }
            default advertise;
          }
          leaf cost {
            tailf:info "User specified metric for this range";
            type uint32 {
              tailf:info "<0-16777215>;;Advertised metric for this range";
              range "0..16777215";
            }
          }
        }
      }

      // router ospf * / area * sham-link *
      list sham-link {
        tailf:info "Define a sham link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "source dest";
        leaf source {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link source";
          }
        }
        leaf dest {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP addr associated with sham-link "
              +"destination";
          }
        }
        leaf cost {
          tailf:info "Associate a cost with the sham-link";
          type uint16 {
            tailf:info "<1-65535>;;Cost of the sham-link";
            range "0..65535";
          }
        }
      }

      // router ospf * / area * stub
      container stub {
        tailf:info "Specify a stub area";
        tailf:cli-compact-syntax;
        //tailf:cli-keep-when-empty;
        tailf:meta-data "trim-delete-when-empty" {
          tailf:meta-value "( stub)";
        }
        tailf:ned-data "." {
          tailf:transaction to;
        }
        tailf:cli-diff-dependency "../nssa" {
          tailf:cli-trigger-on-set;
        }
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
        leaf no-ext-capability {
          tailf:info "Do not send domain specific capabilities into stub area";
          type empty;
        }
      }

      // router ospf * / area * virtual-link *
      list virtual-link {
        tailf:info "Define a virtual link and its parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;ID (IP addr) associated with virtual link neighbor";
          }
        }

        // router ospf * / area * virtual-link retransmit-interval
        leaf retransmit-interval {
          tailf:info "LSA retransmit interval";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link transmit-delay
        leaf transmit-delay {
          tailf:info "LSA transmission delay";
          type uint16 {
            tailf:info "<1-8192>;;Seconds";
            range "1..8192";
          }
          default 1;
        }

        // router ospf * / area * virtual-link hello-interval
        leaf hello-interval {
          tailf:info "Hello packet interval";
          type int32 {
            tailf:info "<1-8192;;Seconds>";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link dead-interval
        leaf dead-interval {
          tailf:info "Dead router detection time";
          type uint16 {
            tailf:info "<1-8192;;Seconds>";
            range "1..8192";
          }
        }

        // router ospf * / area * virtual-link authentication
        leaf authentication {
          tailf:info "Set authentication type";
          type empty;
        }

        // router ospf * / area * virtual-link authentication-key
        container authentication-key {
          tailf:info "Set authentication key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          uses password-grouping;
        }

        // router ospf * / area * virtual-link message-digest-key *
        list message-digest-key {
          tailf:info "Set message digest key";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-255>;;Key ID";
              range "1..255";
            }
          }
          // router ospf * / area * virtual-link message-digest-key * md5
          container md5 {
            tailf:info "Use MD5 algorithm";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-7>;;Encryption type (0 for not "
                  +"yet encrypted, 7 for proprietary)";
                range "0..7";
              }
              default 0;
            }
            leaf auth-key {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Authentication key (16 chars)";
                length "1..16";
              }
            }
          }
        }

      }
    }

    // router ospf * / auto-cost
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      presence "Calculate OSPF interface cost according to bandwidth";
      leaf reference-bandwidth {
        tailf:info "Use reference bandwidth method to assign OSPF cost";
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms "
            +"of Mbits per second";
          range "1..4294967";
        }
      }
    }

    // router ospf * / bfd
    container bfd {
      tailf:info "BFD configuration commands";
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
    }

    // router ospf * / interface-id
    container interface-id {
      tailf:info "Source of the interface ID";
      leaf snmp-if-index {
        tailf:info "SNMP MIB ifIndex";
        type empty;
      }
    }

    // router ospf * / no log-adjacency-changes
    // router ospf * / log-adjacency-changes detail
    // router ospf * / log-adjacency-changes (cat6500 & me3750)
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      tailf:cli-show-no;
      presence true;
      leaf detail {
        tailf:info "Log all state changes";
        type empty;
      }
    }

    // router ospf * / max-lsa
    container max-lsa {
      tailf:info "maximum number of LSAs OSPF process will receive";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf maximum-number {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967294>;;Maximum number of non self-generated "
            +"LSAs this process can receive";
          range "1..4294967294";
        }
      }
      leaf threshold-percentage {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which "
            +"to generate a warning msg";
          range "1..100";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
      leaf ignore-time {
        tailf:info "time during which all adjacencies are suppressed";
        type uint32 {
          tailf:info "<1-17895>;;number of minutes during which "
            +"all adjacencies are suppressed";
          range "1..17895";
        }
      }
      leaf reset-time {
        tailf:info "time after which ignore-count is reset to zero";
        type uint32 {
          tailf:info "<2-35791>;;number of minutes after which "
            +"ignore-count is reset to zero";
          range "2..35791";
        }
        default 60;
      }
      leaf ignore-count {
        tailf:info "maximum number of times adjacencies "
          +"can be suppressed";
        type uint32 {
          range "1..65534";
          tailf:info "<1-65534>;;count on how many times "
            +"adjacencies can be suppressed";
        }
      }
    }

    // router ospf * / passive-interface
    uses passive-interface-grouping;

    // router ospf * / queue-depth
    container queue-depth {
      tailf:info "OSPF Hello/Router process queue depth";

      // router ospf * / queue-depth hello
      leaf hello {
        tailf:info "OSPF Hello process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
        default "unlimited";
      }

      // router ospf * / queue-depth update
      leaf update {
        tailf:info "OSPF Router process queue depth";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;maximum numer of packets in the queue";
            range "1..2147483647";
          }
          type enumeration {
            enum "unlimited" {
              tailf:info "Unlimited queue depth";
            }
          }
        }
      }
    }

    // router ospf * / timers
    container timers {
      tailf:info "Adjust routing timers";

      // router ospf * / timers lsa
      container lsa {
        tailf:info "OSPF LSA timers";
        leaf arrival {
          tailf:info "OSPF LSA arrival timer";
          type uint32 {
            range "0..600000";
            tailf:info "<0-600000>;;The minimum interval in milliseconds "
              +"between accepting the same LSA";
          }
        }
      }

      // router ospf * / timers pacing
      container pacing {
        tailf:info "OSPF pacing timers";

        // router ospf * / timers pacing flood
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<5-100>;;The minimum interval in msec to pace limit flooding on interface";
            range "5..100";
          }
        }

        // router ospf * / timers pacing lsa-group
        leaf lsa-group {
          tailf:info "OSPF LSA group pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<10-1800>;;Interval in sec between group of LSA being refreshed or maxaged";
            range "10..1800";
          }
        }

        // router ospf * / timers pacing retransmission
        leaf retransmission {
          tailf:info "OSPF retransmission pacing timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<5-200>;;The minimum interval in msec between neighbor retransmissions";
            range "5..200";
          }
        }
      }

      // router ospf * / timers throttle
      container throttle {
        tailf:info "OSPF throttle timers";

        // router ospf * / timers throttle lsa
        container lsa {
          tailf:info "OSPF LSA throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf all {
            tailf:info "For all type of OSPF LSAs";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf start-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay to generate first occurrence "
                +"of LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf hold-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Minimum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
          leaf max-interval {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum delay between originating "
                +"the same LSA in milliseconds";
              range "0..600000";
            }
          }
        }

        // router ospf * / timers throttle spf
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf spf-start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between receiving a change "
                +"to SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-hold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-600000>;;Delay between first and second "
                +"SPF calculation in milliseconds";
              range "0..600000";
            }
          }
          leaf spf-max-wait {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<0-600000>;;Maximum wait time in milliseconds "
                +"for SPF calculations";
              range "0..600000";
            }
          }
        }
      }
    }

    // router ospf * / router-id
    leaf router-id {
      tailf:cli-full-command;
      tailf:info "Override configured router identifier (peers will reset)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Manually configured router identifier";
      }
    }
  }

  // router ospf * /
  // router ospf * vrf * /
  grouping router-ospf-grouping {

    // router ospf * / capability
    container capability {
      tailf:info "Enable specific OSPF feature";

      // router ospf * / capability vrf-lite
      leaf vrf-lite {
        tailf:info "Do not perform PE specific checks";
        type empty;
      }

      // router ospf * / no capability opaque
      leaf opaque {
        tailf:info "Opaque LSA";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospf * / no capability lls
      leaf lls {
        tailf:info "Link-local Signaling (LLS) support";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router ospf * / no capability transit
      leaf transit {
        tailf:info "Transit Area";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // router ospf * / no compatible rfc1583
    container compatible {
      tailf:info "OSPF compatibility list";
      leaf rfc1583 {
        tailf:info "compatible with RFC 1583";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router ospf * / distribute-list *
    uses router-distribute-list-grouping;

    // router ospf * / domain-id
    container domain-id {
      tailf:info "OSPF domain-id";
      choice domain-id-choice {
        case a {
          leaf ip-format {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
            }
          }
          container ip-format-secondary {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;OSPF domain ID in IP address format";
              }
            }
            leaf secondary {
              tailf:info "Secondary Domain-ID";
              type empty;
            }
          }
        }
        leaf Null {
          tailf:info "Null Domain-ID";
          tailf:cli-full-command;
          type empty;
        }
        container "type" {
          tailf:info "OSPF domain ID type in Hex format";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf type-leaf {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "0005" {
                tailf:info "Type 0x0005";
              }
              enum "0105" {
                tailf:info "Type 0x0105";
              }
              enum "0205" {
                tailf:info "Type 0x0205";
              }
              enum "8005" {
                tailf:info "Type 0x8005";
              }
            }
          }
          leaf "value" {
            tailf:info "OSPF domain ID value in Hex format";
            type string {
              tailf:info "Hex-data;;OSPF domain ID ext. community "
                +"value in Hex";
              pattern '[0-9a-fA-F]{12}';
            }
          }
        }
      }
    }

    // router ospf * / domain-tag
    leaf domain-tag {
      tailf:info "OSPF domain-tag";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;OSPF domain tag - 32-bit value";
        range "1..4294967295";
      }
    }

    // router ospf * / ignore
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving "
          +"LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }

    // router ospf * / ispf
    leaf ispf {
      tailf:info "Enable incremental SPF computation";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / limit
    container limit {
      tailf:info "Limit a specific OSPF feature";
      container retransmissions {
        tailf:info "LS update, DBD, and LS request retransmissions";
        tailf:cli-compact-syntax;
        leaf dc {
          tailf:info "Demand circuit retransmissions";
          type limit-dc-non-dc-type;
        }
        leaf non-dc {
          tailf:info "Non-demand-circuit retransmissions";
          type limit-dc-non-dc-type;
        }
      }
    }

    // router ospf * / local-rib-criteria
    container local-rib-criteria {
      tailf:info "Enable or disable usage of local RIB as route criteria";
      tailf:cli-compact-syntax;
      leaf forwarding-address {
        tailf:info "Local RIB used to validate external/NSSA "
          +"forwarding addresses";
        type empty;
      }
      leaf inter-area-summary {
        tailf:info "Local RIB used as criteria for inter-area summaries";
        type empty;
      }
      leaf nssa-translation {
        tailf:info "Local RIB used as criteria for NSSA translation";
        type empty;
      }
    }

    // router ospf * / max-metric router-lsa
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        presence true;
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        leaf summary-lsa {
          tailf:info "Override summary-lsa metric with max-metric value";
          type empty;
        }
        leaf summary-lsa-max-metric-value {
          when "../summary-lsa" {
            tailf:dependency "../summary-lsa";
          }
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
        leaf external-lsa {
          tailf:info "Override external-lsa metric with max-metric value";
          type empty;
        }
        leaf external-lsa-max-metric-value {
          when "../external-lsa" {
            tailf:dependency "../external-lsa";
          }
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-16777215>;;Overriding metric in "
              +"external-LSAs (default 16711680)";
            range "1..16777215";
          }
        }
        container on-startup {
          tailf:info "Set maximum metric temporarily after reboot";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice time-wait-for-bgp-choice {
            leaf seconds {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<5-86400>;;Time, in seconds, router-LSAs "
                  +"are originated with max-metric";
                range "5..86400";
              }
            }
            leaf wait-for-bgp {
              tailf:info "Let BGP decide when to originate router-LSA "
                +"with normal metric";
              type empty;
            }
          }
        }
      }
    }

    // router ospf * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router ospf * / mpls ldp
      container ldp {
        tailf:info "routing protocol commands for MPLS LDP";
        container autoconfig {
          tailf:info "Configure LDP automatic configuration";
          presence "Configure LDP automatic configuration";
          leaf area {
            tailf:info "Configure an OSPF area to run MPLS LDP";
            type ospf-area-type;
          }
        }
        container sync {
          tailf:info "Configure LDP-IGP Synchronization";
          presence "Configure LDP-IGP Synchronization";
        }
      }

      // router ospf * / mpls traffic-eng
      container traffic-eng {
        tailf:info "routing protocol commands for MPLS Traffic Engineering";

        // router ospf * / mpls traffic-eng router-id
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }

        // router ospf * / mpls traffic-eng area
        leaf area {
          tailf:info "configure an ospf area to run MPLS Traffic Engineering";
          tailf:cli-full-command;
          type ospf-area-type;
        }

        // router ospf * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "MPLS TE and PIM interaction";
          tailf:cli-full-command;
          type empty;
        }

        // router ospf * / mpls traffic-eng interface
        container interface {
          tailf:info "MPLS TE interface configuration for this OSPF process";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          container name {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
          leaf area {
            tailf:info "advertise MPLS TE information for this interface "+
              "into area";
            type uint32 {
              tailf:info "<0-0>;;OSPF area ID as a decimal value";
            }
          }
        }

        // router ospf * / mpls traffic-eng mesh-group *
        list mesh-group {
          tailf:info "Traffic Engineering Mesh-Group advertisement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "id area";
          leaf id {
            type uint32 {
              tailf:info "<0-4294967295>;;Mesh Group Id";
            }
          }
          leaf area {
            tailf:cli-expose-key-name;
            tailf:info "configure flooding scope as area";
            type ospf-area-type;
          }
          leaf interface {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key {
              tailf:cli-before-key 2;
            }
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }

    // router ospf * / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }

      // router ospf * / neighbor * / cost
      container cost-database-filter-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf cost {
          tailf:info "OSPF cost for point-to-multipoint neighbor";
          type uint32 {
            tailf:info "<1-65535>;;metric";
            range "1..65535";
          }
        }
        container database-filter {
          tailf:info "Filter OSPF LSA during synchronization and "
            +"flooding for point-to-multipoint neighbor";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          container all {
            tailf:info "Filter all LSA";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf out {
              tailf:info "Outgoing LSA";
              type empty;
            }
          }
        }
      }

      // router ospf * / neighbor * / poll-interval
      container poll-interval-priority-container {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        leaf poll-interval {
          tailf:info "OSPF dead-router polling interval";
          type uint32 {
            tailf:info "<0-65535>;;Seconds";
            range "0..65535";
          }

        }
        leaf priority {
          tailf:info "OSPF priority of non-broadcast neighbor";
          type uint32 {
            tailf:info "<0-255>;;Priority";
            range "0..255";
          }
        }
      }
    }

    // router ospf * / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;OSPF wild card bits";
        }
      }
      leaf area {
        tailf:info "Set the OSPF area ID";
        type ospf-area-type;
      }
    }

    // router ospf * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";
      presence true;
      container cisco {
        tailf:info "Cisco Non-stop forwarding";
        tailf:cli-delete-when-empty;
        presence true;
        container helper {
          tailf:info "helper support";
          presence true;
          leaf disable {
            tailf:info "disable helper support";
            tailf:cli-reset-container;
            type empty;
          }
        }
      }
      container ietf {
        tailf:info "IETF graceful restart";
        container helper {
          tailf:info "helper support";
          presence "helper support";
          leaf disable {
            tailf:info "disable helper support";
            tailf:cli-reset-container;
            tailf:cli-delete-container-on-delete;
            type empty;
          }
          leaf strict-lsa-checking {
            tailf:info "enable helper strict LSA checking";
            type empty;
          }
        }
      }
    }

    // router ospf * / prefix-priority high route-map
    container prefix-priority {
      tailf:info "OSPF prefix priority";
      container high {
        tailf:info "High prefix priority";
        leaf route-map {
          tailf:info "Prefix priority selection by route-map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router ospf * / prefix-suppression
    leaf prefix-suppression {
      tailf:info "OSPF prefix suppression";
      tailf:cli-full-command;
      type empty;
    }

    // router ospf * / process-min-time
    container process-min-time {
      tailf:info "Percentage of quantum to be used before releasing CPU";
      leaf percent {
        tailf:info "percent";
        type uint32 {
          range "1..100";
          tailf:info "<1-100>;;Minimum CPU quantum";
        }
      }
    }

    // router ospf * / traffic-share min across-interfaces
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }

    // router ospf * / shutdown
    leaf shutdown {
      tailf:info "Shutdown the OSPF protocol under the current instance";
      tailf:cli-boolean-no;
      type boolean;
    }

    // router ospf * / summary-address
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ip wildcard";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf wildcard {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }
      choice tag-no-advertise-choice {
        leaf tag {
          tailf:info "Set tag";
          tailf:cli-full-command;
          type uint32 {
            range "0..4294967295";
            tailf:info "<0-4294967295>;;32-bit tag value";
          }
        }
        leaf not-advertise {
          tailf:info "Do not advertise when translating OSPF type-7 LSA";
          type empty;
          tailf:cli-full-command;
        }
      }
    }

    // router ospf * / discard-route
    container discard-route {
      tailf:info "Enable or disable discard-route installation";
      tailf:cli-compact-syntax;
      presence true;
      leaf external {
        tailf:info "Discard route for redistributed summarised routes";
        type uint32 {
          tailf:info "<1-255>;;Administrative distance for "
            +"redistributed summarised routes";
          range "1..255";
        }
      }
      leaf internal {
        tailf:info "Discard route for summarised internal routes";
        type uint32 {
          tailf:info "<1-255>;;Administrative distance for "
            +"summarised internal routes";
          range "1..255";
        }
      }
    }

    // router ospf * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast-Reroute";

      // router ospf * / fast-reroute keep-all-paths
      leaf keep-all-paths {
        tailf:info "Keep LFA FRR audit trail";
        tailf:cli-full-command;
        type empty;
      }

      // router ospf * / fast-reroute per-prefix
      container per-prefix {
        tailf:info "Per-prefix LFA FRR parameters";

        // router ospf * / fast-reroute per-prefix enable
        container enable {
          tailf:info "Enable LFA Fast Reroute";

          // router ospf * / fast-reroute per-prefix enable area * prefix-priority
          list area {
            tailf:info "Area to enable LFA FRR in";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key area;
            leaf area {
              type ospf-area-type;
            }
            leaf prefix-priority {
              tailf:info "Priority of prefixes to be protected";
              type enumeration {
                enum "high" {
                  tailf:info "High priority prefixes";
                }
                enum "low" {
                  tailf:info "Low priority prefixes";
                }
              }
            }
          }

          // router ospf * / fast-reroute per-prefix enable prefix-priority
          leaf prefix-priority {
            tailf:info "Priority of prefixes to be protected";
            type enumeration {
              enum "high" {
                tailf:info "High priority prefixes";
              }
              enum "low" {
                tailf:info "Low priority prefixes";
              }
            }
          }
        }

        // router ospf * / fast-reroute per-prefix remote-lfa
        container remote-lfa {
          tailf:info "Remote LFA FastReroute parameters";
          leaf area {
            tailf:info "Area for remote LFA command";
            tailf:cli-full-command;
            type ospf-area-type;
          }
          leaf maximum-cost {
            tailf:info "Maximum distance to tunnel endpoint";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-16777214>;;Value of the maximum distance"
                +" to tunnel endpoint";
            }
          }
          leaf tunnel {
            tailf:info "Remote LFA tunnel type";
            tailf:cli-full-command;
            type enumeration {
              enum "mpls-ldp" {
                tailf:info "Enable remote LFA tunneling via MPLS";
              }
            }
          }
        }
      }
    }
  }

  grouping router-ospfv3-grouping {

    // router ospfv3 * / address-family [ipv4 | ipv6 | <vrf> ] summary-prefix *
    list summary-prefix {
      tailf:info "Configure IP summary prefix";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "prefix";
      leaf "prefix" {
        type union {
          type ios:ipv4-prefix;
          type ios:ipv6-prefix;
        }
      }
    }
  }


  grouping ospf-redistribute-match-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      type empty;
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
        range "0..4294967295";
      }
    }
  }

  // router * / redistribute * level-1
  // router * / redistribute * level-2
  // router * / redistribute * level-1-2
  grouping router-isis-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "IS-IS level-1 routes only";
        }
        enum level-1-2 {
          tailf:info "IS-IS level-1 and level-2 routes";
        }
        enum level-2 {
          tailf:info "IS-IS level-2 routes only";
        }
      }
    }
  }


  // router * / redistribute * route-map
  grouping router-ospf-route-map-grouping {
    leaf route-map {
      tailf:info "Route map reference";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router ospf * / redistribute *
  grouping router-ospf-redistribute-grouping {

    // router ospf * / redistribute *  metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<0-16777214>;;OSPF default metric";
      }
    }

    // router ospf * / redistribute *  metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum "1" {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum "2" {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
      default "2";
    }

    // router ospf * / redistribute * subnets
    leaf subnets {
      tailf:info "Consider subnets for redistribution into OSPF";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    // router ospf * / redistribute *  nssa-only
    leaf nssa-only {
      tailf:info "Limit redistributed routes to NSSA areas";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type empty;
    }

    // router ospf * / redistribute *  tag
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  // router rip / address-family ipv4 vrf *
  grouping router-rip-af-grouping {

    // router rip / no auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "1-32;;Number of paths";
        range "1..32";
      }
    }

    // router rip / neighbor *
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address";
        }
      }
    }

    // router rip / network *
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key ip;
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
    }

    // router rip / no validate-update-source
    leaf validate-update-source {
      tailf:info "Perform sanity checks against source address of "
        +"routing updates";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router rip / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }

    // router rip / default-metric
    leaf default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-4294967295>;;Default metric";
        range "1..4294967295";
      }
    }

    // router rip / distance
    container distance {
      tailf:info "Define an administrative distance";
      tailf:cli-compact-syntax;
      leaf distance-leaf {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "1-255;;Administrative distance";
          range "1..255";
        }
      }
      // router rip / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip mask";
        leaf number {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "1-255;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router rip / distribute-list *
    uses router-distribute-list-grouping;

    // router rip / offset-list *
    uses router-offset-list-grouping;

    // router rip / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router rip / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        presence true;
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        leaf as-no {
          tailf:cli-drop-node-name;
          type bgp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        // router rip / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2"+
              "|metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses router-rip-redistribute-grouping;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type isis-level-type;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence true;
        list iso-igrp-list {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-rip-redistribute-grouping;
        }
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence "Mobile routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence "On Demand stub Routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-rip-redistribute-grouping;
        uses redistribute-ospf-match-grouping;
      }

      // router rip / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        uses router-rip-redistribute-grouping;
      }

      // router rip / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-rip-redistribute-grouping;
      }
    }

    // router rip / timers
    container timers {
      tailf:info "Adjust routing timers";
      tailf:cli-incomplete-no;
      tailf:cli-compact-syntax;
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-no;
        leaf updates {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Interval between updates for RIP";
            range "1..4294967295";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Invalid";
            range "1..4294967295";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Holddown";
            range "1..4294967295";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Flush";
            range "1..4294967295";
          }
        }
        leaf sleep {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type uint32 {
            tailf:info "1-4294967295;;Sleep time, in milliseconds";
            range "1..4294967295";
          }
        }
      }
    }

    // router rip / version
    leaf version {
      tailf:info "Set routing protocol version";
      type uint8 {
        tailf:info "1-2;;rip version 1 or 2";
        range "1..2";
      }
    }

    // router rip / traffic-share min across-interfaces
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }
  }


  // router rip
  // router rip / address-family ipv4 unicast
  grouping router-rip-grouping {

    uses router-rip-af-grouping;

    // router rip / passive-interface
    uses passive-interface-grouping;

    // router rip / output-delay
    leaf output-delay {
      tailf:info "Interpacket delay for RIP updates";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "8-50;;Delay in milliseconds";
        range "8..50";
      }
    }

    // router rip / input-queue
    leaf input-queue {
      tailf:info "Specify input queue depth";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "0-1024;;queue depth";
        range "0..1024";
      }
    }

    // router rip / flash-update-threshold
    leaf flash-update-threshold {
      tailf:info "Specify flash update threshold in second";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-30>;;threshold in seconds";
        range "0..30";
      }
    }
  }

  grouping router-rip-redistribute-grouping {

    // router rip / redistribute * metric
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type union {
        type uint8 {
          tailf:info "<0-16>;;Default metric";
          range "0..16";
        }
        type enumeration {
          enum transparent {
            tailf:info "Transparently redistribute metric";
          }
        }
      }
    }

    // router rip / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  grouping router-eigrp-redistribute-grouping {

    container metric {
      tailf:info "Metric for redistributed routes";
      tailf:cli-break-sequence-commands;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth metric in Kbits per second";
        }
      }
      leaf delay-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<0-4294967295>;;EIGRP delay metric, "+
            "in 10 microsecond units";
        }
      }
      leaf reliability-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;EIGRP reliability metric where "+
            "255 is 100% reliable";
        }
      }
      leaf effective-bandwidth-metric {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;EIGRP Effective bandwidth metric (Loading) "
            +"where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu-bytes {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;EIGRP MTU of the path";
          range "1..65535";
        }
      }
    }

    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router eigrp * /
  // router eigrp * / address-family ipv4 / topology base /
  grouping router-eigrp-grouping {

    // router eigrp * / metric
    container metric {
      tailf:info "Modify metrics and parameters for advertisement";

      // router eigrp * / metric maximum-hops
      leaf maximum-hops {
        tailf:info "Advertise greater than <hops> as unreachable";
        type uint8 {
          tailf:info "<1-255>;;Hop count";
          range "1..255";
        }
      }

      // router eigrp * / metric weights
      container weights {
        tailf:info "Modify metric coefficients";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf tos {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-8>;;Type (Only TOS 0 supported)";
            range "0..8";
          }
        }
        leaf k1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K1";
          }
        }
        leaf k2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K2";
          }
        }
        leaf k3 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K3";
          }
        }
        leaf k4 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;K4";
          }
        }
        leaf k5 {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-255>;;K5";
          }
        }
      }
    }

    // router eigrp * / network *
    container network-ip {
      tailf:cli-drop-node-name;
      list network {
        tailf:info "Enable routing on an IP network";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip;
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network number";
          }
        }
      }
    }
    list network {
      tailf:info "Enable routing on an IP network";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Network number";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;EIGRP wild card bits";
        }
      }
    }

    // router eigrp * / neighbor *
    container neighbor {
      tailf:info "Specify a neighbor router";
      list neighbor-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address interface";
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "/ios:interface"; // NESTED
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
      }
    }

    // router eigrp * / eigrp
    container eigrp {
      tailf:info "EIGRP specific commands";

      // router eigrp * / eigrp router-id
      leaf router-id {
        tailf:info "router id for this EIGRP process";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;EIGRP Router-ID in IP address format";
        }
      }

      // router eigrp * / eigrp stub
      container stub {
        tailf:info "Set address-family in stubbed mode";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf connected {
          tailf:info "Do advertise connected routes";
          type empty;
        }
        leaf static {
          tailf:info "Do advertise static routes";
          type empty;
        }
        leaf summary {
          tailf:info "Do advertise summary routes";
          type empty;
        }
        leaf redistributed {
          tailf:info "Do advertise redistributed routes";
          type empty;
        }
      }

      // router eigrp * / eigrp stub-site
      leaf stub-site {
        tailf:info "Set address-family in stub-site mode";
        tailf:cli-full-command;
        type string {
          tailf:info "ASN:nn or 4BASN:nn Stub-Site ID in aa:nn format";
          pattern "[0-9]+:[0-9]+";
        }
      }
    }
  }

  // router eigrp * /
  // router eigrp * / address-family ipv4 / topology base /
  grouping router-eigrp-base-grouping {

    // router eigrp * / distribute-list *
    uses router-distribute-list-grouping;

    // router eigrp * / default-metric
    container default-metric {
      tailf:info "Set metric of redistributed routes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf bandwidth {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth in Kbits per second";
          range "1..4294967295";
        }
      }
      leaf delay {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<0-4294967295>;;delay metric in 10 microsecond units";
          range "0..4294967295";
        }
      }
      leaf reliability {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Reliability metric where 255 is 100% reliable";
          range "0..255";
        }
      }
      leaf loading  {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
          range "1..255";
        }
      }
      leaf mtu {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;Maximum Transmission Unit metric of the path";
          range "1..65535";
        }
      }
    }

    // router eigrp * / summary-metric *
    list summary-metric {
      tailf:info "Specify summary to apply metric/filtering";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key "prefix";
      leaf "prefix" {
        type ios:ipv4-prefix {
          tailf:info "A.B.C.D/nn;;Summary <network>/<length>, "+
            "e.g., 192.168.0.0/16";
        }
      }
      leaf bandwidth {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Bandwidth metric in Kbits per second";
        }
      }
      leaf delay {
        when "../bandwidth" {
          tailf:dependency "../bandwidth";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;delay metric in 10 microsecond units";
        }
      }
      leaf reliability {
        when "../delay" {
          tailf:dependency "../delay";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;reliability metric where 255 is 100% reliable";
        }
      }
      leaf load {
        when "../reliability" {
          tailf:dependency "../reliability";
        }
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Effective bandwidth metric (Loading) where 255 is 100% loaded";
        }
      }
      leaf mtu {
        when "../load" {
          tailf:dependency "../load";
        }
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;MTU of the path";
          range "1..65535";
        }
      }
      leaf distance {
        tailf:info "Set administrative distance for summary route";
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
    }

    // router eigrp * / offset-list *
    uses router-offset-list-grouping;

    // router eigrp * / redistribute
    container redistribute {
      tailf:info "Redistribute IPv4 routes from another routing protocol";

      // router eigrp * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute bgp
      container bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf as-no {
          tailf:cli-drop-node-name;
          type bgp-as-no-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        presence true;
        // router eigrp * / redistribute isis *
        list isis-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            tailf:cli-disallow-value "level-1|level-2|level-1-2"+
              "|metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
          uses router-eigrp-redistribute-grouping;
        }
        leaf level {
          tailf:cli-drop-node-name;
          type isis-level-type;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence true;
        list iso-igrp-list {
          tailf:info "Border Gateway Protocol (BGP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          key name;
          leaf name {
            tailf:cli-disallow-value "metric|route-map";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          uses router-eigrp-redistribute-grouping;
        }
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses redistribute-ospf-match-grouping;
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        uses router-eigrp-redistribute-grouping;
      }

      // router eigrp * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence true;
        uses router-eigrp-redistribute-grouping;
      }
    }

    // router eigrp * / distance
    container distance {
      tailf:info "Define an administrative distance";

      // router eigrp * / distance eigrp
      container eigrp {
        tailf:info "Set distance for internal and external routes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf internal-distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for internal routes";
            range "1..255";
          }
        }
        leaf external-distance {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for external routes";
            range "1..255";
          }
        }
      }

      // router eigrp * / distance *
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf weight {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }
    }

    // router eigrp * / auto-summary
    leaf auto-summary {
      tailf:info "Enable automatic network number summarization";
      tailf:cli-full-command;
      type empty;
    }

    // router eigrp * / passive-interface
    uses passive-interface-grouping;
  }


  // router eigrp * / address-family ipv4
  grouping router-eigrp-af-virtual-instance-grouping {

    // router eigrp * / address-family ipv4 / af-interface *
    list af-interface {
      tailf:cli-break-sequence-commands;
      tailf:info "Enter Address Family interface configuration";
      tailf:cli-mode-name "config-router-af-interface";
      tailf:cli-exit-command "exit-af-interface" {
        tailf:info "Exit from Address Family Interface configuration";
      }
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // router eigrp * / address-family ipv4 / af-interface * / summary-address
      list summary-address {
        tailf:info "Perform address summarization";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "ip mask";
        leaf ip {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary network address";
          }
        }
        leaf mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Summary network mask";
          }
        }
        leaf leak-map {
          tailf:info "Allow dynamic prefixes based on the leak-map";
          type string {
            tailf:info "WORD;;leak-map name";
          }
        }
      }
      container summary-address-ipv6 {
        tailf:cli-drop-node-name;
        list summary-address {
          tailf:info "Perform address summarization";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key ipv6;
          leaf ipv6 {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;Summary network prefix";
            }
          }
          leaf leak-map {
            tailf:info "Allow dynamic prefixes based on the leak-map";
            type string {
              tailf:info "WORD;;leak-map name";
            }
          }
        }
      }

      // router eigrp * / address-family ipv4 / af-interface * / authentication
      container authentication {
        tailf:info "authentication subcommands";

        // router eigrp * / address-family ipv4 / af-interface * / authentication mode md5
        container mode {
          tailf:info "authentication mode";
          leaf md5 {
            tailf:info "Keyed message digest";
            type empty;
          }
        }

        // router eigrp * / address-family ipv4 / af-interface * / authentication key-chain
        leaf key-chain {
          tailf:info "key-chain";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;name of key-chain";
          }
        }
      }

      // router eigrp * / address-family ipv4 / af-interface * / hello-interval
      leaf hello-interval {
        tailf:info "Configures hello interval";
        type uint16 {
          tailf:info "<1-65535>;;Seconds between hello transmissions";
          range "1..65535";
        }
      }

      // router eigrp * / address-family ipv4 / af-interface * / hold-time
      leaf hold-time {
        tailf:info "Configures hold time";
        type uint16 {
          tailf:info "<1-65535>;;Seconds before neighbor is considered down";
          range "1..65535";
        }
      }

      // router eigrp * / address-family ipv4 / af-interface * / no next-hop-self
      leaf next-hop-self {
        tailf:info "Configures EIGRP next-hop-self";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router eigrp * / address-family ipv4 / af-interface * / passive-interface
      // router eigrp * / address-family ipv4 / af-interface * / no passive-interface
      leaf passive-interface {
        tailf:info "Suppress address updates on an interface";
        tailf:cli-show-no;
        type empty;
      }

      // router eigrp * / address-family ipv4 / af-interface * / no split-horizon
      leaf split-horizon {
        tailf:info "Perform split horizon";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // router eigrp * / address-family ipv4 / af-interface * / stub-site wan-interface
      container stub-site {
        tailf:info "Stub-Site";
        leaf wan-interface {
          tailf:info "Wan Interface";
          type empty;
        }
      }
    }

    // router eigrp * / address-family ipv4 / topology base
    container topology {
      tailf:info "Topology configuration mode";
      container "base" {
        tailf:info "Base Topology";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-af-topology";
        tailf:cli-exit-command "exit-af-topology" {
          tailf:info "Exit from Address Family Topology configuration mode";
        }
        presence true;

        // router eigrp * / address-family ipv4 / topology base / redistribute
        uses router-eigrp-base-grouping;
      }
    }

    // router eigrp * / address-family ipv4 / network *
    // router eigrp * / address-family ipv4 / eigrp
    uses router-eigrp-grouping;
  }


  // router/isis grouping
  grouping narrow-wide-transition-grouping {
    leaf transition {
      tailf:info "Accept both styles of TLVs during transition";
      type empty;
    }
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      type isis-level-type;
    }
  }

  // router/isis grouping
  grouping spf-intervals-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<1-120>;;Interval between consecutive SPFs in seconds";
        range "1..120";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Initial wait before first SPF in milliseconds";
        range "1..120000";
      }
    }
    leaf minimum-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        tailf:info "<1-120000>;;Minimum wait between first and "
          +"second SPF in milliseconds";
        range "1..120000";
      }
    }
  }

  // router/isis grouping
  grouping router-isis-authenticate-snp-grouping {
    leaf authenticate {
      tailf:info "Authentication";
      tailf:cli-incomplete-command;
      type empty;
    }
    leaf snp {
      tailf:info "SNP PDUs";
      type enumeration {
        enum send-only {
          tailf:info "Send but do not check PDUs on receiving";
        }
        enum validate {
          tailf:info "Send and check PDUs on receiving";
        }
      }
    }
  }

  // router/isis grouping
  grouping lsp-gen-interval-grouping {
    leaf interval {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120";
        tailf:info "<1-120>;;Interval in seconds";
      }
    }
    leaf initial-wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Initial wait in milliseconds";
      }
    }
    leaf wait {
      tailf:cli-drop-node-name;
      type uint32 {
        range "1..120000";
        tailf:info "<1-120000>;;Wait between first and second "
          +"lsp generation in milliseconds";
      }
    }
  }

  // router/isis grouping
  grouping set-overload-bit-suppress-grouping {
    leaf external {
      tailf:info "If overload-bit set, don't advertise "
        +"IP prefixes learned from other protocols";
      tailf:cli-break-sequence-commands;
      type empty;
    }
    leaf interlevel {
      tailf:info "If overload-bit set, don't advertise "
        +"IP prefixes learned from another ISIS level";
      type empty;
    }
  }


  // router/isis grouping
  grouping authentication-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type authentication-level-type;
    }
  }

  // router/isis grouping
  grouping redist-level-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      tailf:cli-break-sequence-commands;
      type isis-level-type;
    }
  }


  grouping router-isis-redistribute-grouping {

    // router isis * / redistribute * metric
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }

    // router isis * / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    // router isis * / redistribute * metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "Set IS-IS External metric type";
        }
        enum internal {
          tailf:info "Set IS-IS Internal metric type";
        }
      }
      default internal;
    }

    // router isis * / redistribute * level-1
    // router isis * / redistribute * level-1-2
    uses router-isis-level-grouping;
  }


  grouping router-isis-af-redistribute-grouping {

    // router isis * / address-family ipv6 / redistribute * metric
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }

    // router isis * / address-family ipv6 / redistribute * metric-type
    leaf metric-type {
      tailf:info "OSPF/IS-IS exterior metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "Set IS-IS External metric type";
        }
        enum internal {
          tailf:info "Set IS-IS Internal metric type";
        }
      }
    }

    // router isis * / address-family ipv6 / redistribute * level-1
    // router isis * / address-family ipv6 / redistribute * level-1-2
    uses router-isis-level-grouping;

    // router isis * / address-family ipv6 / redistribute * route-map
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }

    // router isis * / address-family ipv6 / redistribute * include-connected
    leaf include-connected {
      tailf:info "Include connected";
      type empty;
    }
  }


  // router/isis grouping
  grouping isis-redist-ospf-match-grouping {
    uses redist-level-grouping;
    leaf metric {
      tailf:info "ISIS default metric";
      type uint32 {
        tailf:info "<0-4294967295>;;ISIS default metric";
        range "0..4294967295";
      }
    }
    leaf route-map {
      tailf:info "Route map reference";
      type string {
        tailf:info "WORD;;Pointer to route-map entries";
      }
    }
  }

  // router isis
  // router isis *
  // interface * / isis
  grouping router-isis-interface-grouping {

    // router isis * / authentication
    container authentication {
      tailf:info "ISIS authentication for LSPs";

      // router isis * / authentication mode
      container mode {
        tailf:info "Authentication mode";
        container md5 {
          tailf:info "Keyed message digest";
          presence true;
          uses authentication-level-grouping;
        }
        container text {
          tailf:info "Clear text password";
          presence true;
          uses authentication-level-grouping;
        }
      }

      // router isis * / authentication key-chain
      container key-chain {
        tailf:info "Authentication key-chain";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of key-chain";
          }
        }
        uses authentication-level-grouping;
      }

      // router isis * / authentication send-only
      container send-only {
        tailf:info "Authentication send only, receive ignore";
        presence true;
        uses authentication-level-grouping;
      }
    }
  }

  // router isis
  // router isis *
  // router isis * / address-family ipv6 unicast
  grouping router-isis-af-grouping {

    // router isis * / no adjacency-check
    leaf adjacency-check {
      tailf:info "Check ISIS neighbor protocol support";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router isis * / set-overload-bit
    container set-overload-bit {
      tailf:info "Signal other routers not to use us in SPF";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;

      choice set-overload-bit-choice {

        // router isis * / set-overload-bit on-startup
        container on-startup {
          tailf:info "Set overload-bit only temporarily after reboot";
          choice on-startup-choice {
            container time {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf time {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise "
                    +"ourself as overloaded after reboot";
                  range "5..86400";
                }
              }
              leaf suppress {
                tailf:info "If overload-bit set, suppress the following "
                  +"types of IP prefixes";
                tailf:cli-incomplete-command;
                type empty;
              }
              uses set-overload-bit-suppress-grouping;
            }
            container wait-for-bgp {
              tailf:info "Let BGP decide when to unset the overload bit";
              presence "Let BGP decide when to unset the overload bitW";
              container suppress {
                tailf:info "If overload-bit set, suppress the following "
                  +"types of IP prefixes";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                uses set-overload-bit-suppress-grouping;
              }
            }
          }
        }

        // router isis * / set-overload-bit suppress
        container suppress {
          tailf:info "If overload-bit set, suppress the following types of IP prefixes";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses set-overload-bit-suppress-grouping;
        }
      }
    }

    // router isis * / spf-interval
    container spf-interval {
      tailf:info "Minimum interval between SPF calculations";
      tailf:cli-compact-syntax;
      choice spf-interval-choice {
        list level-1-2 {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            type enumeration {
              enum level-1 {
                tailf:info "Set interval for level 1 only";
              }
              enum level-2 {
                tailf:info "Set interval for level 2 only";
              }
            }
          }
          uses spf-intervals-grouping;
        }
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses spf-intervals-grouping;
        }
      }
    }

    // router isis * / prc-interval
    container prc-interval {
      tailf:info "Minimum interval between partial route calculations";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interval {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120>;;PRC interval in seconds";
          range "1..120";
        }
      }
      leaf initial-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Initial wait for PRC in milliseconds";
          range "1..120000";
        }
      }
      leaf minimum-wait {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-120000>;;Minimum wait between first and "
            +"second PRC in milliseconds";
          range "1..120000";
        }
      }
    }

    // router isis * / metric-style
    container metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      choice metric-style-choice {
        container narrow {
          tailf:info "Use old style of TLVs with narrow metric";
          presence true;
          uses narrow-wide-transition-grouping;
        }
        container transition {
          tailf:info "Send and accept both styles of TLVs during transition";
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type isis-level-type;
          }
        }
        container wide {
          tailf:info "Use new style of TLVs to carry wider metric";
          presence true;
          uses narrow-wide-transition-grouping;
        }
      }
    }

    // router isis * / metric
    choice metric-choice {
      case default-case {
        container metric {
          tailf:info "Set ISIS metric for all interfaces";
          tailf:cli-diff-dependency "../metric-style";
          leaf "default" {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
          }
        }
      }
      case level-case {
        container metric-level {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../metric-style";
          list metric {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key level;
            leaf level {
              type enumeration {
                enum level-1 {
                  tailf:info "Apply metric to level-1 links";
                }
                enum level-2 {
                  tailf:info "Apply metric to level-2 links";
                }
              }
            }
            leaf "default" {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type uint32 {
                tailf:info "<1-16777214>;;Default metric";
                range "1..16777214";
              }
            }
          }
        }
      }
    }

    // router isis * / maximum-paths
    leaf maximum-paths {
      tailf:info "Forward packets over multiple paths";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-32>;;Number of paths";
        range "1..32";
      }
    }

    // router isis * / default-information
    container default-information {
      tailf:info "Control distribution of default information";
      tailf:cli-incomplete-no;
      container originate {
        tailf:info "Distribute a default route";
        presence true;
        leaf route-map {
          tailf:info "Route-map reference";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }
    }
  }

  // router isis
  // router isis *
  grouping router-isis-grouping {

    // router isis * / protocol shutdown
    container protocol {
      tailf:info "Set protocol's administrative state";
      leaf shutdown {
        tailf:info "Set protocol's administrative state to disable";
        type empty;
      }
    }

    // router isis * / max-area-addresses
    leaf max-area-addresses {
      tailf:info "Allow configuration of more manual area addresses";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<3-254>;;Max number of manual area addresses";
        range "3..254";
      }
    }

    // router isis * / net *
    list net {
      tailf:info "A Network Entity Title for this process (OSI only)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key tag;
      leaf tag {
        type string {
          tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
        }
      }
    }

    // router isis * / is-type
    leaf is-type {
      tailf:info "IS Level for this routing process (OSI only)";
      tailf:cli-full-command;
      type enumeration {
        enum level-1 {
          tailf:info "Act as a station router only";
        }
        enum level-1-2 {
          tailf:info "Act as both a station router and an area router";
        }
        enum level-2-only {
          tailf:info "Act as an area router only";
        }
      }
    }

    // router isis * / advertise
    container advertise {
      tailf:info "Control which IP routes flow in L1 and L2 LSPs";
      leaf passive-only {
        tailf:info "only interface address of passive interfaces";
        type empty;
      }
    }

    // router isis * / authentication
    uses router-isis-interface-grouping;

    // router isis * / area-password
    container area-password {
      tailf:info "Configure the authentication password for an area";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Area password";
        }
      }
      uses router-isis-authenticate-snp-grouping;
    }

    // router isis * / ispf
    container ispf {
      tailf:info "Configure execution of incremental SPF";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Do incremental SPF for level-1";
          }
          enum level-1-2 {
            tailf:info "Do incremental SPF for both levels";
          }
          enum level-2 {
            tailf:info "Do incremental SPF for level-2";
          }
        }
      }
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1..600";
          tailf:info "<1-600>;;Number of seconds before "
            +"activating incremental-spf";
        }
      }
    }

    // router isis * / fast-flood
    container fast-flood {
      tailf:info "Flood LSPs (that triggered SPF) before running SPF";
      presence "Flood LSPs (that triggered SPF) before running SPF";
      leaf number {
        tailf:cli-drop-node-name;
        type uint32 {
          range "1..15";
          tailf:info "<1-15>;;number of LSPs to be flooded "
            +"before starting SPF";
        }
      }
    }

    // router isis * / ip route
    container ip {
      tailf:info "IP specific commands";
      container route {
        tailf:info "ISIS IP routes";
        container priority {
          tailf:info "Assign priority to IP prefixes";
          container high {
            tailf:info "Assign high priority to important IP "
              +"prefixes in ISIS IP local RIB";
            leaf tag {
              tailf:info "Assign high priority to IP prefixes "
                +"with a specific route tag";
              type uint32 {
                range "1..4294967295";
                tailf:info "<1-4294967295>;;tag value";
              }
            }
          }
        }
      }
    }

    // router isis * / set-attached-bit
    container set-attached-bit {
      tailf:info "Conditionally advertise us as attached to L2";
      leaf route-map {
        tailf:info "Route-map reference";
        type string {
          tailf:info "WORD;;Route map name";
        }
      }
    }

    // router isis * / max-lsp-lifetime
    leaf max-lsp-lifetime {
      tailf:info "Set maximum LSP lifetime";
      tailf:cli-full-command;
      type uint32 {
        range "1..65535";
        tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
      }
    }

    // router isis * / lsp-refresh-interval
    leaf lsp-refresh-interval {
      tailf:info "Set LSP refresh interval";
      tailf:cli-full-command;
      type uint32 {
        range "1..65535";
        tailf:info "<1-65535>;;LSP refresh time in seconds";
      }
    }

    // router isis * / lsp-gen-interval
    container lsp-gen-interval {
      tailf:info "Minimum interval between regenerating same LSP";
      choice lsp-gen-interval-choice {
        container intervals {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses lsp-gen-interval-grouping;
        }
        container intervals-levels {
          tailf:cli-drop-node-name;
          container intervals-level-1 {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf level-1 {
              tailf:info "Set interval for level 1 only";
              type empty;
            }
            uses lsp-gen-interval-grouping;
          }
          container intervals-level-2 {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf level-2 {
              tailf:info "Set interval for level 2 only";
              type empty;
            }
            uses lsp-gen-interval-grouping;
          }
        }
      }
    }

    // router isis * / use external-metrics
    container use {
      tailf:info "Use different algorithms during SPF";
      leaf external-metrics {
        tailf:info "Honour external metrics during SPF";
        type empty;
      }
    }

    // router isis * / no ignore-lsp-errors
    leaf ignore-lsp-errors {
      tailf:info "Ignore LSPs with bad checksums";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // router isis * / no hostname dynamic
    container hostname {
      tailf:info "Dynamic hostname for IS-IS";
      leaf dynamic {
        tailf:info "Dynamic hostname";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // router isis * / log-adjacency-changes
    container log-adjacency-changes {
      tailf:info "Log changes in adjacency state";
      presence true;
      leaf all {
        tailf:info "Include changes generated by non-IIH event";
        type empty;
      }
    }

    // router isis * / partition avoidance
    container partition {
      tailf:info "CLNS area partition";
      leaf avoidance {
        tailf:info "Withdraw area prefix if partition detected";
        type empty;
      }
    }

    // router isis * / lsp-mtu
    leaf lsp-mtu {
      tailf:info "Set maximum LSP size";
      tailf:cli-full-command;
      type uint32 {
        range "128..4352";
        tailf:info "<128-4352>;;Max LSP size in bytes";
      }
    }

    // router isis * / lsp-full
    container lsp-full {
      tailf:info "If we run out of LSP fragments";
      container suppress {
        tailf:info "suppress the following types of IP prefixes";
        choice lsp-full-choince {
          container external-interlevel-container {
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            leaf external {
              tailf:info "don't advertise IP prefixes learned "
                +"from other protocols";
              type empty;
            }
            leaf interlevel {
              tailf:info "don't advertise IP prefixes learned "
                +"from another ISIS level";
              type empty;
            }
          }
          leaf none {
            tailf:info "don't suppress any prefixes";
            type empty;
          }
        }
      }
    }

    // router isis * / update-queue-depth
    leaf update-queue-depth {
      tailf:info "Set Update process queue depth";
      type uint32 {
        tailf:info "<1-2147483647>;;Max queue depth";
        range "1..2147483647";
      }
    }

    // router isis * / nsf
    container nsf {
      tailf:info "Non-stop forwarding";

      // router isis * / nsf cisco
      leaf cisco {
        tailf:info "Checkpoint method";
        type empty;
      }

      // router isis * / nsf ietf
      leaf ietf {
        tailf:info "IETF method";
        type empty;
      }
    }

    // router isis * / bfd all-interfaces
    container bfd {
      tailf:info "BFD configuration commands";
      leaf all-interfaces {
        tailf:info "Enable BFD on all interfaces";
        type empty;
      }
    }

    // router isis * / distance *
    container distance {
      tailf:info "Define an administrative distance";

      // router isis * / distance * ip
      container distance-ip {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip {
          tailf:info "Distance applied for IP derived routes";
          type empty;
        }
      }

      // router isis * / distance * <ip-address> <wildcard-bits>
      list distance-network-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Wildcard bits";
          }
        }
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
      }

      // router isis * / distance * clns
      container distance-clns {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf distance {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;OSPF Administrative distance";
            range "1..255";
          }
        }
        leaf clns {
          tailf:info "Distance applied for CLNS derived routes";
          type empty;
        }
      }
    }

    // router isis * / domain-password
    container domain-password {
      tailf:info "Set the authentication password for a routing domain";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Routing domain password";
        }
      }
      uses router-isis-authenticate-snp-grouping;
    }

    choice hello-padding-choice {
      // router isis * / hello padding
      // router isis * / no hello padding
      container hello {
        tailf:info "Pad ISIS hello PDUs to full MTU";
        leaf padding {
          tailf:info "Pad hello PDU";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // router isis * / hello padding multi-point
      // router isis * / hello padding point-to-point
      container conf {
        tailf:cli-drop-node-name;
        container hello {
          tailf:info "Pad ISIS hello PDUs to full MTU";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          leaf padding {
            tailf:info "Pad hello PDU";
            type enumeration {
              enum multi-point {
                tailf:info "Pad LAN hello PDUs";
              }
              enum point-to-point {
                tailf:info "Pad point-to-point hello PDUs";
              }
            }
          }
        }
      }
    }

    // router isis * / traffic-share
    container traffic-share {
      tailf:info "How to compute traffic share over alternate paths";
      container min {
        tailf:info "All traffic shared among min metric paths";
        leaf across-interfaces {
          tailf:info "Use different interfaces for equal-cost paths";
          type empty;
        }
      }
    }

    // router isis * / microloop avoidance
    container microloop {
      tailf:info "Enable microloop protection configuration commands";
      container avoidance {
        tailf:info "Enable local microloop avoidance";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        choice avoidance-choice {
          // router isis * / microloop avoidance protected
          leaf protected {
            tailf:info "Microloop avoidance for protected link or prefix only";
            type empty;
          }
          // router isis * / microloop avoidance disable
          leaf disable {
            tailf:info "Disable Microloop avoidance";
            type empty;
          }
        }
      }
    }

    // router isis * / segment-routing mpls
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";
      leaf mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        type empty;
      }
    }

    // router isis * / fast-reroute
    container fast-reroute {
      tailf:info "Configure Fast-Reroute";

      // router isis * / fast-reroute per-prefix
      container per-prefix {
        tailf:info "Enable Fast-Reroute Per-Prefix";

        // router isis * / fast-reroute per-prefix level-1
        container level-1 {
          tailf:info "Apply to level-1";
          choice level-choice {
            leaf route-map {
              tailf:info "route-map for selecting primary paths for protection";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            leaf all {
              tailf:info "Enable Fast-Reroute for primary paths";
              type empty;
            }
          }
        }

        // router isis * / fast-reroute per-prefix level-2
        container level-2 {
          tailf:info "Apply to level-2";
          choice level-choice {
            leaf route-map {
              tailf:info "route-map for selecting primary paths for protection";
              type string {
                tailf:info "WORD;;route-map name";
              }
            }
            leaf all {
              tailf:info "Enable Fast-Reroute for primary paths";
              type empty;
            }
          }
        }
      }

      // router isis * / fast-reroute remote-lfa
      container remote-lfa {
        tailf:info "Configuring fast-reroute remote-lfa";
        // router isis * / fast-reroute remote-lfa level-1
        container level-1 {
          tailf:info "Apply to level-1";
          container mpls-ldp {
            tailf:info "Use mpls-ldp tunnel type";
            tailf:cli-delete-when-empty;
            presence true;
            leaf maximum-metric {
              tailf:info "maximum metric to reach release node";
              type uint32 {
                tailf:info "<1-4294967295>;;metric value";
              }
            }
          }
        }
        // router isis * / fast-reroute remote-lfa level-2
        container level-2 {
          tailf:info "Apply to level-2";
          container mpls-ldp {
            tailf:info "Use mpls-ldp tunnel type";
            tailf:cli-delete-when-empty;
            presence true;
            leaf maximum-metric {
              tailf:info "maximum metric to reach release node";
              type uint32 {
                tailf:info "<1-4294967295>;;metric value";
              }
            }
          }
        }
      }
    }

    // router isis * / mpls
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";

      // router isis * / mpls ldp sync
      container ldp {
        tailf:info "routing protocol commands for MPLS LDP";
        leaf sync {
          tailf:info "Configure LDP-IGP Synchronization";
          type empty;
        }
      }

      // router isis * / mpls traffic-eng
      container traffic-eng {
        tailf:info "routing protocol commands for MPLS Traffic Engineering";

        // router isis * / mpls traffic-eng level-1
        leaf level-1 {
          tailf:info "Run MPLS TE on IS-IS level 1 only";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng level-2
        leaf level-2 {
          tailf:info "Run MPLS TE on IS-IS level 2 only";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng multicast-intact
        leaf multicast-intact {
          tailf:info "MPLS TE and PIM interaction";
          tailf:cli-full-command;
          type empty;
        }

        // router isis * / mpls traffic-eng router-id
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }

        // router isis * / mpls traffic-eng scanner
        container scanner {
          tailf:info "Timer parameters for TE database";
          presence "Timer parameters for TE database";
          tailf:cli-compact-syntax;
          leaf interval {
            tailf:info "time (secs) between LSPDB walks for TE";
            type uint32 {
              range "1..60";
              tailf:info "<1-60>;;interval between LSPDB walks "
                +"for TE TLVs extraction";
            }
          }
          leaf max-flash {
            tailf:info "Number of ISIS LSPs to be processed with no delay";
            type uint32 {
              range "0..200";
              tailf:info "<0-200>;;Max. number of LSPs ISIS may send to "
                +"TE db without delay";
            }
          }
        }
      }
    }

    // router isis * / passive-interface
    uses passive-interface-grouping;

    // router isis * / distribute-list
    uses router-distribute-list-grouping;

    // router isis * / redistribute
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";

      // router isis * / redistribute maximum-prefix
      container maximum-prefix {
        tailf:info "Maximum number of prefixes redistributed to protocol";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of IP "
              +"prefixes redistributed";
            range "1..4294967295";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-break-sequence-commands;
          type uint32 {
            tailf:info "<1-100>;;Threshold value (%) at which to "
              +"generate a warning message";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning message when limit is exceeded";
          tailf:cli-full-command;
          type empty;
        }
        leaf withdraw {
          tailf:info "Withdraw redistibuted prefixes";
          tailf:cli-full-command;
          type empty;
        }
      }

      // router isis * / redistribute connected
      container connected {
        tailf:info "Connected";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Connected";
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute static
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence "Static routes";
        // router isis * / redistribute static clns
        container clns {
          tailf:info "Redistribution of BGP NSAP routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        // router isis * / redistribute static ip
        container ip {
          tailf:info "Redistribution of IP static routes";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          uses router-isis-redistribute-grouping;
        }
      }

      // router isis * / redistribute odr
      container odr {
        tailf:info "On Demand stub Routes";
        tailf:cli-compact-syntax;
        presence "On Demand stub Routes";
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute rip
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        presence "Routing Information Protocol (RIP)";
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute bgp *
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key as-no;
        leaf as-no {
          tailf:cli-suppress-range;
          type bgp-as-no-type;
        }
        // router isis * / redistribute bgp * clns
        container clns {
          tailf:info "Redistribution of BGP NSAP routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses redistribute-ospf-match-grouping;
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute isis
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-compact-syntax;
        list isis-area-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key area-tag;
          leaf area-tag {
            tailf:cli-disallow-value "ip";
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          // router isis * / redistribute isis * ip
          leaf ip {
            tailf:info "Redistribution of IP routes between levels "+
              "or processes";
            type empty;
          }
          // router isis * / redistribute isis * metric
          leaf metric {
            tailf:info "ISIS default metric";
            type uint32 {
              tailf:info "<0-4294967295>;;ISIS default metric";
              range "0..4294967295";
            }
          }
          // router isis * / redistribute isis * route-map
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }

        // router isis * / redistribute isis ip *
        list ip {
          tailf:info "Redistribution of IP routes between levels";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key "from into";
          leaf from {
            type enumeration {
              enum level-1 {
                tailf:info "Inter-area routes from level-1";
              }
              enum level-2 {
                tailf:info "Inter-area routes from level-2";
              }
            }
          }
          leaf into {
            tailf:info "from level-n into level-m";
            tailf:cli-expose-key-name;
            type enumeration {
              enum level-1 {
                tailf:info "Inter-area routes from level-1";
              }
              enum level-2 {
                tailf:info "Inter-area routes from level-2";
              }
            }
          }
          leaf distribute-list {
            tailf:info "select routes";
            type uint8 {
              tailf:info "<100-199>;;IP extended acces-list number";
              range "100..199";
            }
          }
          leaf route-map {
            tailf:info "Route map for route matching";
            type string {
              tailf:info "WORD;;Name of the route-map";
            }
          }
        }
      }

      // router isis * / redistribute eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key as-no;
        leaf as-no {
          type eigrp-as-no-type;
        }
        uses router-isis-redistribute-grouping;
      }

      // router isis * / redistribute iso-igrp
      container iso-igrp {
        tailf:info "IGRP for OSI networks";
        presence "IGRP for OSI networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        choice iso-igrp-choice {
          container area-tag-route-map-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf area-tag {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "route-map";
              type string {
                tailf:info "WORD;;ISO routing area tag";
              }
            }
            leaf route-map {
              tailf:info "Route map reference";
              type string {
                tailf:info "WORD;;Pointer to route-map entries";
              }
            }
          }
          leaf route-map {
            tailf:info "Route map reference";
            type string {
              tailf:info "WORD;;Pointer to route-map entries";
            }
          }
        }
        uses redist-level-grouping;
        leaf metric {
          tailf:info "ISIS default metric";
          type uint32 {
            tailf:info "<0-4294967295>;;ISIS default metric";
            range "0..4294967295";
          }
        }
        leaf metric-type {
          tailf:info "OSPF/IS-IS exterior metric type for "
            +"redistributed routes";
          type enumeration {
            enum external {
              tailf:info "Set IS-IS External metric type";
            }
            enum internal {
              tailf:info "Set IS-IS Internal metric type";
            }
          }
        }
      }

      // router isis * / redistribute mobile
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        presence "Mobile routes";
        uses router-isis-redistribute-grouping;
      }
    }

    // router isis * / summary-address *
    list summary-address {
      tailf:info "Configure IP address summaries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "ip mask";
      leaf ip {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP summary address";
        }
      }
      leaf mask {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Summary mask";
        }
      }

      // router isis * / summary-address * level
      leaf level {
        tailf:cli-drop-node-name;
        type enumeration {
          enum level-1 {
            tailf:info "Summarize into level-1 area";
          }
          enum level-1-2 {
            tailf:info "Summarize into both area and sub-domain";
          }
          enum level-2 {
            tailf:info "Summarize into level-2 sub-domain";
          }
        }
      }

      // router isis * / summary-address * tag
      leaf tag {
        tailf:info "Set tag";
        type uint32 {
          tailf:info "<1-4294967295>;;32-bit tag value";
          range "1..4294967295";
        }
      }

      // router isis * / summary-address * metric
      leaf metric {
        tailf:info "Set metric for summay route";
        type uint32 {
          tailf:info "<1-4294967295>;;metric";
          range "1..4294967295";
        }
      }
    }

    // router isis * / no adjacency-check
    // router isis * / set-overload-bit
    // router isis * / spf-interval
    // router isis * / prc-interval
    // router isis * / metric
    // router isis * / maximum-paths
    // router isis * / default-information
    uses router-isis-af-grouping;

    // router isis * / address-family ipv6 unicast
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv6 {
        tailf:info "Address family";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-af";
        tailf:cli-exit-command "exit-address-family" {
          tailf:info "Exit from Address Family configuration "
            +"mode";
        }
        leaf af {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type enumeration {
            enum unicast {
              tailf:info "Address Family Modifier";
            }
          }
          default unicast;
        }

        uses router-isis-af-grouping;

        // router isis * / address-family ipv6 summary-prefix *
        list summary-prefix {
          tailf:info "Configure IPv6 summary prefix";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "prefix";
          leaf "prefix" {
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
            }
          }
          // router isis * / address-family ipv6 summary-prefix * level-X
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "Summarize into level-1 area";
              }
              enum level-1-2 {
                tailf:info "Summarize into both area and sub-domain";
              }
              enum level-2 {
                tailf:info "Summarize into level-2 sub-domain";
              }
            }
          }
          // router isis * / address-family ipv6 summary-prefix * tag
          leaf tag {
            tailf:info "Set tag";
            type uint32 {
              tailf:info "<1-4294967295>;;32-bit tag value";
            }
          }
        }

        // router isis * / address-family ipv6 unicast / distance
        leaf distance {
          tailf:info "Administrative distance";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-255>;;OSPF Administrative distance";
            range "1..255";
          }
        }

        // router isis * / address-family ipv6 multi-topology
        container multi-topology {
          tailf:info "Enable multi-topology mode";
          presence "Enable multi-topology mode";
          leaf transition {
            tailf:info "Accept and generate both IS-IS "
              +"IPv6 and Multi-topology IPv6 TLVs";
            type empty;
          }
        }

        // router isis * / address-family ipv6 / redistribute
        container redistribute {
          tailf:info "Redistribute IPv6 prefixes from another "
            +"routing protocol";

          // router isis * / address-family ipv6 /redistribute connected
          container connected {
            tailf:info "Connected";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence "Connected";
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute static
          container static {
            tailf:info "Static routes";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence "Static routes";
            uses router-isis-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute bgp
          container bgp {
            tailf:info "Border Gateway Protocol (BGP)";
            tailf:cli-compact-syntax;
            leaf as-no {
              tailf:cli-drop-node-name;
              type bgp-as-no-type;
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 / redistribute ospf *
          list ospf {
            tailf:info "Open Shortest Path First (OSPF)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key id;
            leaf id {
              tailf:cli-suppress-range;
              type uint16 {
                tailf:info "<1-65535>;;Process ID";
                range "1..65535";
              }
            }
            uses redistribute-ospf-match-grouping;
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 / redistribute rip
          list rip {
            tailf:info "IPv6 Routing Information Protocol (RIPv6)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key process;
            leaf process {
              type string {
                tailf:info "WORD;;User selected string identifying "
                  +"this process";
              }
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute eigrp *
          list eigrp {
            tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key as-no;
            leaf as-no {
              type eigrp-as-no-type;
            }
            uses router-isis-af-redistribute-grouping;
          }

          // router isis * / address-family ipv6 /redistribute isis
          container isis {
            tailf:info "ISO IS-IS";
            tailf:cli-compact-syntax;

            // router isis * / address-family ipv6 /redistribute isis *
            list isis-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              key "from into";
              leaf from {
                type enumeration {
                  enum level-1 {
                    tailf:info "Inter-area routes from level-1";
                  }
                  enum level-2 {
                    tailf:info "Inter-area routes from level-2";
                  }
                }
              }
              leaf into {
                tailf:info "from level-n into level-m";
                tailf:cli-expose-key-name;
                type enumeration {
                  enum level-1 {
                    tailf:info "Inter-area routes from level-1";
                  }
                  enum level-2 {
                    tailf:info "Inter-area routes from level-2";
                  }
                }
              }
              leaf distribute-list {
                tailf:info "select routes";
                type string {
                  tailf:info "WORD;;IPv6 prefix-list name";
                }
              }
              leaf route-map {
                tailf:info "Route map for route matching";
                type string {
                  tailf:info "WORD;;Name of the route-map";
                }
              }
            }
          }

          // router isis * / address-family ipv6 / redistribute nemo
          container nemo {
            tailf:info "Network Mobility (NEMO)";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            uses router-isis-af-redistribute-grouping;
          }
        }
      }
    }
  }


  // router lisp / eid-table * / database-mapping * /
  // router lisp / service ipv4 / database-mapping *
  // router lisp / service ipv6 / database-mapping *
  grouping router-lisp-database-mapping-grouping {
    list database-mapping {
      tailf:info "Configures Locator addresses for an ETR";
      tailf:cli-incomplete-command;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key "prefix";
      max-elements 100;
      leaf "prefix" {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;EID-prefix to advertise locators for "+
              "(max 100 prefixes)";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;EID-prefix to advertise locators "+
              "for (max 100 prefixes)";
          }
        }
      }
      // router lisp / eid-table * / database-mapping * <rloc>
      choice rloc-choice {
        leaf ipv4-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 Address of loopback or other ETR interface";
          }
        }
        container IPv4-interface {
          tailf:info "Use IPv4 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        container IPv6-interface {
          tailf:info "Use IPv6 address of interface as locator";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          uses interface-name-grouping;
        }
        leaf ipv6-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other "+
              "ETR interface";
          }
        }
        leaf auto-discover-rlocs {
          tailf:info "Auto discover locators registered by other xTRs";
          tailf:cli-full-command;
          type empty;
        }
        leaf locator-set {
          tailf:info "Use locators defined by locator-set";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Existing locator set";
          }
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
        }
      }
    }
  }

  // router lisp / ipv4
  // router lisp / eid-table * ipv4
  grouping router-lisp-af4-common-grouping {

    // router lisp / ipv4 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request message";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IPv4 Source address of inner header in "+
          "Map-Request message";
      }
    }

    // router lisp / ipv4 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of "+
            "map-request";
        }
      }
    }
  }

  // router lisp / ipv6
  // router lisp / eid-table * ipv6
  grouping router-lisp-af6-common-grouping {

    // router lisp / ipv6 map-request-source
    leaf map-request-source {
      tailf:info "Configures inner header source address in Map-Request message";
      type inet:ipv6-address {
        tailf:info "X:X:X:X::X;;IPv6 Source address of inner header in Map-Request message";
      }
    }

    // router lisp / ipv6 proxy-itr
    container proxy-itr {
      tailf:info "Configures a LISP Proxy Ingress Tunnel Router (PITR)";
      tailf:cli-compact-syntax;
      leaf ipv6-local-locator {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        type inet:ipv6-address {
          tailf:info "X:X:X:X::X;;IPv6 address in ITR-RLOC field of map-request";
        }
      }
      leaf ipv4-local-locator {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPv4 address in ITR-RLOC field of map-request";
        }
      }
    }
  }

  // router lisp / ipv4
  // router lisp / ipv6
  // router lisp / eid-table * ipv4
  // router lisp / eid-table * ipv6
  grouping router-lisp-af-grouping {

    // router lisp / ipv4 map-resolver
    leaf map-resolver {
      tailf:info "Configures a LISP Map Resolver (MR)";
      type empty;
    }

    // router lisp / ipv4 map-resolver map-request validate source
    container  map-resolver-conf {
      tailf:cli-drop-node-name;
      container map-resolver {
        tailf:info "Configures a LISP Map Resolver (MR)";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        container map-request {
          tailf:info "Map-Request processing options";
          container validate {
            tailf:info "Validation options";
            container source {
              tailf:info "Influence which source RLOCs map requests are accepted from";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              leaf registered {
                tailf:info "...from RLOCs that register EID-prefixes in the same IID on a co-located MapServer";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              container "list" {
                tailf:info "Define allowed prefixes using an ip[v6] prefix list";
                choice list-choice {
                  leaf ipv4 {
                    tailf:info "IPv4 prefixes";
                    type string {
                      tailf:info "WORD;;IPv4 prefix-list name";
                    }
                  }
                  leaf ipv6 {
                    tailf:info "IPv6 prefixes";
                    type string {
                      tailf:info "WORD;;IPv6 prefix-list name";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // router lisp / ipv4 itr map-resolver *
    container itr {
      tailf:info "Configures a LISP Ingress Tunnel Router (ITR)";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      list map-resolver {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map resolver";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map resolver";
            }
          }
        }
      }

      // router lisp / ipv4 itr
      // router lisp / ipv6 itr
      leaf enable {
        tailf:cli-drop-node-name;
        type empty;
      }
    }

    // router lisp / ipv4 etr map-server *
    container etr {
      tailf:info "Configures a LISP Egress Tunnel Router (ETR)";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      list map-server {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "IPv4 Address of map server";
            }
            type inet:ipv6-address {
              tailf:info "IPv6 Address of map server";
            }
          }
        }

        // router lisp / ipv4 etr map-server * key
        container "key" {
          tailf:info "Authentication key used with map server";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses crypto-key-grouping;
          leaf hash-function {
            tailf:info "Map-Register authentication type";
            type enumeration {
              enum sha1 {
                tailf:info "Use the SHA-1-96 hash function";
              }
              enum sha2 {
                tailf:info "Use the SHA-256-128 hash function";
              }
            }
          }
        }
      }

      // router lisp / ipv4 etr
      // router lisp / ipv6 etr
      leaf enable {
        tailf:cli-drop-node-name;
        type empty;
      }
    }

    // router lisp / ipv4 map-cache-limit
    leaf map-cache-limit {
      tailf:info "Configures maximum size of map-cache";
      type uint32 {
        tailf:info "<0-100000>;;Maximum number of map-cache entries";
        range "0..100000";
      }
    }

    // router lisp / ipv4 map-cache-persistent
    container map-cache-persistent {
      tailf:info "Dump map-cache onto flash, making it persistent across reboots";
      tailf:meta-data "suppress-delete-error-invalid";
      presence true;
      leaf interval {
        tailf:info "Interval in minutes of how often the map-cache is saved";
        type uint16 {
          tailf:info "<1-1440>;;Interval in minutes, default 60";
          range "1..1440";
        }
      }
    }

    // router lisp / ipv4 route-import
    container route-import {
      tailf:info "Import RIB routes by a routing protocol into LISP";

      // router lisp / ipv4 route-import database
      container database {
        tailf:info "Use RIB routes to define local EID database entries";

        // router lisp / ipv4 route-import database connected
        // router lisp / ipv4 route-import database static
        // router lisp / ipv4 route-import database rip
        list static-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key protocol;
          leaf protocol {
            type enumeration {
              enum connected {
                tailf:info "Connected";
              }
              enum static {
                tailf:info "Static routes";
              }
              enum rip {
                tailf:info "Routing Information Protocol (RIP)";
              }
            }
          }
          leaf route-map {
            tailf:info "Route map for route selection filtering";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Route map name";
            }
          }
          leaf locator-set {
            tailf:info "Locator set to use with created database mapping entries";
            type string {
              tailf:info "WORD;;Locator set name";
            }
          }
        }

        // router lisp / ipv4 route-import database ospf *
        // router lisp / ipv4 route-import database ospfv3 *
        // router lisp / ipv4 route-import database eigrp *
        // router lisp / ipv4 route-import database bgp *
        // router lisp / ipv4 route-import database rip *
        list id-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key "protocol id";
          leaf protocol {
            type enumeration {
              enum bgp {
                tailf:info "Border Gateway Protocol (BGP)";
              }
              enum eigrp {
                tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
              }
              enum isis {
                tailf:info "ISO IS-IS";
              }
              enum ospf {
                tailf:info "Open Shortest Path First (OSPF)";
              }
              enum ospfv3 {
                tailf:info "OSPFv3";
              }
              enum rip {
                tailf:info "Routing Information Protocol (RIP)";
              }
            }
          }
          leaf id {
            tailf:cli-disallow-value "route-map";
            type string {
              tailf:info "WORD;;Process id";
            }
          }
          leaf route-map {
            tailf:info "Route map for route selection filtering";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Route map name";
            }
          }
          leaf locator-set {
            tailf:info "Locator set to use with created database mapping entries";
            type string {
              tailf:info "WORD;;Locator set name";
            }
          }
        }
      }
    }

    // router lisp / ipv4 route-export site-registration
    container route-export {
      tailf:info "Export routes into RIB from LISP";
      leaf site-registration {
        tailf:info "Export LISP site registrations to RIB";
        type empty;
      }
    }

    // router lisp / ipv4 map-cache site-registration
    container map-cache {
      tailf:info "Address family specific map cache configuration";
      leaf site-registration {
        tailf:info "Install map cache to map request for site registrations";
        type empty;
      }
    }

    // router lisp / ipv4 proxy-etr
    leaf proxy-etr {
      tailf:info "Configures a LISP Proxy Engress Tunnel Router (PETR)";
      tailf:cli-full-command;
      type empty;
    }

    // router lisp / ipv4 use-petr
    list use-petr {
      tailf:info "Encapsulate to Proxy ETR when matching forward-native "+
        "entry";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key address;
      leaf address {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 locator address of PETR";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 locator address of PETR";
          }
        }
      }
      leaf priority {
        tailf:info "Configures which Locators from a set are preferred";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<0-255>;;Lower priority Locator takes preference";
        }
      }
      leaf weight {
        tailf:info "Traffic load-spreading among Locators";
        type uint8 {
          tailf:info "<0-100>;;Relative weight of locator";
          range "0..100";
        }
      }
    }

    // router lisp / ipv4 map-server
    leaf map-server {
      tailf:info "Configures a LISP Map Server (MS)";
      type empty;
    }
  }

  // router-lisp-eid-table-grouping
  grouping router-lisp-eid-table-grouping {

    // router lisp / eid-table * instance-id
    leaf instance-id {
      tailf:info "EID instance-ID";
      tailf:cli-hide-in-submode;
      type uint32 {
        tailf:info "<0-16777214>;;Instance-ID";
        range "0..16777214";
      }
    }

    // router lisp / eid-table * / map-cache *
    list map-cache {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key "prefix";
      leaf "prefix" {
        type union {
          type ios:ipv4-prefix {
            tailf:info "A.B.C.D/nn;;IPv4 EID-prefix for RLOC static mapping";
          }
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID-prefix for RLOC "+
              "static mapping";
          }
        }
      }
      choice map-cache-choice {
        // router lisp / eid-table * / map-cache * <locator>
        case locator {
          leaf locator {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 Address of loopback or other ETR "+
                  "interface";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;IPv6 Address of loopback or other ETR "+
                  "interface";
              }
            }
          }
          leaf priority {
            tailf:info "Lower priority Locator takes preference";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Lower priority Locator takes preference";
            }
          }
          leaf weight {
            tailf:info "Traffic load-spreading among Locators";
            type uint8 {
              tailf:info "<0-100>;;Relative weight of locator";
              range "0..100";
            }
          }
        }
        // router lisp / eid-table * / map-cache * map-request
        leaf map-request {
          tailf:info "Send Map-Request for LISP destination EID";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * native-forward
        leaf native-forward {
          tailf:info "Natively forward packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
        // router lisp / eid-table * / map-cache * drop
        leaf drop {
          tailf:info "Drop packets that match this map-cache entry";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // router lisp / eid-table * / database-mapping *
    uses router-lisp-database-mapping-grouping;

    // router lisp / eid-table * / loc-reach-algorithm
    container loc-reach-algorithm {
      tailf:info "Configure locator reachability algorithm";
      leaf lsb-reports {
        tailf:info "Configure data packet LSB report handling";
        type enumeration {
          enum ignore {
            tailf:info "Ignore data packet LSB reports";
          }
        }
      }
      leaf rloc-probing {
        tailf:info "Probe high priority RLOCs with Map-Requests as last "+
          "resort";
        type empty;
      }
    }

    // router lisp / eid-table * / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / eid-table * / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-grouping;
      uses router-lisp-af6-common-grouping;
    }
  }

  // router lisp / service ipv4 /
  // router lisp / service ipv6 /
  grouping router-lisp-service-af-grouping {

    // router lisp / service ipv4 / eid-table
    container eid-table {
      tailf:info "Bind an eid-table";

      // router lisp / service ipv4 / eid-table default
      leaf "default" {
        tailf:info "Default VRF";
        type empty;
      }

      // router lisp / service ipv4 / eid-table vrf
      leaf vrf {
        tailf:info "VRF name";
        tailf:cli-diff-dependency "/ios:vrf/definition"; // MODE
        type string {
          tailf:info "WORD;;VRF name";
        }
      }
    }

    // router lisp / service ipv4 / database-mapping *
    uses router-lisp-database-mapping-grouping;

    // router lisp / service ipv4 / encapsulation
    leaf encapsulation {
      tailf:info "Select encapsulation type for data packets";
      type enumeration {
        enum lisp {
          tailf:info "Use LISP encapsulation for data packets";
        }
        enum vxlan {
          tailf:info "Use VXLAN encapsulation for data packets";
        }
      }
    }
  }

  // router lisp /
  // router lisp / instance-id * /
  grouping router-lisp-service-grouping {

    // router lisp / service
    container service {
      tailf:info "Select service type";

      // router lisp / service ipv4
      container ipv4 {
        tailf:info "Select service type as IPv4";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-lisp-serv-ipv4";
        tailf:cli-exit-command "exit-service-ipv4" {
          tailf:info "Exit from LISP service-ipv4 configuration mode";
        }
        presence true;
        uses router-lisp-service-af-grouping;
        uses router-lisp-af-grouping;
        uses router-lisp-af4-common-grouping;
      }

      // router lisp / service ipv6
      container ipv6 {
        tailf:info "Select service type as IPv6";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-router-lisp-serv-ipv6";
        tailf:cli-exit-command "exit-service-ipv6" {
          tailf:info "Exit from LISP service-ipv6 configuration mode";
        }
        presence true;
        uses router-lisp-service-af-grouping;
        uses router-lisp-af-grouping;
        uses router-lisp-af6-common-grouping;
      }
    }
  }


  // router-lisp-grouping
  grouping router-lisp-grouping {

    // router lisp / syslog
    container syslog {
      tailf:info "Configure syslog option";

      // router lisp / syslog verbose
      leaf verbose {
        tailf:info "Enable verbose syslog";
        type empty;
      }

      // router lisp / syslog session changes
      container session {
        tailf:info "Enable session syslog";
        leaf changes {
          tailf:info "Enable session change syslog";
          type empty;
        }
      }
    }

    // router lisp / etr map-server source-address
    container etr {
      tailf:info "Configures a LISP Egress Tunnel Router (ETR)";
      container map-server {
        tailf:info "Configures map server for ETR registration";
        container source-address {
          tailf:info "Configures map server source address";
          uses interface-name-grouping;
        }
      }
    }

    // router lisp / locator-table
    container locator-table {
      tailf:info "Specify the RLOC table";
      choice locator-table-choice {
        leaf "default" {
          tailf:info "Default VRF";
          type empty;
        }
        leaf vrf {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }
    }

    // router lisp / locator-set *
    list locator-set {
      tailf:info "Configure a named locator set";
      tailf:cli-mode-name "config-router-lisp-locator-set";
      //IWAN3: tailf:cli-exit-command "exit-locator-set";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "Configure a named locator set";
        }
      }

      // router lisp / locator-set * / a.b.c.d
      list IPv4-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / X:X:X:X::X
      list IPv6-address {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Address of loopback or other ETR "+
              "interface";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv4-interface *
      list IPv4-interface {
        tailf:info "Use IPv4 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / IPv6-interface *
      list IPv6-interface {
        tailf:info "Use IPv6 address of interface as locator";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf priority {
          tailf:info "Configures which Locators from a set are preferred";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-255>;;Lower priority Locator takes preference";
          }
        }
        leaf weight {
          tailf:info "Traffic load-spreading among Locators";
          type uint8 {
            tailf:info "<0-100>;;Relative weight of locator";
            range "0..100";
          }
        }
      }

      // router lisp / locator-set * / auto-discover-rlocs
      leaf auto-discover-rlocs {
        tailf:info "Auto discover locators registered by other xTRs";
        type empty;
      }
    }

    // router lisp / service
    uses router-lisp-service-grouping {
      refine "service/ipv4" {
        tailf:cli-diff-dependency "../../locator-set";
      }
      refine "service/ipv6" {
        tailf:cli-diff-dependency "../../locator-set";
      }
      refine "service/ipv4/etr/map-server/key/secret" {
        tailf:meta-data "secret-password" {
          tailf:meta-value "router lisp<NL><*>service ipv4<NL><*> ::  etr map-server <map-server> key <PASSWORD>";
        }
      }
      refine "service/ipv6/etr/map-server/key/secret" {
        tailf:meta-data "secret-password" {
          tailf:meta-value "router lisp<NL><*>service ipv6<NL><*> ::  etr map-server <map-server> key <PASSWORD>";
        }
      }
    }

    // router lisp / map-request
    container map-request {
      tailf:info "Configure map-request handling";
      leaf itr-rlocs {
        tailf:info "Configure to use the specified RLOC set as ITR RLOC in "+
          "map-request";
        type string {
          tailf:info "WORD;;Existing locator set";
        }
        tailf:non-strict-leafref {
          path "../../locator-set/name";
        }
      }
    }

    // router lisp / eid-table
    container eid-table {
      tailf:info "Configure an EID instance for a VRF";
      tailf:cli-diff-dependency "../locator-set";

      // router lisp / eid-table default
      list default-vrf {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-router-lisp-eid-table";
        tailf:cli-explicit-exit;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type enumeration {
            enum "default" {
              tailf:info "Default VRF";
            }
          }
        }
        uses router-lisp-eid-table-grouping;
      }

      // router lisp / eid-table vrf *
      list vrf {
        tailf:info "VRF name";
        tailf:cli-mode-name "config-router-lisp-eid-table";
        tailf:cli-explicit-exit;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses router-lisp-eid-table-grouping;
      }
    }

    // router lisp / loc-reach-algorithm
    container loc-reach-algorithm {
      tailf:info "Configure locator reachability algorithm";

      // router lisp / loc-reach-algorithm rloc-probing
      leaf rloc-probing {
        tailf:info "Probe high priority RLOCs with Map-Requests as last resort";
        type empty;
      }
    }

    // router lisp / site *
    list site {
      tailf:info "Configure a LISP site on a map server (MS)";
      tailf:cli-mode-name "config-router-lisp-site";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;The site name";
        }
      }

      // router lisp / site * / description
      leaf "description" {
        tailf:info "Provide a description string for the LISP site";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Site description";
        }
      }

      // router lisp / site * / authentication-key
      container authentication-key {
        tailf:info "Authentication key used by LISP site";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses crypto-key-grouping;
      }

      // router lisp / site * / eid-prefix *
      list eid-prefix {
        tailf:info "Site EID address prefix";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "prefix";
        leaf "prefix" {
          type union {
            type ios:ipv4-prefix {
              tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
            }
            type ios:ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging "+
                "to the SITE";
            }
          }
        }
        // router lisp / site * / eid-prefix * route-tag
        leaf route-tag {
          tailf:info "ALT RIB route tag for EID prefix";
          type uint32 {
            tailf:info "<0-4294967295>;;RIB route tag";
          }
        }
        // router lisp / site * / eid-prefix * accept-more-specifics
        leaf accept-more-specifics {
          tailf:info "Accept registrations for more specific EID prefixes";
          type empty;
        }
      }

      // router lisp / site * / eid-prefix instance-id *
      container eid-prefix-instance {
        tailf:cli-drop-node-name;
        list eid-prefix {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "instance-id prefix";
          leaf instance-id {
            tailf:info "EID instance-ID";
            tailf:cli-expose-key-name;
            type uint32 {
              tailf:info "<1-16777214>;;Instance-ID";
              range "1..16777214";
            }
          }
          leaf "prefix" {
            type union {
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D/nn;;IPv4 EID prefix belonging to the SITE";
              }
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 EID prefix belonging "+
                  "to the SITE";
              }
            }
          }
          leaf route-tag {
            tailf:info "ALT RIB route tag for EID prefix";
            type uint32 {
              tailf:info "<0-4294967295>;;RIB route tag";
            }
          }
          leaf accept-more-specifics {
            tailf:info "Accept registrations for more specific EID prefixes";
            type empty;
          }
        }
      }

      // router lisp / site * / allowed-locator *
      list allowed-locator {
        tailf:info "Locator from LISP site";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key rloc;
        leaf rloc {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 locator allowed in registered locator-set";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 locator allowed in registered locator-set";
            }
          }
        }
      }
    }

    // router lisp / ipv4
    container ipv4 {
      tailf:info "IPv4 address family";
      uses router-lisp-af-grouping {
        refine "map-cache-persistent" {
          tailf:cli-show-no;
        }
      }
      uses router-lisp-af4-common-grouping;
    }

    // router lisp / ipv6
    container ipv6 {
      tailf:info "IPv6 address family";
      uses router-lisp-af-grouping {
        refine "map-cache-persistent" {
          tailf:cli-show-no;
        }
      }
      uses router-lisp-af6-common-grouping;
    }

    // router lisp / instance-id *
    list instance-id {
      tailf:info "EID instance-ID";
      tailf:cli-mode-name "config-router-lisp-inst";
      //IWAN3: tailf:cli-exit-command "exit-instance-id";
      tailf:cli-diff-dependency "../locator-set";
      tailf:cli-diff-dependency "/ios:vrf/definition";
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint32 {
          tailf:info "<0-16777214>;;Instance-ID";
          range "0..16777214";
        }
      }

      // router lisp / instance-id * / service
      uses router-lisp-service-grouping {
        refine "service/ipv4/etr/map-server/key/secret" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router lisp<NL><*> instance-id <instance-id><NL><*>  service ipv4<NL><*> ::  etr map-server <map-server> key <PASSWORD>";
          }
        }
        refine "service/ipv6/etr/map-server/key/secret" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router lisp<NL><*> instance-id <instance-id><NL><*>  service ipv6<NL><*> ::  etr map-server <map-server> key <PASSWORD>";
          }
        }
      }
    }
  }


  grouping ip-nat-outside-source-grouping {

    leaf redundancy {
      tailf:cli-break-sequence-commands;
      tailf:info "NAT redundancy operation";
      type uint8 {
        tailf:info "<1-2>;IP redundancy ID";
      }
    }
    leaf mapping-id {
      when "../redundancy" {
        tailf:dependency "../redundancy";
      }
      tailf:info "Associate a mapping id to this mapping";
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    leaf add-route {
      tailf:info "Add a static route for outside local address";
      type empty;
    }

    leaf no-payload {
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }
  }

  grouping ip-nat-source-static-grouping {

    leaf redundancy {
      tailf:cli-break-sequence-commands;
      tailf:info "NAT redundancy operation";
      type union {
        type uint8 {
          tailf:info "<1-2>;IP redundancy ID";
        }
        type string {
          tailf:info "WORD;;IP redundancy name";
        }
      }
    }
    leaf mapping-id {
      when "../redundancy" {
        tailf:dependency "../redundancy";
      }
      tailf:info "Associate a mapping id to this mapping";
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    leaf extendable {
      tailf:info "Extend this translation when used";
      type empty;
    }

    leaf no-alias {
      tailf:info "Do not create an alias for the global address";
      type empty;
    }

    leaf no-payload {
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }

    leaf add-route {
      tailf:info "Add a static route for outside local address";
      type empty;
    }

    leaf route-map {
      tailf:info "Specify route-map";
      type string {
        tailf:info "WORD;;Route-map name";
      }
    }
    leaf reversible {
      when "../route-map" {
        tailf:dependency "../route-map";
      }
      type empty;
    }

    leaf match-in-vrf {
      tailf:info "Match incoming vrf";
      type empty;
    }

    leaf forced {
      tailf:info "Delete this entry and its children, even if in use";
      type empty;
    }

    leaf overload {
      tailf:info "Overload an address translation";
      type empty;
    }
  }

  grouping ip-nat-inside-options-grouping {

    // [no-payload]
    leaf no-payload {
      tailf:cli-break-sequence-commands;
      tailf:info "No translation of embedded address/port in the payload";
      type empty;
    }

    // [reversible]
    leaf reversible {
      tailf:info "Allow out->in traffic";
      type empty;
    }

    // [overload]
    leaf overload {
      tailf:info "Overload an address translation";
      type empty;
    }

    // [oer]
    leaf oer {
      tailf:info "Use with vtemplate only. On new translation, "+
        "if OER BR is UP, OER will select IP from outgoing Interface."+
        " All packets matching translation are forwarded over "+
        "Interface for duration of translation.";
      type empty;
    }
    // [ portmap name ]
  }

  grouping ip-nat-inside-grouping {

    // <pool>
    leaf pool {
      tailf:info "Name pool of global addresses";
      tailf:cli-optional-in-sequence;
      tailf:non-strict-leafref {
        path "/ios:ip/nat/pool/id";
      }
      type string {
        tailf:info "WORD;;Pool name for global addresses";
      }
    }

    // [ redundancy <rg-id> ]
    leaf redundancy {
      tailf:info "NAT redundancy operation";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-2>;;IP redundancy ID";
        range "1..2";
      }
    }

    // [ mapping-id <map-id> ]
    leaf mapping-id {
      tailf:info "Associate a mapping id to this mapping";
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    // <interface>
    leaf interface {
      when "not(../pool)" {
        tailf:dependency "../pool";
      }
      tailf:info "Specify interface for global address";
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "../../../../../../interface";
      type string {
        tailf:info "WORD;;Interface name";
      }
    }
  }

  grouping ip-nat-inside-vrf-grouping {

    // <pool>
    leaf pool {
      tailf:info "Name pool of global addresses";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Pool name for global addresses";
      }
      tailf:non-strict-leafref {
        path "/ios:ip/nat/pool/id";
      }
    }

    // [ redundancy <rg-id> ]
    leaf redundancy {
      tailf:info "NAT redundancy operation";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<1-2>;;IP redundancy ID";
        range "1..2";
      }
    }

    // [ mapping-id <map-id> ]
    leaf mapping-id {
      tailf:info "Associate a mapping id to this mapping";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint32 {
        tailf:info "<1-2147483647>;;Stateful NAT mapping id";
        range "1..2147483647";
      }
    }

    // <interface>
    leaf interface {
      when "not(../pool)" {
        tailf:dependency "../pool";
      }
      tailf:info "Specify interface for global address";
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      tailf:cli-diff-dependency "../../../../../../../interface";
      type string {
        tailf:info "WORD;;Interface name";
      }
    }

    // [vrf]
    leaf vrf {
      tailf:info "Specify vrf";
      tailf:cli-expose-key-name;
      type string {
        tailf:info "WORD;;vrf name";
      }
    }

    // [match-in-vrf]
    leaf match-in-vrf {
      tailf:info "Match incoming vrf";
      tailf:cli-optional-in-sequence;
      type empty;
    }
  }

  grouping mobile-ip-spi-grouping {
    choice spi-type-choice {
      leaf hex {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<100-FFFFFFFF>;;SPI hex value";
        }
      }
      leaf decimal {
        tailf:info "decimal Security parameter index - bidirectional";
        type uint32 {
          tailf:info "<256-4294967295>;;SPI decimal value";
          range "256..4294967295";
        }
      }
    }
  }


  // interface * / xconnect
  grouping xconnect-interface-grouping {

    choice xconnect-choice {

      // interface * / xconnect * encapsulation
      container xconnect {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xconn";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-diff-dependency "../encapsulation";
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }
        leaf encapsulation {
          tailf:info "Data encapsulation method";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }
        leaf manual {
          tailf:info "Manually configure session parameters";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf pw-class {
          tailf:info "Optional pseudowire-class to use for "+
            "advanced configuration";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
          tailf:non-strict-leafref {
            path "/ios:pseudowire-class/name";
          }
        }
        leaf sequencing {
          tailf:info "Configure sequencing options for xconnect";
          tailf:cli-full-command;
          tailf:cli-hide-in-submode;
          when "../encapsulation = 'l2tpv3'" {
            tailf:dependency "../encapsulation";
          }
          type enumeration {
            enum both {
              tailf:info "Transmit and receive sequence numbers";
            }
            enum receive {
              tailf:info "Receive sequence numbers";
            }
            enum transmit {
              tailf:info "Transmit sequence numbers";
            }
          }
        }

        // interface * / xconnect encapsulation / backup
        container backup {
          tailf:cli-break-sequence-commands;
          tailf:info "Xconnect backup configuration commands";

          // interface * / xconnect encapsulation / backup peer
          container peer {
            tailf:info "Backup pseudowire";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peer-router-ip-addr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of peer";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Enter VC ID value";
                range "1..4294967295";
              }
            }
            leaf pw-class {
              tailf:cli-optional-in-sequence;
              type string {
                tailf:info "Optional Pseudowire-class to use for "+
                  "backup pseudowire";
              }
              tailf:non-strict-leafref {
                path "/ios:pseudowire-class/name";
              }
            }
            leaf priority {
              tailf:info "Optional priority to use for backup pseudowire.";
              type uint8 {
                tailf:info "Peer priority";
                range "1..10";
              }
            }
          }

          // interface * / xconnect encapsulation / backup delay
          container delay {
            tailf:info "Backup delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf enable-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-180>;;Enable delay";
                range "0..180";
              }
              default 0;
            }
            leaf disable-delay {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<0-180>;;Disable delay";
                  range "0..180";
                }
                type enumeration {
                  enum never {
                    tailf:info "Disallow disable";
                  }
                }
              }
              default 0;
            }
          }
        }

        // interface * / xconnect encapsulation / mpls
        container mpls {
          tailf:info "MPLS manual configuration commands";

          // interface * / xconnect encapsulation / mpls control-word
          leaf control-word {
            tailf:info "Include control-word in pseudowire packets";
            type empty;
          }

          // mpls label
        }

        // interface * / xconnect encapsulation / mtu
        leaf mtu {
          tailf:info "set XCONNECT Maximum Transfer Unit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<64-9100>;;per Xconnect MTU size in bytes";
            range "64..9100";
          }
        }

        // interface * / xconnect encapsulation / ..
        // .. no remote link failure notification
        container remote {
          tailf:info "Xconnect remote peer configuration commands";
          container link {
            tailf:info "Link information";
            container failure {
              tailf:info "Failure information";
              leaf "notification" {
                tailf:info "Notify in case of remote link failure";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
            }
          }
        }
      }

      // interface * / xconnect pw-class
      container xconnect-pw-class {
        tailf:cli-drop-node-name;
        container xconnect {
          tailf:info "Xconnect commands";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          leaf pw-class {
            tailf:info "Pseudowire-class to use for encapsulation "+
              "and protocol configuration";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Pseudowire-class name";
            }
            tailf:non-strict-leafref {
              path "/ios:pseudowire-class/name";
            }
          }
        }
      }

      // interface * / xconnect vfi
      container xconnect-vfi {
        tailf:cli-drop-node-name;
        container xconnect {
          tailf:info "Xconnect commands";
          tailf:cli-incomplete-command;
          leaf vfi {
            tailf:info "connect to a virtual forwarding instance";
            // dep: before this created, must change l2 vfi
            tailf:cli-diff-dependency "/ios:l2/vfi" { // IN CHOICE
              tailf:cli-trigger-on-set;
            }
            tailf:non-strict-leafref {
              path "/ios:l2/vfi/name";
            }
            type string {
              tailf:info "WORD;VFI name";
            }
          }
        }
      }
    }
  }

  // interface * / service instance * ethernet / xconnect
  // interface ATM* / pvc * / xconnect
  // interface CEM* / cem * / xconnect
  // connect * / xconnect
  grouping xconnect-grouping {

    choice xconnect-choice {

      // interface * / xconnect * encapsulation
      container xconnect {
        tailf:cli-break-sequence-commands;
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xconn";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        presence true;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-hide-in-submode;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }
        leaf encapsulation {
          tailf:info "Data encapsulation method";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }
        leaf manual {
          tailf:info "Manually configure session parameters";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf pw-class {
          tailf:info "Optional pseudowire-class to use for advanced configuration";
          tailf:cli-optional-in-sequence;
          tailf:cli-hide-in-submode;
          tailf:non-strict-leafref {
            path "/ios:pseudowire-class/name";
          }
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }
        leaf sequencing {
          when "../encapsulation = 'l2tpv3'" {
            tailf:dependency "../encapsulation";
          }
          tailf:info "Configure sequencing options for xconnect";
          tailf:cli-full-command;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum both {
              tailf:info "Transmit and receive sequence numbers";
            }
            enum receive {
              tailf:info "Receive sequence numbers";
            }
            enum transmit {
              tailf:info "Transmit sequence numbers";
            }
          }
        }

        // interface * / xconnect encapsulation / backup
        container backup {
          tailf:cli-break-sequence-commands;
          tailf:info "Xconnect backup configuration commands";

          // interface * / xconnect encapsulation / backup peer
          container peer {
            tailf:info "Backup pseudowire";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf peer-router-ip-addr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of peer";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-4294967295>;;Enter VC ID value";
                range "1..4294967295";
              }
            }
            leaf pw-class {
              tailf:cli-optional-in-sequence;
              tailf:non-strict-leafref {
                path "/ios:pseudowire-class/name";
              }
              type string {
                tailf:info "Optional Pseudowire-class to use for "+
                  "backup pseudowire";
              }
            }
            leaf priority {
              tailf:info "Optional priority to use for backup pseudowire.";
              type uint8 {
                tailf:info "Peer priority";
                range "1..10";
              }
            }
          }

          // interface * / xconnect encapsulation / backup delay
          container delay {
            tailf:info "Backup delay";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf enable-delay {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-180>;;Enable delay";
                range "0..180";
              }
              default 0;
            }
            leaf disable-delay {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<0-180>;;Disable delay";
                  range "0..180";
                }
                type enumeration {
                  enum never {
                    tailf:info "Disallow disable";
                  }
                }
              }
              default 0;
            }
          }
        }

        // interface * / xconnect encapsulation / mpls
        container mpls {
          tailf:info "MPLS manual configuration commands";

          // interface * / xconnect encapsulation / mpls control-word
          leaf control-word {
            tailf:info "Include control-word in pseudowire packets";
            type empty;
          }

          // mpls label
        }

        // interface * / xconnect encapsulation / mtu
        leaf mtu {
          tailf:info "set XCONNECT Maximum Transfer Unit";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<64-9100>;;per Xconnect MTU size in bytes";
            range "64..9100";
          }
        }

        // interface * / xconnect encapsulation / ..
        // .. no remote link failure notification
        container remote {
          tailf:info "Xconnect remote peer configuration commands";
          container link {
            tailf:info "Link information";
            container failure {
              tailf:info "Failure information";
              leaf "notification" {
                tailf:info "Notify in case of remote link failure";
                tailf:cli-boolean-no;
                tailf:cli-full-command;
                type boolean;
                default true;
              }
            }
          }
        }
      }

      // No mode version of:
      // interface * / xconnect pw-class
      container xconnect-pw-class {
        tailf:cli-drop-node-name;
        container xconnect {
          tailf:info "Xconnect commands";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          leaf pw-class {
            tailf:info "Pseudowire-class to use for encapsulation "+
              "and protocol configuration";
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "/ios:pseudowire-class/name";
            }
            type string {
              tailf:info "WORD;;Pseudowire-class name";
            }
          }
        }
      }
    }
  }


  // ip pim
  // ip pim vrf *
  grouping ip-pim-grouping {

    // ip pim ssm
    container ssm {
      tailf:info "Configure Source Specific Multicast";
      choice ip-pim-ssm-choice {
        leaf "default" {
          tailf:info "Use 232/8 group range for SSM";
          type empty;
        }
        leaf "range" {
          tailf:info "ACL for group range to be used for SSM";
          type union {
            type uint16 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP named access list";
              pattern '[a-zA-Z].*';
            }
          }
        }
      }
    }

    // ip pim register-source
    container register-source {
      tailf:info "Source address for PIM Register";
      uses interface-name-grouping;
    }

    // ip pim snooping
    leaf snooping {
      tailf:info "Global PIM Snooping enable for Catalyst Vlans";
      type empty;
    }

    // ip pim bsr-candidate *
    list bsr-candidate {
      tailf:info "Candidate bootstrap router (candidate BSR)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf hash-mask-length {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-32>;;Hash Mask length for RP selection";
          range "0..32";
        }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-255>;;Priority value for candidate "+
            "bootstrap router";
        }
      }
      leaf accept-rp-candidate {
        tailf:info "BSR RP candidate filter";
        type exp-ip-acl-type;
      }
    }

    // ip pim send-rp-announce
    container send-rp-announce {
      tailf:info "Auto-RP send RP announcement";
      tailf:cli-compact-syntax;
      container interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf scope {
        tailf:info "RP announcement scope";
        type uint8 {
          tailf:info "<1-255>;;TTL of the RP announce packet ";
          range "1..255";
        }
      }
      leaf group-list {
        tailf:info "Group access-list";
        type union {
          type uint16 {
            tailf:info "<1-99>;;Access list number";
            range "1..99";
          }
          type string {
            tailf:info "WORD;;IP named access list";
            pattern '[a-zA-Z].*';
          }
        }
      }
      leaf interval {
        tailf:info "RP announcement interval";
        type uint16 {
          tailf:info "<1-16383>;;number of seconds";
          range "1..16383";
        }
      }
    }

    // ip pim send-rp-discovery
    container send-rp-discovery {
      tailf:info "Auto-RP send RP discovery message (as RP-mapping agent)";

      // ip pim send-rp-discovery scope
      container scope {
        tailf:info "Scope of the RP discovery packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;TTL";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "RP discovery interval";
          type uint16 {
            tailf:info "<1-16383>;;number of seconds";
            range "1..16383";
          }
        }
      }
    }

    // ip pim rp-address *
    list rp-address {
      tailf:info "PIM RP-address (Rendezvous Point)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Rendezvous-point for group";
        }
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-disallow-value "override";
        type std-acl-type;
      }
      leaf override {
        tailf:info "Overrides dynamically learnt RP mappings";
        type empty;
      }
    }

    // ip pim rp-candidate *
    list rp-candidate {
      tailf:info "To be a PIMv2 RP candidate";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf bidir {
        type empty;
      }
      leaf group-list {
        tailf:info "group-list";
        type union {
          type uint8 {
            tailf:info "<1-99>;;Access-list reference for group prefixes";
            range "1..99";
          }
          type string {
            tailf:info "WORD;;Named access list";
          }
        }
      }
      leaf interval {
        tailf:info "RP candidate advertisement interval";
        type uint16 {
          tailf:info "<1-16383>;;number of seconds";
          range "1..16383";
        }
      }
      leaf priority {
        tailf:info "RP candidate priority";
        type uint8 {
          tailf:info "<0-255>;;Priority value";
        }
      }
    }

    // ip pim spt-threshold
    container spt-threshold {
      tailf:info "Source-tree switching threshold";

      // ip pim spt-threshold infinity
      // ip pim spt-threshold ?
      leaf "value" {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type union {
          type enumeration {
            enum infinity {
              tailf:info "Never switch to source-tree";
            }
          }
          type uint32 {
            tailf:info "<0-4294967>;;Traffic rate in kilobits per second";
            range "0..4294967";
          }
        }
      }

      // ip pim spt-threshold ? group-list *
      list group-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key group-list;
        leaf "value" {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type union {
            type enumeration {
              enum infinity {
                tailf:info "Never switch to source-tree";
              }
            }
            type uint32 {
              tailf:info "<0-4294967>;;Traffic rate in kilobits per second";
              range "0..4294967";
            }
          }
        }
        leaf group-list {
          tailf:info "Group address access-list";
          tailf:cli-expose-key-name;
          type std-acl-type;
        }
      }
    }

    // ip pim autorp
    choice autorp-choice {
      // no ip pim autorp
      leaf autorp {
        tailf:info "Configure AutoRP global operations";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // ip pim autorp listener
      container conf {
        tailf:cli-drop-node-name;
        container autorp {
          tailf:info "Configure AutoRP global operations";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          leaf listener {
            tailf:info "Allow AutoRP packets across sparse mode interface";
            type empty;
          }
        }
      }
    }

    // ip pim dm-fallback
    leaf dm-fallback {
      tailf:info "Fallback group mode is Dense";
      tailf:cli-full-command;
      type empty;
    }
  }

  // event manager applet * / event
  // event manager applet * / event tag *
  grouping event-manager-applet-event-grouping {

    // event manager applet * / event none
    container none {
      tailf:info "Manually run policy event";
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
        }
      }
    }

    // event manager applet * / event snmp-notification
    container snmp-notification {
      tailf:info "SNMP Notification Event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf oid {
        tailf:info "Object ID of data element";
        type string {
          tailf:info "WORD;;OID string";
        }
      }
      leaf oid-val {
        tailf:info "Comparison value";
        type string {
          tailf:info "WORD;;Comparision value";
        }
      }
      leaf op {
        tailf:info "Operator";
        type operator-type;
      }
      leaf src-ip-address {
        tailf:info "Source ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Source ip address value";
          }
        }
      }
      leaf dest-ip-address {
        tailf:info "Destination ip address";
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination ip address value";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Destination ip address value";
          }
        }
      }
    }

    // event manager applet * / event syslog
    container syslog {
      tailf:info "Syslog event";
      // event manager applet * / event syslog pattern
      leaf "pattern" {
        tailf:info "Pattern match string for the entire message";
        type string {
          tailf:info "WORD;;Pattern match string for the entire message";
        }
      }
    }

    // event manager applet * / event cli pattern
    container cli {
      tailf:info "CLI event";
      tailf:cli-compact-syntax;
      container "pattern" {
        tailf:info "CLI command pattern match";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf regular-expression {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Pattern match string";
          }
        }
        leaf sync {
          tailf:info "CLI and EEM policy execution sync or async";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum no {
              tailf:info "Policy and CLI will run asynchronously";
            }
            enum yes {
              tailf:info "Run policy and the result determines whether "+
              "to run CLI";
            }
          }
        }
        leaf skip {
          tailf:info "Whether to skip CLI command execution";
          type enumeration {
            enum no {
              tailf:info "CLI command should be executed";
            }
            enum yes {
              tailf:info "CLI command should not be executed";
            }
          }
        }
      }
    }

    // event manager applet * / event track
    container track {
      tailf:info "Tracking object event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf object-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-1000>;;Tracking object number";
        }
      }
      leaf state {
        tailf:info "State of tracking object";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum any {
            tailf:info "Any state";
          }
          enum down {
            tailf:info "Down state";
          }
          enum up {
            tailf:info "Up state";
          }
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event neighbor-discovery
    container neighbor-discovery {
      tailf:info "Neighbor Discovery event";
      tailf:cli-compact-syntax;
      container interface {
        tailf:info "Interface name";
        tailf:cli-flatten-container;
        leaf regexp {
          tailf:info "Specify a regexp for interfaces";
          type string {
            tailf:info "WORD;;interface name string";
          }
        }
      }
      leaf cdp {
        tailf:info "Monitor CDP events";
        type enumeration {
          enum add {
            tailf:info "Monitor only CDP add events";
          }
          enum all {
            tailf:info "Monitor all CDP events";
          }
          enum delete {
            tailf:info "Monitor only CDP delete events";
          }
          enum update {
            tailf:info "Monitor CDP add and update events";
          }
        }
      }
    }

    // event manager applet * / event timer
    container timer {
      tailf:info "Timer event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf trigger {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum absolute {
            tailf:info "Absolute timer event";
          }
          enum countdown {
            tailf:info "Countdown timer event";
          }
          enum watchdog {
            tailf:info "Watchdog timer event";
          }
          enum cron {
            tailf:info "Cron timer event";
          }
        }
      }
      leaf name {
        tailf:info "Name of the timer";
        type string {
          tailf:info "WORD;;Timer name string";
        }
      }
      leaf cron-entry {
        tailf:info "Cron entry for cron timer";
        type string {
          tailf:info "WORD;;Cron entry string";
        }
      }
      leaf time {
        tailf:info "Time period for watchdog / countdown / absolute timer";
        type uint32 {
          tailf:info "<1-4294967295>;;Enter seconds[.milliseconds] value";
          range "1..4294967295";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
      leaf ratelimit {
        tailf:info "Limit trigger to once per given time period";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }

    // event manager applet * / event snmp
    container snmp {
      tailf:info "SNMP event";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf oid {
        tailf:info "Object ID of data element";
        type string {
          tailf:info "WORD;;OID string";
        }
      }
      leaf get-type {
        tailf:cli-break-sequence-commands;
        tailf:info "Type of SNMP get operation";
        type enumeration {
          enum exact {
            tailf:info "Exact oid specified";
          }
          enum next {
            tailf:info "Next available oid";
          }
        }
      }
      leaf entry-op {
        tailf:info "Entry comparison operator";
        type operator-type;
      }
      leaf entry-val {
        tailf:info "Entry comparison value";
        type string {
          tailf:info "WORD;;Entry value";
        }
      }
      leaf exit-op {
        tailf:info "Exit operator";
        type operator-type;
      }
      leaf exit-val {
        tailf:info "Exit comparison value";
        type string {
          tailf:info "WORD;;Entry value";
        }
      }
      leaf poll-interval {
        tailf:info "Poll interval value";
        type uint32 {
          tailf:info "<0-4294967295>;;Enter seconds[.milliseconds] value";
        }
      }
    }

    // event manager applet * / event ipsla
    container ipsla {
      tailf:info "IPSLA Event";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf operation-id {
        tailf:info "IPSLA Operation ID";
        type uint32 {
          tailf:info "<1-2147483647>;;Operation ID value";
          range "1..2147483647";
        }
      }
      leaf reaction-type {
        tailf:info "IPSLA Reaction Type";
        type string {
          tailf:info "WORD;;Reaction Type";
        }
      }
      leaf maxrun {
        tailf:info "Maximum runtime of applet";
        type uint32 {
          tailf:info "<0-31536000>;;Enter seconds[.milliseconds] value";
          range "0..31536000";
        }
      }
    }
  }

  // vrf definition * / route-target
  // vrf definition * / address-family ipv4 / route-target
  // l2vpn vfi context * / autodiscovery bgp signaling * / route-target
  // l2 vfi * / route-target
  grouping route-target-grouping {

    list "export" {
      tailf:info "Export Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN "+
            "Extended Community";
        }
      }
    }

    list "import" {
      tailf:info "Import Target-VPN community";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key asn-ip;
      leaf asn-ip {
        type asn-ip-type {
          tailf:info "ASN:nn or IP-address:nn;;Target VPN Extended Community";
        }
      }
    }
  }

  // vrf definition * / address-family ipv4
  // vrf definition * / address-family ipv6
  grouping vrf-definition-af-grouping {

    // vrf definition * / address-family ipv4 / export
    container export {
      tailf:info "VRF export";
      leaf map {
        tailf:info "Route-map based VRF export";
        type string {
          tailf:info "WORD;;Route-map reference";
        }
      }
    }

    // vrf definition * / address-family ipv4 / route-target
    container route-target {
      tailf:info "Specify Target VPN Extended Communities";
      uses route-target-grouping;
    }

    // vrf definition * / address-family ipv4 / maximum routes
    container maximum {
      tailf:info "Set a limit";
      container routes {
        tailf:info "Maximum number of routes allowed in this routing table";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967294>;;Maximum number of routes allowed";
          }
        }
        choice action {
          case a {
            leaf warning-only {
              tailf:info "Only give a warning message if limit is exceeded";
              type empty;
            }
          }
          case b {
            leaf warn-threshold {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to "+
                  "generate a warning msg";
                range "1..100";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due to over "+
                "maximum route limit";
              type uint8 {
                tailf:info "<1-100>;;Threshold value (%) at which to "+
                  "reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
        }
      }
    }
  }

  // snmp-server host *
  grouping snmp-server-host-grouping {

    // snmp-server host * traps
    // snmp-server host * informs
    leaf message-type {
      tailf:cli-optional-in-sequence;
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum informs {
          tailf:info "Send Inform messages to this host";
        }
        enum traps {
          tailf:info "Send Trap messages to this host";
        }
      }
      default traps;
    }

    // snmp-server host * version
    container version {
      tailf:info "SNMP version to use for notification messages";
      tailf:cli-optional-in-sequence;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      leaf version {
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1" {
            tailf:info "Use SNMPv1";
          }
          enum "2c" {
            tailf:info "Use SNMPv2c";
          }
          enum "3" {
            tailf:info "Use SNMPv3";
          }
        }
      }
      leaf security-level {
        tailf:cli-drop-node-name;
        when "../version = '3'"  {
          tailf:dependency "../version";
        }
        type enumeration {
          enum auth {
            tailf:info "Use the SNMPv3 authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Use the SNMPv3 noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Use the SNMPv3 authPriv Security Level";
          }
        }
      }
    }

    // snmp-server host * community-string
    leaf community-string {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "version|informs|traps|vrf";
      type string {
        tailf:info "WORD;;SNMPv1/v2c community string or SNMPv3 user name";
      }
    }

    // snmp-server host * community-string
    leaf-list allowed-traps {
      tailf:cli-drop-node-name;
      tailf:cli-flat-list-syntax {
        tailf:cli-replace-all;
      }
      type enumeration {
        enum aaa_server {
          tailf:info "Allow SNMP AAA traps";
        }
        enum alarms {
          tailf:info "Allow SNMP alarms traps";
        }
        enum atm {
          tailf:info "Allow SNMP atm traps";
        }
        enum bfd {
          tailf:info "Allow SNMP BFD traps";
        }
        enum bgp {
          tailf:info "Allow BGP state change traps";
        }
        enum bstun {
          tailf:info "Allow bstun event traps";
        }
        enum bulkstat {
          tailf:info "Allow Data-Collection-MIB traps";
        }
        enum cable {
          tailf:info "Allow SNMP cable traps";
        }
        enum call-home {
          tailf:info "Allow SNMP CISCO-CALLHOME-MIB traps";
        }
        enum casa {
          tailf:info "Allow casa event traps";
        }
        enum cef {
          tailf:info "Allows cef traps";
        }
        enum cnpd {
          tailf:info "Allow NBAR Protocol Discovery traps";
        }
        enum config {
          tailf:info "Allow SNMP config traps";
        }
        enum config-copy {
          tailf:info "Allow SNMP config-copy traps";
        }
        enum config-ctid {
          tailf:info "Allow SNMP config-ctid traps";
        }
        enum cpu {
          tailf:info "Allow cpu related traps";
        }
        enum dhcp {
          tailf:info "Allow dhcp traps";
        }
        enum dlsw {
          tailf:info "Allow dlsw traps";
        }
        enum ds1 {
          tailf:info "Allow SNMP ds1 traps";
        }
        enum dsp {
          tailf:info "Allow SNMP DSP traps";
        }
        enum dspu {
          tailf:info "Allow dspu event traps";
        }
        enum eigrp {
          tailf:info "Allow SNMP EIGRP traps";
        }
        enum entity {
          tailf:info "Allow SNMP entity traps";
        }
        enum entity-diag {
          tailf:info "Allow SNMP CISCO-ENTITY-DIAG-MIB traps";
        }
        enum entity-qfp {
          tailf:info "Allow SNMP CISCO-ENTITY-QFP-MIB traps";
        }
        enum entity-state {
          tailf:info "Allow ENTITY-STATE-MIB traps";
        }
        enum envmon {
          tailf:info "Allow environmental monitor traps";
        }
        enum ethernet-cfm {
          tailf:info "Allow SNMP Ethernet CFM traps";
        }
        enum evc {
          tailf:info "Allow SNMP EVC traps";
        }
        enum event-manager {
          tailf:info "Allow SNMP Embedded Event Manager traps";
        }
        enum firewall {
          tailf:info "Allow SNMP Firewall traps";
        }
        enum flash {
          tailf:info "Allow SNMP FLASH traps";
        }
        enum flowmon {
          tailf:info "Allow SNMP flow monitor notifications";
        }
        enum frame-relay {
          tailf:info "Allow SNMP frame-relay traps";
        }
        enum fru-ctrl {
          tailf:info "Allow entity FRU control traps";
        }
        enum gdoi {
          tailf:info "Allows gdoi traps";
        }
        enum hsrp {
          tailf:info "Allow SNMP HSRP traps";
        }
        enum iplocalpool {
          tailf:info "Allow SNMP IP Local Pool traps";
        }
        enum ipmulticast {
          tailf:info "Allow SNMP ipmulticast traps";
        }
        enum ipsec {
          tailf:info "Allow SNMP IPsec traps";
        }
        enum ipsla {
          tailf:info "Allow SNMP Host IP SLA traps";
        }
        enum isakmp {
          tailf:info "Allow SNMP ISAKMP traps";
        }
        enum isg-mib {
          tailf:info "Allow SNMP isgmib traps";
        }
        enum isis {
          tailf:info "Allow IS-IS traps";
        }
        enum l2tun-pseudowire-status {
          tailf:info "Allow SNMP L2 pseudowire status traps";
        }
        enum l2tun-session {
          tailf:info "Allow SNMP L2 session traps";
        }
        enum license {
          tailf:info "Allow license traps";
        }
        enum mac-notification {
          tailf:info "Allow SNMP MAC Notification Traps";
        }
        enum memory {
          tailf:info "Allow SNMP Mempool traps";
        }
        enum mpls-fast-reroute {
          tailf:info "Allow SNMP MPLS traffic engineering fast reroute traps";
        }
        enum mpls-ldp {
          tailf:info "Allow SNMP MPLS label distribution protocol traps";
        }
        enum mpls-traffic-eng {
          tailf:info "Allow SNMP MPLS traffic engineering traps";
        }
        enum mpls-vpn {
          tailf:info "Allow SNMP MPLS Virtual Private Network traps";
        }
        enum msdp {
          tailf:info "Allow SNMP MSDP traps";
        }
        enum mvpn {
          tailf:info "Allow Multicast Virtual Private Network traps";
        }
        enum nhrp {
          tailf:info "Allow SNMP NHRP traps";
        }
        enum ospf {
          tailf:info "Allow OSPF traps";
        }
        enum ospfv3 {
          tailf:info "Allow OSPFv3 traps";
        }
        enum pfr {
          tailf:info "Allow SNMP PfR traps";
        }
        enum pim {
          tailf:info "Allow SNMP PIM traps";
        }
        enum pw-vc {
          tailf:info "Allow SNMP Pseudowire VC traps";
        }
        enum resource-policy {
          tailf:info "Enable CISCO-ERM-MIB notifications";
        }
        enum rf {
          tailf:info "Allow all SNMP traps defined in CISCO-RF-MIB";
        }
        enum rsrb {
          tailf:info "Allow rsrb event traps";
        }
        enum rsvp {
          tailf:info "Allow RSVP flow change traps";
        }
        enum sdlc {
          tailf:info "Allow sdlc event traps";
        }
        enum sdllc {
          tailf:info "Allow sdllc event traps";
        }
        enum snmp {
          tailf:info "Allow SNMP-type notifications";
        }
        enum sonet {
          tailf:info "Allow SNMP SONET traps";
        }
        enum srp {
          tailf:info "Allow SRP protocol traps";
        }
        enum stun {
          tailf:info "Allow stun event traps";
        }
        enum syslog {
          tailf:info "Allow SNMP syslog traps";
        }
        enum trustsec-sxp {
          tailf:info "Allow SNMP CISCO-TRUSTSEC-SXP-MIB traps";
        }
        enum tty {
          tailf:info "Allow TCP connection traps";
        }
        enum udp-port {
          tailf:info "The notification host's UDP port number (default port "
            +"162)";
        }
        enum voice {
          tailf:info "Allow SNMP Voice traps";
        }
        enum vrfmib {
          tailf:info "Allow SNMP vrfmib traps";
        }
        enum vrrp {
          tailf:info "Allow SNMP vrrp traps";
        }
        enum x25 {
          tailf:info "Allow x25 event traps";
        }
      }
    }
  }


  // aaa authentication login *
  // aaa authentication ppp *
  grouping aaa-authentication-method-grouping {

    // aaa authentication login * cache
    leaf cache {
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authentication login * group
    leaf group {
      tailf:info "Use Server-group";
      type aaa-group-type;
    }
    container group2 {
      when "../group" {
        tailf:dependency "../group";
      }
      tailf:cli-drop-node-name;
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      leaf group {
        tailf:info "Use Server-group 2";
        type aaa-group-type;
      }
    }

    // aaa authentication login * krb5
    leaf krb5 {
      tailf:info "Use Kerberos 5 authentication.";
      type empty;
    }

    choice local-choice {
      // aaa authentication login * local
      leaf local {
        tailf:info "Use local username authentication.";
        type empty;
      }
      // aaa authentication login * local-case
      leaf local-case {
        tailf:info "Use case-sensitive local username authentication.";
        type empty;
      }
    }

    // aaa authentication login * tacacs+
    leaf "tacacsplus" {
      tailf:alt-name "tacacs+";
      tailf:info "Use enable password for authentication.";
      type empty;
    }

    // aaa authentication login * line
    leaf line {
      tailf:info "Use line password for authentication.";
      type empty;
    }

    // aaa authentication login * enable
    leaf enable {
      tailf:info "Use enable password for authentication.";
      type empty;
    }

    // aaa authentication login * none
    leaf none {
      tailf:info "NO authentication.";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa authorization exec *
  // aaa authorization commands *
  // aaa authorization eventmanager *
  // aaa authorization network *
  grouping aaa-authorization-method-grouping {

    // aaa authorization exec * cache
    leaf cache {
      tailf:info "Use Cached-group";
      type aaa-group-type;
    }

    // aaa authorization exec * group
    leaf group {
      tailf:info "Use server-group.";
      type aaa-group-type;
    }

    // aaa authorization exec * krb5-instance
    leaf krb5-instance {
      tailf:info "Use Kerberos instance privilege maps.";
      type empty;
    }

    // aaa authorization exec * tacacs+
    leaf "tacacsplus" {
      tailf:alt-name "tacacs+";
      tailf:info "Use enable password for authorization.";
      type empty;
    }

    // aaa authorization exec * local
    leaf local {
      tailf:info "Use local database.";
      type empty;
    }

    // aaa authorization exec * if-authenticated
    leaf if-authenticated {
      tailf:info "Succeed if user has authenticated.";
      type empty;
    }

    // aaa authorization exec * none
    leaf none {
      tailf:info "No authorization (always succeeds).";
      tailf:cli-full-command;
      type empty;
    }
  }

  // aaa accounting exec *
  // aaa accounting commands *
  // aaa accounting network *
  // aaa accounting connection *
  // aaa accounting system default
  grouping aaa-accounting-method-grouping {

    // aaa accounting exec * none
    // aaa accounting exec * start-stop
    // aaa accounting exec * stop-only
    leaf action-type {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type enumeration {
        enum none {
          tailf:info "No accounting.";
        }
        enum start-stop  {
          tailf:info "Record start and stop without waiting";
        }
        enum stop-only {
          tailf:info "Record stop when service terminates.";
        }
      }
    }

    // aaa accounting exec * broadcast
    leaf broadcast {
      tailf:info "Use Broadcast for Accounting";
      tailf:cli-no-name-on-delete;
      type empty;
    }

    // aaa accounting exec * group
    leaf group {
      tailf:info "Use Server-group";
      tailf:cli-no-name-on-delete;
      tailf:cli-no-value-on-delete;
      type aaa-group-type;
    }
  }

  // cable modulation-profile *
  grouping cable-modulation-profile-grouping {
    leaf fec-tbytes {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-16>;;FEC tbytes";
      }
    }
    leaf fec-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<16-253>;;FEC codeword length in k bytes";
      }
    }
    leaf burst-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;max burst size in minislots";
      }
    }
    leaf guard-t {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<0-255>;;guard time in symbols";
      }
    }
    leaf mod {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum "8qam" {
          tailf:info "8-QAM modulation";
        }
        enum "16qam" {
          tailf:info "16-QAM modulation";
        }
        enum "32qam" {
          tailf:info "32-QAM modulation";
        }
        enum "64qam" {
          tailf:info "64-QAM modulation";
        }
        enum "qpsk" {
          tailf:info "qpsk modulation";
        }
      }
    }
    leaf scrambler {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum no-scrambler {
          tailf:info "scrambler disabled";
        }
        enum scrambler {
          tailf:info "scrambler enabled";
        }
      }
    }
    leaf seed {
      when "../scrambler = 'scrambler'" {
        tailf:dependency "../scrambler";
      }
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type string {
        tailf:info "<0x0-0x7FFF>;;scrambler seed in hex";
      }
    }
    leaf diff {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type enumeration {
        enum diff {
          tailf:info "diff encoding enabled";
        }
        enum no-diff {
          tailf:info "diff encoding disabled";
        }
      }
    }
    leaf pre-len {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<4-1536>;;preamble length in bits";
      }
    }
    leaf last-cw {
      tailf:cli-drop-node-name;
      type enumeration {
        enum fixed {
          tailf:info "fixed codeword";
        }
        enum shortened {
          tailf:info "shortened codeword";
        }
      }
    }
    leaf preamble {
      tailf:cli-drop-node-name;
      type enumeration {
        enum qpsk0 {
          tailf:info "QPSK0 preamble";
        }
        enum qpsk1 {
          tailf:info "QPSK1 preamble";
        }
      }
    }
    leaf rs-interleave-depth {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-114>;;RS interleave depth";
      }
    }
    leaf rs-interleave-block {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<18-2048>;;RS interleave block size";
      }
    }
  }


  // cable modulation-profile *
  grouping cable-modulation-profile-list-grouping {

    // cable modulation-profile * request
    container request {
      tailf:info "Request Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * initial
    container initial {
      tailf:info "Initial Ranging Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * station
    container station {
      tailf:info "Station Ranging Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * short
    container short {
      tailf:info "Short Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * long
    container long {
      tailf:info "Long Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-short
    container a-short {
      tailf:info "Advanced Phy Short Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-long
    container a-long {
      tailf:info "Advanced Phy Long Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }

    // cable modulation-profile * a-ugs
    container a-ugs {
      tailf:info "Advanced Phy Unsolicited Grant Burst";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      uses cable-modulation-profile-grouping;
    }
  }

  // cable load-balance docsis-group *
  // cable load-balance docsis-group FN *
  grouping cable-load-balance-docsis-group-grouping {

    // cable load-balance docsis-group * / restricted
    leaf restricted {
      tailf:info "Set load balance group as restricted";
      type empty;
    }

    // cable load-balance docsis-group * / downstream
    container downstream {
      tailf:info "Set downstream RF channels";

      // cable load-balance docsis-group * / downstream Modular-Cable *
      list Modular-Cable {
        tailf:info "Modular cable";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }

      // cable load-balance docsis-group * / downstream Integrated-Cable *
      list Integrated-Cable {
        tailf:info "Integrated cable";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf rf-channel {
          tailf:info "RF channel";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;List of port numbers and number ranges";
          }
        }
      }
    }

    // cable load-balance docsis-group * / upstream
    container upstream {
      tailf:info "Set upstream channels";

      // cable load-balance docsis-group * / upstream Upstream-Cable *
      list Upstream-Cable {
        tailf:info "Upstream Cable Controller";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf us-channel {
          tailf:info "Associate physical us channels";
          tailf:cli-multi-value;
          type string {
            tailf:info "<grouplist>;;Physical us channel numbers and number ranges";
          }
        }
      }

      // cable load-balance docsis-group * / upstream Cable *
      list Cable {
        tailf:info "CMTS interface";
        tailf:cli-allow-join-with-key;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
          }
        }
        leaf upstream-list {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<grouplist>;;List of Ranges for upstream channels <0-7>";
          }
        }
      }
    }

    // cable load-balance docsis-group * / method
    container method {
      tailf:info "Set load balancing type/method";
      container utilization {
        tailf:info "Interface utilization";
        presence true;
      }
    }

    // cable load-balance docsis-group * / threshold
    container threshold {
      tailf:info "Load balancing threshold in %";

      // cable load-balance docsis-group * / threshold load
      container load {
        tailf:info "Interface load threshold settings";
        leaf percentage {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;Threshold value in %";
            range "1..100";
          }
        }
        // cable load-balance docsis-group * / threshold load minimum
        leaf minimum {
          tailf:info "Set minimum number of modems/flows difference "+
            "before loadbalancing starts";
          type uint8 {
            tailf:info "<1-100>;;Minimum number of modems/flows";
            range "1..100";
          }
        }
      }

      // cable load-balance docsis-group * / threshold stability
      leaf stability {
        tailf:info "Threshold for stability detection";
        type uint8 {
          tailf:info "<0-100>;;Stability condition detection threshold in %";
          range "0..100";
        }
      }
    }

    // cable load-balance docsis-group * / policy
    leaf policy {
      tailf:info "Set load balancing policy";
      type enumeration {
        tailf:info "pure-ds-load;;Do not count US load when calculating "+
          "DS utilization";
        enum pcmm {
          tailf:info "Enable balancing of modems with active PCMM service "+
          "flows";
        }
        enum pure-ds-load {
          tailf:info "Do not count US load when calculating DS utilization";
        }
        enum ugs {
          tailf:info "Enable balancing of modems with active UGS service "+
          "flows";
        }
        enum us-across-ds {
          tailf:info "Load balancing on US groups across DS, DS method will "+
            "be ignored";
        }
      }
    }

    // cable load-balance docsis-group * / interval
    leaf interval {
      tailf:info "Set interface polling interval";
      type uint16 {
        tailf:info "<1-1000>;;Interface polling interval in seconds";
        range "1..1000";
      }
    }

    // cable load-balance docsis-group * / init-tech-list
    container init-tech-list {
      tailf:info "Set DCC initialization technique list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf grouplist {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "<grouplist> ";
        }
      }
      leaf ucc {
        tailf:info "Allow the use of UCC in upstream load balancing";
        type empty;
      }
    }

    // cable load-balance docsis-group * / docsis-policy
    leaf docsis-policy {
      tailf:info "Enter load balance group policy";
      type uint32 {
        tailf:info "<0-4294967295>;;Load balance group policy number";
        range "0..4294967295";
      }
    }

    // cable load-balance docsis-group * / tag *
    list tag {
      tailf:info "Add tag to load balancing group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;tag name";
        }
      }
    }
  }

  // facility-alarm outlet-temperature
  grouping facility-alarm-grouping {

    // facility-alarm outlet-temperature major
    container major {
      tailf:info "Major warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature minor
    container minor {
      tailf:info "Minor warning threshold";
      leaf temperature {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<20-100>;;<##> threshold temperature (degrees C)";
          range "20..100";
        }
      }
    }

    // facility-alarm outlet-temperature critical
    container critical {
      tailf:info "Critical warning threshold";

      // facility-alarm outlet-temperature critical exceed-action shutdown
      leaf exceed-action {
        tailf:info "Critical outlet temperature exceed action";
        tailf:cli-full-command;
        type enumeration {
          enum shutdown {
            tailf:info "Auto-shutdown when critical outlet temperature "+
            "is exceeded";
          }
        }
      }

      // facility-alarm outlet-temperature critical
      leaf temperature {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;<##> threshold temperature (degrees C)";
          range "1..255";
        }
      }
    }
  }

  // process cpu threshold type total
  // process cpu threshold type interrupt
  // process cpu threshold type process
  grouping process-cpu-threshold-grouping {
    leaf rising {
      tailf:info "rising threshold";
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    leaf interval {
      tailf:info "observation interval";
      type uint32 {
        tailf:info "<5-86400>";
        range "5..86400";
      }
    }
    leaf falling {
      tailf:info "falling threshold ";
      type uint8 {
        tailf:info "<1-100>";
        range "1..100";
      }
    }
    container falling-interval {
      tailf:cli-flatten-container;
      tailf:cli-drop-node-name;
      leaf interval {
        tailf:info "observation interval";
        type uint32 {
          tailf:info "<5-86400>";
          range "5..86400";
        }
      }
    }
  }

  // cable submgmt default filter-group cm
  // cable submgmt default filter-group cpe
  // cable submgmt default filter-group mta
  // cable submgmt default filter-group stb
  // cable submgmt default filter-group ps
  grouping cable-submgmt-default-filter-group-grouping {
    leaf upstream {
      tailf:info "Default Upstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
    leaf downstream {
      tailf:info "Default Downstream Group";
      type uint8 {
        tailf:info "<1-254>;;Group ID";
        range "1..254";
      }
    }
  }

  // interface * / storm-control broadcast level
  // interface * / storm-control multicast level
  // interface * / storm-control unicast level
  grouping storm-control-level-bps-pps-grouping {
    container level-bps-pps {
      tailf:cli-drop-node-name;
      container level {
        tailf:info "Set storm suppression level on this interface";
        choice level-choice {
          leaf bps {
            tailf:info "Enter suppression level in bits per second";
            type string {
              tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
            }
          }
          leaf pps {
            tailf:info "Enter suppression level in packets per second";
            type string {
              tailf:info "<0.0 - 10000000000.0>[k|m|g];;Enter rising threshold";
            }
          }
        }
      }
    }
  }

  grouping logging-host-grouping {

    // logging host * / discriminator
    leaf discriminator {
      tailf:info "Specify a message discriminator identifier for this "
        +"logging session";
      type string {
        tailf:info "WORD;;Message discriminator identifier for this logging "
          +"session (8 chars. max)";
      }
    }

    // logging host * / session-id
    container session-id {
      tailf:info "Specify syslog message session ID tagging";
      tailf:cli-flatten-container;
      choice session-id-choice {
        leaf hostname {
          tailf:info "Include hostname in session ID tag";
          type empty;
        }
        leaf ipv4 {
          tailf:info "Include logging source IP address in session ID tag";
          type empty;
        }
        leaf ipv6 {
          tailf:info "Include logging source IPV6 address in session ID tag";
          type empty;
        }
        leaf string {
          tailf:info "Include custom string in session ID tag";
          type string {
            tailf:info "WORD;;Custom string in [s_id=\"custom_string\"] tag";
          }
        }
      }
    }

    // logging host * / transport
    leaf transport {
      tailf:info "Specify the transport protocol (default=UDP)";
      type enumeration {
        enum beep {
          tailf:info "Blocks Extensible Exchange Protocol";
        }
        enum tcp {
          tailf:info "Transport Control Protocol";
        }
        enum udp {
          tailf:info "User Datagram Protocol";
        }
      }
    }

    // logging host * / port
    leaf port {
      tailf:info "Specify the transport port number";
      when "../transport" {
        tailf:dependency "../transport";
      }
      type uint16 {
        tailf:info "<1-65535>;;Port number";
        range "1..65535";
      }
    }
  }


  grouping crypto-ikev2-profile-aaa-authorization-group-list {

    container "list" {
      tailf:info "AAA method list";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf list-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;AAA list name";
        }
      }
      leaf aaa-username {
        tailf:cli-break-sequence-commands;
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;AAA username";
        }
      }
      leaf name-mangler {
        tailf:info "Specify the name-mangler to derive AAA username";
        tailf:non-strict-leafref {
          path "../../../../../../../../ikev2/name-mangler/name";
        }
        type string {
          tailf:info "WORD;;mangler name";
        }
      }
      container password {
        tailf:info "Specify the AAA password";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses crypto-key-grouping;
      }
    }
  }

  // parameter-map type inspect * /
  // parameter-map type inspect-global /
  grouping parameter-map-grouping {

    // parameter-map type inspect * / alert
    leaf alert {
      tailf:info "Turn on/off alert";
      type enumeration {
        enum off {
          tailf:info "Turn off alert";
        }
        enum on {
          tailf:info "Turn on alert";
        }
      }
    }

    // parameter-map type inspect * / audit-trail
    leaf audit-trail {
      tailf:info "Turn on/off audit trail";
      type enumeration {
        enum off {
          tailf:info "Turn off audit trail";
        }
        enum on {
          tailf:info "Turn on audit trail";
        }
      }
    }

    // parameter-map type inspect * / dns-timeout
    leaf dns-timeout {
      tailf:info "Specify timeout for DNS";
      type uint32 {
        tailf:info "<1-2147483>;;Timeout in seconds";
        range "1..2147483";
      }
    }

    // parameter-map type inspect * / icmp
    container icmp {
      tailf:info "Config timeout values for icmp";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf idle-time {
        tailf:info "Specify timeout for icmp";
        type uint32 {
          tailf:info "<1-2147483>;;Timeout in seconds";
          range "1..2147483";
        }
      }
      leaf ageout-time {
        tailf:info "Specify aggressive age-out time for icmp";
        type uint32 {
          tailf:info "<1-2147483>;;Timeout in seconds";
          range "1..2147483";
        }
      }
    }

    // parameter-map type inspect * / max-destination
    leaf max-destination {
      tailf:info "config maximum destination";
      type uint32 {
        tailf:info "<1-4294967295>;;maximum destination value";
        range "1..4294967295";
      }
    }

    // parameter-map type inspect * / max-incomplete
    container max-incomplete {
      tailf:info "Specify maximum number of incomplete connections before "
        +"clamping";

      // parameter-map type inspect * / max-incomplete ?
      container half-open-sessions {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;half-open sessions";
            range "1..4294967295";
          }
        }
        container aggressive-aging {
          tailf:info "Aggressive Aging parameters";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf high {
            tailf:info "Specify the high watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;High watermark in absolute values";
              range "1..4294967295";
            }
          }
          leaf low {
            tailf:info "Specify the low watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;Low watermark in absolute values";
              range "1..4294967295";
            }
          }
        }
      }

      // parameter-map type inspect * / max-incomplete high
      leaf high {
        tailf:info "Specify high-watermark for clamping";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }

      // parameter-map type inspect * / max-incomplete low
      leaf low {
        tailf:info "Specify low-watermark for clamping";
        tailf:cli-full-command;
        type uint32 {      // parameter-map type inspect * / max-incomplete high
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }
    }

    // parameter-map type inspect * / one-minute
    container one-minute {
      tailf:info "Specify one-minute-sample watermarks for clamping";
      leaf high {
        tailf:info "Specify high-watermark for clamping";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }
      leaf low {
        tailf:info "Specify low-watermark for clamping";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of connections";
          range "1..2147483647";
        }
      }
    }

    // parameter-map type inspect * / session total
    container session {
      tailf:info "Configure session total";
      container total {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf number {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;session total number";
            range "1..4294967295";
          }
        }
        container aggressive-aging {
          tailf:info "Aggressive Aging parameters";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf high {
            tailf:info "Specify the high watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;High watermark in absolute values";
              range "1..4294967295";
            }
          }
          leaf low {
            tailf:info "Specify the low watermark for aggressive-aging";
            type uint32 {
              tailf:info "<1-4294967295>;;Low watermark in absolute values";
              range "1..4294967295";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / sessions maximum
    container sessions {
      tailf:info "Maximum number of inspect sessions";
      leaf maximum {
        tailf:info "Maximum sessions";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of sessions";
          range "1..2147483647";
        }
      }
    }

    // parameter-map type inspect * / tcp
    container tcp {
      tailf:info "Config timeout values for tcp connections";

      // parameter-map type inspect * / tcp finwait-time
      container finwait-time {
        tailf:info "Specify timeout for TCP connections after a FIN";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for fin wait=time";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
          }
        }
      }

      // parameter-map type inspect * / tcp idle-time
      container idle-time {
        tailf:info "Specify idle timeout for tcp connections";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for tcp";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / tcp max-incomplete
      container max-incomplete {
        tailf:info "Specify max half-open connection per host";
        leaf host {
          tailf:info "Specify max half-open connection per host";
          type uint32 {
            tailf:info "<1-4294967295>;;half-open sessions";
            range "1..4294967295";
          }
        }
      }

      // parameter-map type inspect * / tcp synwait-time
      container synwait-time {
        tailf:info "Specify timeout for TCP connections after a SYN and no";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time syn wait-time";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / tcp syn-flood
      container syn-flood {
        tailf:info "syn-flood config";

        // parameter-map type inspect * / tcp syn-flood limit
        leaf limit {
          tailf:info "syn-flood limit";
          type uint32 {
            tailf:info "<1-4294967295>;;number of half-open connections that triggers SYN cookie";
            range "1..4294967295";
          }
        }

        // parameter-map type inspect * / tcp syn-flood rate per-destination
        container rate {
          tailf:info "maximum syn packet rate";
          leaf per-destination {
            tailf:info "per destination";
            type uint32 {
              tailf:info "<1-1000000000>;;maximum rate of TCP SYN packets";
              range "1..1000000000";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / udp
    container udp {
      tailf:info "Config timeout values for udp flows";

      // parameter-map type inspect * / udp idle-time
      container idle-time {
        tailf:info "Specify idle timeout for udp";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
        leaf ageout-time {
          tailf:info "Specify aggressive age-out time for udp";
          type uint32 {
            tailf:info "<1-2147483>;;Timeout in seconds";
            range "1..2147483";
          }
        }
      }

      // parameter-map type inspect * / udp half-open
      container half-open {
        tailf:info "Config timeout values for udp half open flow";
        container idle-time {
          tailf:info "Specify idle timeout for udp half open";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in miliseconds";
              range "1..2147483";
            }
          }
          leaf ageout-time {
            tailf:info "Specify aggressive age-out time for udp half open";
            type uint32 {
              tailf:info "<1-2147483>;;Timeout in miliseconds";
              range "1..2147483";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / log
    container log {
      tailf:info "Inspect packet logging";
      leaf dropped-packets {
        tailf:info "log packets dropped by the firewall";
        type empty;
      }
    }

    // parameter-map type inspect * / threat-detection
    container threat-detection {
      tailf:info "Configure Threat Detection";

      // parameter-map type inspect * / threat-detection basic-threat
      leaf basic-threat {
        tailf:info "Enable Threat Detection";
        tailf:cli-full-command;
        type empty;
      }

      // parameter-map type inspect * / threat-detection rate
      container rate {
        tailf:info "Configure Threat Detection rate";

        // parameter-map type inspect * / threat-detection rate syn-attack
        container syn-attack {
          tailf:info "Configure Threat Detection rate for syn attack events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }

        // parameter-map type inspect * / threat-detection rate inspect-drop
        container inspect-drop {
          tailf:info "Configure Threat Detection rate for firewall inspection based drop events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }

        // parameter-map type inspect * / threat-detection rate fw-drop
        container fw-drop {
          tailf:info "Configure Threat Detection rate for firewall drop events";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf average-time-frame {
            tailf:info "Configure Threat Detection average time frame";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<600-3600>;;average time frame in seconds";
              range "6..3600";
            }
          }
          leaf average-threshold {
            tailf:info "Configure Threat Detection average threshold";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;average threshold in pkts/sec";
              range "1..4294967295";
            }
          }
          leaf burst-threshold {
            tailf:info "Configure Threat Detection burst threshold";
            type uint32 {
              tailf:info "<1-1000000000>;;burst threshold in pkts/sec";
              range "1..1000000000";
            }
          }
        }
      }
    }

    // parameter-map type inspect * / vrf * inspect
    list vrf {
      tailf:info "vrf binding with parameter map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key vrf;
      leaf vrf {
        tailf:cli-diff-dependency "../../../../../ip/vrf";
        tailf:cli-diff-dependency "../../../../../vrf/definition";
        type string {
          tailf:info "WORD;;vrf name";
        }
      }
      leaf inspect {
        tailf:info "vrf binding with parameter map";
        tailf:non-strict-leafref {
          path "../../../inspect-vrf/name";
        }
        type string {
          tailf:info "WORD;;parameter-map name";
        }
      }
    }
  }


  // qos map dscp * to cos
  // qos map dscp * to tx-queue
  grouping dscp-value-0-7-grouping {

    leaf dscp-value0 {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value1 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value2 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value3 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value4 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value5 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value6 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
    leaf dscp-value7 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-63>;;DSCP values separated by spaces "+
          "(up to 8 values total)";
        range "0..63";
      }
    }
  }


  // qos map cos * to dscp
  grouping cos-value-0-7-grouping {

    leaf cos-value0 {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value1 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value2 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value3 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value4 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value5 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value6 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
    leaf cos-value7 {
      tailf:cli-drop-node-name;
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      type uint8 {
        tailf:info "<0-7>;;CoS values separated by spaces "+
          "(up to 8 values total)";
        range "0..7";
      }
    }
  }

  // controller Modular-Cable * / rf-channel *
  grouping controller-modular-cable-rf-channel-grouping {

    // controller Modular-Cable * / rf-channel *
    list rf-channel {
      tailf:info "RF channel configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key rf-port;
      leaf rf-port {
        type uint8 {
          tailf:info "<0-23>;;RF channel number";
          range "0..23";
        }
      }

      // controller Modular-Cable * / rf-channel * description
      leaf "description" {
        tailf:info "configure RF channel name/description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this RF channel that will be "+
            "truncated to 80 characters";
        }
      }

      // controller Modular-Cable * / rf-channel * cable downstream
      container cable {
        tailf:info "configure RF channel cable downstream channel-id";
        container downstream {
          tailf:info "configure RF channel cable downstream channel-id";
          leaf channel-id {
            tailf:info "configure RF channel cable downstream channel-id";
            type uint8 {
              tailf:info "<1-255>;;RF channel cable downstream channel-id";
              range "1..255";
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * frequency
      container frequency {
        tailf:info "configure RF channel frequency in Hz";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf freq {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<55000000-1050000000>;;Frequency in Hz";
              range "55000000..1050000000";
            }
            type enumeration {
              enum none {
                tailf:info "No Frequency configured";
              }
            }
          }
        }
        leaf annex {
          tailf:info "ITU-T J.83 MPEG standard";
          tailf:cli-incomplete-command;
          type enumeration {
            enum "A" {
              tailf:info "Annex A, European Standard";
            }
            enum "B" {
              tailf:info "Annex B, North American Standard";
            }
          }
        }
        leaf modulation {
          tailf:info "configure RF channel modulation type";
          type enumeration {
            enum "256qam" {
              tailf:info "256-QAM modulation";
            }
            enum "64qam" {
              tailf:info "64-QAM modulation";
            }
          }
        }
        leaf interleave {
          tailf:info "Interleave depth";
          type enumeration {
            enum 128 {
              tailf:info "R/S Interleave I=128, J=1";
            }
            enum 16 {
              tailf:info "R/S Interleave I=16, J=8";
            }
            enum 32 {
              tailf:info "R/S Interleave I=32, J=4";
            }
            enum 64 {
              tailf:info "R/S Interleave I=64, J=2";
            }
            enum 8 {
              tailf:info "R/S Interleave I=8, J=16";
            }
            enum 12 {
              tailf:info "R/S Interleave I=12, J=17";
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * network-delay auto


      // controller Modular-Cable * / rf-channel * ip-address
      container ip-address {
        tailf:info "configure IP address of edge QAM";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of edge QAM";
          }
        }
        leaf mac-address {
          tailf:info "MAC address of edge QAM";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "H.H.H;;MAC address of edge QAM";
          }
        }
        leaf depi-remote-id {
          tailf:info "configure DEPI session ID for edge QAM";
          type uint32 {
            tailf:info "<1-4294967295>;;DEPI remote ID";
            range "1..4294967295";
          }
        }
        leaf eqam-headroom {
          tailf:info "Headroom for Edge QAM channel";
          type uint8 {
            tailf:info "<0-28>;;EdgeQAM Headroom";
            range "0..28";
          }
        }
      }

      // controller Modular-Cable * / rf-channel * network-delay
      container network-delay {
        tailf:info "Delay through Converged Interconnect Network (CIN) to EQAM";
        choice network-delay-choice {
          leaf usec {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-3000>;;CIN delay in usec";
              range "0..3000";
            }
          }
          // controller Modular-Cable * / rf-channel * network-delay
          container auto {
            tailf:info "CIN Delay via DLM Measurements";
            tailf:cli-delete-when-empty;
            presence true;
            leaf sampling-rate {
              tailf:info "Sampling Rate for DLM Request";
              type uint16 {
                tailf:info "<1-500>;;DLM Sampling Rate in sec";
                range "1..500";
              }
            }
          }
        }
      }

      // controller Modular-Cable * / rf-channel * depi-tunnel
      container depi-tunnel {
        tailf:info "DEPI Data Session Configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf depi-tunnel-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;depi-tunnel name";
          }
        }
        leaf tsid {
          tailf:info "tsid ";
          type uint16 {
            tailf:info "<0-65535>;;tsid value";
          }
        }
      }

      // controller Modular-Cable * / rf-channel * rf-power
      leaf rf-power {
        tailf:info "Set RF Power";
        type string {
          tailf:info "<1-100>;;dBmV (The format is XY.Z; by default, .Z is .0)";
        }
      }

      // controller Modular-Cable * / no rf-channel * rf-shutdown
      leaf rf-shutdown {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }

  // controller Integrated-Cable * / rf-chan *
  grouping controller-integrated-cable-rf-chan-grouping {

    // controller Integrated-Cable * / rf-chan * / type
    leaf "type" {
      tailf:info "QAM Data Type";
      type enumeration {
        enum DOCSIS {
          tailf:info "DOCSIS";
        }
        enum VIDEO {
          tailf:info "VIDEO";
        }
      }
    }

    // controller Integrated-Cable * / rf-chan * / frequency
    leaf frequency {
      tailf:info "RF Channel Frequency";
      type uint32 {
        tailf:info "<93000000-861000000>;;frequency";
        range "93000000..861000000";
      }
    }

    // controller Integrated-Cable * / rf-chan * / rf-output
    leaf rf-output {
      tailf:info "QAM Output Mode";
      type enumeration {
        enum ALT {
          tailf:info "ALT";
        }
        enum CW {
          tailf:info "CW";
        }
        enum NORMAL {
          tailf:info "NORMAL";
        }
        enum PRBS {
          tailf:info "PRBS";
        }
      }
    }

    // controller Integrated-Cable * / rf-chan * / power-adjust
    leaf power-adjust {
      tailf:info "Channel Power Adjust";
      type string {
        tailf:info "WORD;;Power Adjust Range:  -8.0 -  0.0 dBmV";
      }
    }

    // controller Integrated-Cable * / rf-chan * / qam-profile
    leaf qam-profile {
      tailf:info "QAM Profile Number";
      type uint8 {
        tailf:info "<0-31>;;qam profile number";
        range "0..31";
      }
    }

    // controller Integrated-Cable * / rf-chan * / docsis-channel-id
    leaf docsis-channel-id {
      tailf:info "Docsis Channel Id";
      type uint8 {
        tailf:info "<1-255>;;dcid";
        range "1..255";
      }
    }
  }

  grouping object-group-service-protocol-match {
    choice match-choice {
      leaf eq {
        tailf:info "Match only packets on a given port number";
        tailf:cli-prefix-key {
          tailf:cli-before-key 1;
        }
        type empty;
      }
      leaf gt {
        tailf:info "Match only packets with a greater port number";
        tailf:cli-prefix-key {
          tailf:cli-before-key 1;
        }
        type empty;
      }
      leaf lt {
        tailf:info "Match only packets with a lower port number";
        tailf:cli-prefix-key {
          tailf:cli-before-key 1;
        }
        type empty;
      }
    }
  }

  // arp *
  // arp vrf *
  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key ip-address;
      leaf ip-address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of ARP entry";
        }
      }
      leaf hardware-address {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;48-bit hardware address of ARP entry";
          pattern '[0-9a-fA-F]+\.[0-9a-fA-F]+\.[0-9a-fA-F]+';
        }
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "ARP type ARPA";
          }
          enum SAP {
            tailf:info "ARP type SAP (HP's ARP type)";
          }
          enum SMDS {
            tailf:info "ARP type SMDS";
          }
          enum SNAP {
            tailf:info "ARP type SNAP (FDDI and TokenRing)";
          }
          enum SRP-A {
            tailf:info "ARP type SRP (side A)";
          }
          enum SRP-B {
            tailf:info "ARP type SRP (side B)";
          }
        }
      }
      //todo:[interface-type]
      leaf alias {
        tailf:info "Respond to ARP requests for the IP address";
        type empty;
      }
    }
  }


  // interface Dot11Radio * / encryption
  // interface Dot11Radio * / encryption vlan *
  grouping interface-encryption-mode-grouping {

    container mode {
      tailf:info "encryption mode";

      // interface Dot11Radio * / encryption mode ciphers
      // interface Dot11Radio * / encryption vlan * mode ciphers
      container ciphers {
        tailf:info "Optional data ciphers";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        choice suite-choice {
          leaf ckip {
            tailf:info "Cisco Per packet key hashing";
            type empty;
          }
          leaf ckip-cmic {
            tailf:info "Cisco Per packet key hashing and MIC (MMH)";
            type empty;
          }
          leaf cmic {
            tailf:info "Cisco MIC (MMH)";
            type empty;
          }
          case a {
            leaf aes-ccm {
              tailf:info "WPA AES CCMP";
              type empty;
            }
            leaf tkip {
              tailf:info "WPA Temporal Key encryption";
              type empty;
            }
            leaf wep {
              tailf:cli-drop-node-name;
              type enumeration {
                enum wep128 {
                  tailf:info "128 bit key";
                }
                enum wep40 {
                  tailf:info "40 bit key";
                }
              }
            }
          }
        }
      }
    }
  }

  grouping ip-ssh-algorithm-grouping {

    container algorithm {
      tailf:info "Configure different algorithms used in SSH";

      // ip ssh server algorithm mac
      leaf-list mac {
        tailf:info "MAC algorithms advertised to other party";
        tailf:cli-replace-all;
        tailf:cli-flat-list-syntax;
        type enumeration {
          enum hmac-sha1 {
            tailf:info "HMAC-SHA1 (digest length = key length = 160 bits)";
          }
          enum hmac-sha1-96 {
            tailf:info "HMAC-SHA1-96 (digest length = 96 bits, key length = 160 bits)";
          }
        }
      }

      // ip ssh server algorithm encryption
      leaf-list encryption {
        tailf:info "Encrytption algorithms advertised to other party";
        tailf:cli-replace-all;
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type enumeration {
          enum "3des-cbc" {
            tailf:info "Three-key 3DES in CBC mode";
          }
          enum aes128-cbc {
            tailf:info "AES with 128-bit key in CBC mode";
          }
          enum aes128-ctr {
            tailf:info "AES with 128-bit key in CTR mode";
          }
          enum aes192-cbc {
            tailf:info "AES with 192-bit key in CBC mode";
          }
          enum aes192-ctr {
            tailf:info "AES with 192-bit key in CTR mode";
          }
          enum aes256-cbc {
            tailf:info "AES with 256-bit key in CBC mode";
          }
          enum aes256-ctr {
            tailf:info "AES with 256-bit key in CTR mode";
          }
        }
      }
    }
  }


  // policy-map * / class * / bandwidth remaining percent
  // policy-map * / class * / bandwidth remaining ratio
  grouping bandwidth-remaining-account-grouping {
    container account {
      tailf:info "Overhead Accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice account-choice {
        case dot1q-qing {
          leaf bras-side {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum dot1q {
                tailf:info "dot1Q at BRAS side";
              }
              enum qinq {
                tailf:info "QinQ at BRAS side";
              }
            }
          }
          leaf aal {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum aal3 {
                tailf:info "AAL3 Layer type";
              }
              enum aal5 {
                tailf:info "AAL5 Layer type";
              }
            }
          }
          leaf subscriber-encapsulation {
            tailf:cli-drop-node-name;
            type enumeration {
              enum mux-1483routed {
                tailf:info "Mux 1483 Routed";
              }
              enum mux-dot1q-rbe {
                tailf:info "Mux Bridging and dot1Q encapsulation";
              }
              enum mux-pppoa {
                tailf:info "Mux PPPoA";
              }
              enum mux-rbe {
                tailf:info "Mux Bridging encapsulation";
              }
              enum snap-1483routed {
                tailf:info "Snap 1483 Routed";
              }
              enum snap-dot1q-rbe {
                tailf:info "Snap Bridging and dot1Q encapsulation";
              }
              enum snap-pppoa {
                tailf:info "Snap PPPoA encapsulation";
              }
              enum snap-rbe {
                tailf:info "Snap Bridging encapsulation";
              }
            }
          }
        }
        leaf user-defined  {
          tailf:info "Offset Size";
          type int8 {
            tailf:info "<-63 - 63>;;User Defined size";
          }
        }
      }
    }
  }


  grouping result-type-method-grouping {
    leaf authoritative {
      tailf:info "failure type";
      type empty;
    }
    leaf agent-not-found {
      tailf:info "agent not found type";
      type empty;
    }
    leaf none {
      tailf:info "no type";
      type empty;
    }
    leaf success {
      tailf:info "success type";
      type empty;
    }
    leaf method-timeout {
      tailf:info "method_timeout type";
      type empty;
    }
    leaf aaa-timeout {
      tailf:info "aaa timeout type";
      type empty;
    }
  }

  // interface * / vrrp *
  // interface * / vrrp * address-family ipv4 /
  // interface * / vrrp * address-family ipv6 /
  grouping interface-vrrp-grouping {

    // interface * / vrrp * description
    leaf "description" {
      tailf:info "Group specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this group";
        length "1..80";
      }
    }

    // interface * / vrrp * vrrs leader
    container vrrs {
      tailf:info "VRRS related commands";
      list leader {
        tailf:info "Name of VRRS Tag for which this group is the leader";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the VRRS Tag to lead";
          }
        }
      }
    }

    // interface * / vrrp * preempt delay minimum
    container preempt {
      tailf:info "Enable preemption of lower priority Master";
      container delay {
        tailf:info "Wait before preempting";
        leaf minimum {
          tailf:info "Delay at least this long";
          type uint16 {
            tailf:info "<0-3600>;;Seconds to delay";
            range "0..3600";
          }
        }
      }
    }

    // interface * / vrrp * priority
    leaf priority {
      tailf:info "Priority of this VRRP group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority level";
        range "1..254";
      }
    }

    // interface * / vrrp * timers
    container timers {
      tailf:info "Set the VRRP timers";

      // interface * / vrrp * timers advertise
      container advertise {
        tailf:info "Set the Advertisement timer";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Advertisement interval in seconds";
            range "1..255";
          }
        }
        leaf msec {
          tailf:info "Specify time in milliseconds";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<50-999>;;Advertisement interval in milliseconds";
            range "50..999";
          }
        }
      }

      // interface * / vrrp * timers learn
      leaf learn {
        tailf:info "Learn timer values from current Master";
        tailf:cli-full-command;
        type empty;
      }
    }

    // interface * / vrrp * track *
    list track {
      tailf:info "Event Tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;Tracked object";
          range "1..1000";
        }
      }

      // interface Vlan * / vrrp * track * decrement
      leaf decrement {
        tailf:info "Priority decrement";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-255>;;Decrement value";
        }
      }
    }

    // interface * / vrrp * shutdown
    leaf shutdown {
      tailf:info "Disable VRRP Configuration";
      tailf:cli-full-command;
      type empty;
    }
  }


  grouping router-bgp-aggregate-address-content-grouping {

    // router bgp * / address-family * / aggregate-address * as-set
    leaf as-set {
      tailf:cli-break-sequence-commands;
      tailf:info "Generate AS set path information";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * summary-only
    leaf summary-only {
      tailf:info "Filter more specific routes from updates";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * attribute-map
    leaf attribute-map {
      tailf:info "Set attributes of aggregate";
      type string {
        tailf:info "WORD;;Route map for parameter control";
      }
    }

    // router bgp * / address-family * / aggregate-address * advertise-map
    leaf advertise-map {
      tailf:info "Set condition to advertise attribute";
      type string {
        tailf:info "WORD;;Route map to control attribute advertisement";
      }
    }

    // router bgp * / address-family * / aggregate-address * suppress-map
    leaf suppress-map {
      tailf:info "Conditionally filter more specific routes from updates";
      type string {
        tailf:info "WORD;;Route map for suppression";
      }
    }

    // router bgp * / address-family * / aggregate-address * as-override
    leaf as-override {
      tailf:info "Override matching AS-number while sending update";
      type empty;
    }

    // router bgp * / address-family * / aggregate-address * route-map
    leaf route-map {
      tailf:info "Set parameters of aggregate";
      type string {
        tailf:info "WORD;;Route map for parameter control";
      }
    }
  }


  // ip dns view * /
  grouping ip-dns-view-grouping {

    // ip dns view * / domain
    container domain {
      tailf:info "Configure DNS Resolver parameters";

      // ip dns view * / domain name-server
      container name-server {
        tailf:info "Domain server IP address";

        // ip dns view * / domain name-server vrf *
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "name address";
          leaf name {
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf address {
            type union {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Host IP address";
              }
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Host IPv6 address";
              }
            }
          }
        }

        // ip dns view * / domain name-server interface
        container interface {
          tailf:info "Gather dynamically from interface address "+
            "acquisition";
          uses interface-name-grouping;
        }
      }
    }

    // ip dns view * / dns
    container dns {
      tailf:info "Configure DNS Server parameters";

      // ip dns view * / dns forwarding
      container forwarding {
        tailf:info "Configure DNS server forwarding";

        // ip dns view * / dns forwarding source-interface
        container source-interface {
          tailf:info "Specify source address when forwarding queries";
          uses interface-name-grouping;
        }
      }
    }
  }

  // ip igmp
  // ip igmp vrf *
  grouping ip-igmp-grouping {

    // ip igmp limit
    leaf limit {
      tailf:info "IGMP limit";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64000>;;Max Allowed State";
        range "1..64000";
      }
    }

    // ip igmp ssm-map
    container ssm-map {
      tailf:info "SSM mapping commands";

      // ip igmp ssm-map enable
      leaf enable {
        tailf:info "Enable SSM group to source mapping";
        type empty;
      }

      // no ip igmp ssm-map query dns
      container query {
        tailf:info "Which database should we query for the source";
        leaf dns {
          tailf:info "Use DNS for source lookup";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // ip igmp ssm-map static
      container static {
        tailf:info "SSM static group to source mapping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type std-ip-acl-type;
        }
        leaf source-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;SSM source address";
          }
        }
      }
    }
  }

  // ip msdp
  // ip msdp vrf *
  grouping ip-msdp-grouping {

    // ip msdp peer *
    list peer {
      tailf:info "Configure an MSDP peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      container connect-source {
        tailf:info "Configure source address used for MSDP connection";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf remote-as {
        tailf:info "Configured AS number";
        type uint16 {
          tailf:info "<1-65535>;;Autonomous System Number";
          range "1..65535";
        }
      }
    }

    // ip msdp description *
    list "description" {
      tailf:info "Peer specific description";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-diff-dependency "../peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      leaf text {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this pee";
        }
      }
    }

    // ip msdp keepalive *
    list keepalive {
      tailf:info "Configure keepalive parameters for a peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../peer";
      key address;
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      leaf keepalive-interval {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-60>;;Send keepalive period in seconds";
          range "1..60";
        }
      }
      leaf hold-time-interval {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-75>;;Maximum time in seconds to wait for a message";
          range "1..75";
        }
      }
    }

    // ip msdp sa-filter in *
    // ip msdp sa-filter out *
    list sa-filter {
      tailf:info "Filter SA messages from peer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../peer";
      key "direction address";
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Enable incoming SA filtering";
          }
          enum out {
            tailf:info "Enable outgoing SA filtering";
          }
        }
      }
      leaf address {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
      choice list-choice {
        leaf "list" {
          tailf:info "Access-list";
          type ext-acl-type;
        }
        leaf route-map {
          tailf:info "Route-map";
          type string {
            tailf:info "WORD;;route-map name";
          }
        }
        leaf rp-list {
          tailf:info "Access-list for originating RP";
          type union {
            type uint16 {
              tailf:info "<1-99>;;Standard IP access list";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf rp-route-map {
          tailf:info "Route-map for originating RP";
          type string {
            tailf:info "WORD;;Route-map reference";
          }
        }
      }
    }

    // Note: Constant ("ip msdp cache-sa-state" cannot be disabled.")
    // ip msdp cache-sa-state

    // ip msdp originator-id
    container originator-id {
      tailf:info "Configure MSDP Originator ID";
      uses interface-name-grouping;
    }

    // NOTE: Can not be disabled: ip msdp cache-sa-state

    // ip msdp mesh-group
    container mesh-group {
      tailf:info "Configure an MSDP mesh-group";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of mesh-group";
        }
      }
      leaf address {
        tailf:cli-drop-node-name;
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;Peer name or address";
        }
      }
    }
  }

  grouping if-srv-encapsulation-dot1q-grouping {
    leaf-list id {
      tailf:cli-drop-node-name;
      tailf:cli-range-list-syntax;
      tailf:cli-replace-all;
      type union {
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
        type enumeration {
          // note: warning, may be replaced on device?
          enum any {
            tailf:info "For all VLANS [1-4094]";
          }
        }
      }
    }
    // [second-dot1q]
    leaf second-dot1q {
      tailf:cli-break-sequence-commands;
      tailf:info "inner 802.1Q Virtual LAN or C-VLAN";
      type union {
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
        type enumeration {
          enum any {
            tailf:info "For all VLANS [1-4094]";
          }
        }
      }
    }
    // [cos]
    leaf cos {
      tailf:info "cos Vlan";
      type uint8 {
        tailf:info "<0-7>;;cos values";
        range "0..7";
      }
    }
    // [etype]
    leaf etype {
      tailf:info "payload ethertype after Vlan Field";
      type enumeration {
        enum ipv4 {
          tailf:info "IPv4";
        }
        enum ipv6 {
          tailf:info "IPv6";
        }
        enum pppoe-all {
          tailf:info "PPPoE ALL";
        }
        enum pppoe-discovery {
          tailf:info "PPPoE Discovery Stage";
        }
        enum pppoe-session {
          tailf:info "PPPoE Session Stage";
        }
      }
    }
  }


  // ip wccp
  // ip wccp vrf *
  // ipv6 wccp
  // ipv6 wccp vrf *
  grouping ip-wccp-grouping {

    // ip wccp source-interface
    container source-interface {
      tailf:info "Set source interface for Router ID";
      uses interface-name-grouping;
    }

    // ip wccp web-cache
    container web-cache {
      tailf:info "Standard web caching service";
      presence true;
    }

    // ip wccp *
    list wccp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key service-number;
      leaf service-number {
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-254>;;Dynamically defined service identifier number";
          range "0..254";
        }
      }

      // ip wccp * redirect-list
      leaf redirect-list {
        tailf:cli-break-sequence-commands;
        tailf:info "Set the access-list used to permit redirection";
        type exp-ip-acl-type;
      }

      // ip wccp * group-list
      leaf group-list {
        tailf:info "Set the access-list used to permit group membership";
        type std-acl-type;
      }

      // ip wccp * password
      container password {
        tailf:info "Authentication password (key)";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }
    }
  }

  // interface * / ip wccp
  // interface * / ip wccp vrf *
  // interface * / ipv6 wccp
  // interface * / ipv6 wccp vrf *
  grouping interface-ip-wccp-grouping {

    // interface * / ip wccp *
    list wccp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key service-number;
      leaf service-number {
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<0-254>;;Dynamically defined service identifier number";
          range "0..254";
        }
      }
      // interface * / ip wccp * redirect
      container redirect {
        tailf:info "Set packet redirection options for the service";
        leaf in {
          tailf:info "Redirect to a Cache Engine appropriate inbound packets";
          type empty;
        }
        leaf out {
          tailf:info "Redirect to a Cache Engine appropriate outbound packets";
          type empty;
        }
      }
    }
  }


  // spanning-tree portfast
  // spanning-tree portfast edge
  grouping spanning-tree-portfast-grouping {

    // spanning-tree portfast default
    leaf "default" {
      tailf:info "Enable portfast by default on all access ports";
      tailf:cli-full-command;
      type empty;
    }

    // spanning-tree portfast bpdufilter default
    container bpdufilter {
      tailf:info "Enable portfast bdpu filter on this switch";
      leaf "default" {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }

    // spanning-tree portfast bpduguard default
    container bpduguard {
      tailf:info "Enable portfast bpdu guard on this switch";
      leaf "default" {
        tailf:info "Enable portfast by default on all access ports";
        type empty;
      }
    }
  }


  grouping domain-path-preference-grouping {

    container path-preference {
      tailf:info "Specify the preferred provider";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf path1 {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf path2 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "fallback";
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf path3 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "fallback";
        type string {
          tailf:info "WORD;;Primary service provider";
        }
      }
      leaf fallback {
        tailf:info "Specify the fallback provider's color";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf fallback-path1 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf fallback-path2 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf fallback-path3 {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Fallback service provider";
        }
      }
      leaf next-fallback {
        when "../fallback-path1" {
          tailf:dependency "../fallback-path1";
        }
        tailf:info "Specify the next-fallback service provider";
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf blackhole {
        tailf:info "Drop the packet if primary unavailable";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      leaf routing {
        tailf:info "No Fallback provider";
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      leaf next-fallback-path1 {
        tailf:cli-drop-node-name;
        tailf:cli-disallow-value "blackhole|routing|next-fallback";
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
      leaf next-fallback-path2 {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
      leaf next-fallback-path3 {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Next-fallback service provider";
        }
      }
    }
  }


  // key chain * / key * / accept-lifetime
  // key chain * / key * / accept-lifetime local
  // key chain * / key * / send-lifetime
  // key chain * / key * / send-lifetime local
  grouping lifetime-grouping {
    leaf start-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type hhmm-type {
        tailf:info "hh:mm;;Time to start (hh:mm)";
      }
    }
    leaf start-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type month-type {
        tailf:info "MONTH;;Month of the year to start";
      }
    }
    leaf start-date {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;;Day of the month to start";
        range "1..31";
      }
    }
    leaf start-year {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint16 {
        tailf:info "<1993-2035>;;Year to start";
        range "1993..2035";
      }
    }

    leaf duration {
      tailf:info "Set key lifetime duration";
      tailf:cli-optional-in-sequence;
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-2147483646>;;Seconds";
        range "1..2147483646";
      }
    }
    leaf infinite {
      tailf:info "Never expires";
      tailf:cli-optional-in-sequence;
      tailf:cli-full-command;
      type empty;
    }

    leaf stop-time {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type hhmm-type {
        tailf:info "hh:mm;;Time to stop (hh:mm)";
      }
    }
    leaf stop-month {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type month-type {
        tailf:info "MONTH;;Month of the year to stop";
      }
    }
    leaf stop-date {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint8 {
        tailf:info "<1-31>;;Day of the month to stop";
        range "1..31";
      }
    }
    leaf stop-year {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<1993-2035>;;Year to stop";
        range "1993..2035";
      }
    }
  }


  // controller Upstream-Cable /
  grouping us-channel-grouping {
    list us-channel {
      tailf:info "Upstream channel configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<0-11>;;Upstream channel number";
          range "0..11";
        }
      }

      // controller Upstream-Cable * / us-channel * frequency
      leaf frequency {
        tailf:info "Frequency";
        type uint32 {
          tailf:info "<5000000-85000000>;;Upstream Frequency in Hz";
          range "5000000..85000000";
        }
      }

      // controller Upstream-Cable * / us-channel * channel-width
      container channel-width {
        tailf:info "Channel width in HZ";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf first-choice-width {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "Channel width Hz";
          }
        }
        leaf last-choice-width {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "Channel width Hz";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * power-level
      leaf power-level {
        tailf:info "Input power level";
        type int8 {
          tailf:info "<-13 - 23>;;Power level in dBmV";
          range "-13..23";
        }
      }

      // controller Upstream-Cable * / us-channel * docsis-mode
      leaf docsis-mode {
        tailf:info "Upstream channel DOCSIS mode";
        type enumeration {
          enum atdma {
            tailf:info "DOCSIS 2.0 ATDMA-only channel";
          }
          enum scdma {
            tailf:info "DOCSIS 2.0 SCDMA-only channel";
          }
          enum tdma {
            tailf:info "DOCSIS 1.x-only channel";
          }
          enum tdma-atdma {
            tailf:info "DOCSIS 1.x and DOCSIS 2.0 mixed channel";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * minislot-size
      leaf minislot-size {
        tailf:info "Minislot size";
        type uint8 {
          tailf:info "Minislot size in time ticks";
          range "1|2|4|8|16|32|64|128";
        }
      }

      // controller Upstream-Cable * / us-channel * modulation-profile
      container modulation-profile {
        tailf:info "Modulation Profile Number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf primary-profile-number {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "VALUE;;modulation number";
          }
        }
        leaf secondary-profile-number {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "VALUE;;secondary modulation number";
          }
        }
        leaf tertiary-profile-number {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "VALUE;;tertiary modulation number";
          }
        }
      }

      // controller Upstream-Cable * / us-channel * equalization-coefficient
      leaf equalization-coefficient {
        tailf:info "Enable equalization coefficient";
        type empty;
      }

      // controller Upstream-Cable * / us-channel * shutdown
      leaf shutdown {
        tailf:info "Shutdown the upstream channel";
        tailf:cli-show-no;
        type empty;
      }
    }
  }


  // ip explicit-path identifier * / index *
  // ip explicit-path name * / index *
  grouping ip-explicit-path-grouping {

    // ip explicit-path identifier * / index *
    list index {
      tailf:info "Specify entry index ";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;Entry index number";
        }
      }
      choice address-choice {

        // ip explicit-path name * / index * next-address
        leaf next-address {
          tailf:info "Specify the next address in the path";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "WORD;;Enter IP address (A.B.C.D)";
          }
        }

        // ip explicit-path name * / index * next-address loose
        container next-address-loose {
          tailf:cli-drop-node-name;
          container next-address {
            tailf:info "Specify the next address in the path";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            leaf loose {
              tailf:info "Target address is loose";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type inet:ipv4-address {
                tailf:info "WORD;;Enter IP address (A.B.C.D)";
              }
            }
          }
        }

        // ip explicit-path name * / index * exclude-address
        leaf exclude-address {
          tailf:info "Exclude an address from subsequent partial path segments";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "WORD;;Enter IP address (A.B.C.D)";
          }
        }
      }
    }
  }

  // radius-server host *
  // aaa group server radius * / server-private *
  grouping radius-server-grouping {

    // radius-server host * auth-port
    leaf auth-port {
      tailf:info "UDP port for RADIUS authentication server (default is "
        +"1645)";
      type uint16 {
        tailf:info "<0-65535>;;Port number";
        range "0..65535";
      }
    }

    // radius-server host * acct-port
    leaf acct-port {
      tailf:info "UDP port for RADIUS accounting server (default is 1646)";
      type uint16 {
        tailf:info "<0-65535>;;Port number";
        range "0..65535";
      }
    }

    // radius-server host * timeout
    leaf timeout {
      tailf:info "Time to wait for this RADIUS server to reply (overrides default)";
      type uint16 {
        tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
        range "1..1000";
      }
    }

    // radius-server host * retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server (overrides default)";
      type uint8 {
        tailf:info "<0-100>;;Number of retries to this server for a transaction";
        range "0..100";
      }
    }

    // radius-server host * test
    container test {
      tailf:info "Configure server automated testing.";
      tailf:cli-flatten-container;
      leaf username {
        tailf:info "A name (from local database) that should be used to send requests.";
        type string {
          tailf:info "WORD;;User Name";
        }
      }
    }

    // radius-server host * key
    container "key" {
      tailf:info "per-server encryption key (overrides default)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      uses password-grouping;
    }
  }


  /// ========================================================================
  /// grouping domain-
  /// ========================================================================

  grouping domain-advanced-smart-probes-grouping {
    container smart-probes {
      tailf:info "Smart probes configuration";
      container burst {
        tailf:info "Specify smart probe burst profile for channels monitored by general monitor";

        // domain * / vrf * / master hub / advanced / smart-probes burst
        container burst {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-100>;;Specify number of packets in one burst";
              range "1..100";
            }
          }
          leaf packets {
            tailf:info "packet(s) in every burst";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf every {
            tailf:info "every burst interval";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-30>;;Specify the interval between the starts of two adjacent bursts";
              range "1..30";
            }
          }
          leaf seconds {
            tailf:info "interval length in the scale of seconds";
            type empty;
          }
        }

        // domain * / vrf * / master hub / advanced / smart-probes burst quick
        container quick {
          tailf:info "Specify smart probe burst profile for channels monitored by quick monitor";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-100>;;Specify number of packets in one burst";
              range "1..100";
            }
          }
          leaf packets {
            tailf:info "packet(s) in every burst";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf every {
            tailf:info "every burst interval";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-30>;;Specify the interval between the starts of two adjacent bursts";
              range "1..30";
            }
          }
          leaf seconds {
            tailf:info "interval length in the scale of seconds";
            type empty;
          }
        }
      }
    }
  }

  grouping domain-master-grouping {
    list master {
      tailf:info "Enter master controller configuration submode";
      tailf:cli-mode-name "config-domain-vrf-mc";
      tailf:cli-sequence-commands;
      max-elements 1;
      key "type";
      leaf "type" {
        type enumeration {
          enum branch {
            tailf:info "Set master type as branch hub";
          }
          enum hub {
            tailf:info "Set master type as a hub";
          }
          enum regional-hub {
            tailf:info "Set master type as a regional hub";
          }
          enum transit {
            tailf:info "Set master type as a transit hub";
          }
        }
      }

      leaf pop-id {
        when "../type = 'transit'" {
          tailf:dependency "../type";
        }
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-62>;;Pop ID";
          range "1..62";
        }
      }

      // domain * / vrf * / master hub / source-interface
      container source-interface {
        tailf:info "Source Interface for master controller";
        tailf:cli-break-sequence-commands;
        uses interface-name-grouping;
      }

      // domain * / vrf * / master hub / site-prefixes prefix-list
      container site-prefixes {
        tailf:info "site prefixes configuration";
        leaf prefix-list {
          tailf:info "Specify prefix-list with static site prefixes";
          type string {
            tailf:info "WORD;;prefix-list containing list of site prefixes";
          }
        }
      }

      // domain * / vrf * / master hub / hub
      leaf hub {
        tailf:info "Specify regional-hub master controller to peer with";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of regional-hub master controller";
        }
      }

      // domain * / vrf * / master hub / collector
      container collector {
        tailf:info "NMS/v9 collector configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of NMS/v9 collector";
          }
        }
        leaf port {
          tailf:info "Specify collector port number";
          type uint16 {
            tailf:info "<1-65535>;;Specify collector port number";
            range "1..65535";
          }
        }
      }

      // domain * / vrf * / master hub / load-balance advanced
      container load-balance {
        tailf:info "load balance non-policy traffic";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-domain-vrf-mc-load-balance";
        leaf option {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum advanced {
              tailf:info "Load balancing configuration mode";
            }
          }
          default advanced;
        }

        // domain * / vrf * / master hub / load-balance advanced / path-preference
        uses domain-path-preference-grouping;
      }

      // domain * / vrf * / master hub / password
      container password {
        tailf:info "MD5 password to be used with BRs";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }

      // domain * / vrf * / master hub / enterprise-prefix prefix-list
      container enterprise-prefix {
        tailf:info "Enterprise prefix configuration";
        leaf prefix-list {
          tailf:info "Specify prefix-list with static site targets";
          type string {
            tailf:info "WORD;;prefix-list containing list of site targets";
          }
        }
      }

      // domain * / vrf * / master hub / monitor-interval *
      list monitor-interval {
        tailf:info "Monitoring interval";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "seconds dscp";
        leaf seconds {
          type uint16 {
            tailf:info "<1-300>;;interval (second)";
          }
        }
        leaf dscp {
          tailf:info "specify DSCP";
          tailf:cli-expose-key-name;
          type dscp-type;
        }
      }

      // domain * / vrf * / master hub / advanced
      container advanced {
        tailf:info "Advanced configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-domain-vrf-mc-advanced";
        presence true;

        // domain * / vrf * / master hub / advanced / smart-probes burst
        uses domain-advanced-smart-probes-grouping;

        // domain * / vrf * / master hub / advanced / channel-unreachable-timer
        leaf channel-unreachable-timer {
          tailf:info "Unreach interval detection";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-65535>;;Specify new timer interval value in seconds";
            range "1..65535";
          }
        }
      }

      // domain * / vrf * / master hub / class * sequence
      list class {
        tailf:info "Create domain class and enter domain class command mode";
        tailf:cli-mode-name "config-domain-vrf-mc-class";
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;domain class name";
          }
        }
        leaf sequence {
          tailf:info "Set the Sequence for the class";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<1-65535>;;Sequence number for the class";
            range "1..65535";
          }
        }

        // domain * / vrf * / master hub / class * / match
        container match {
          tailf:info "Specify the applications the policy applies to.";
          tailf:cli-break-sequence-commands;

          // domain * / vrf * / master hub / class * / match dscp *
          list dscp {
            tailf:info "specify DSCP";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key services-value;
            leaf services-value {
              type dscp-type;
            }
            leaf policy {
              tailf:info "Specify the policy (user defined/predefined)";
              type enumeration {
                enum best-effort {
                  tailf:info "domain policy type best effort";
                }
                enum bulk-data {
                  tailf:info "domain policy type bulk data";
                }
                enum custom {
                  tailf:info "custom user-defined policy";
                }
                enum low-latency-data {
                  tailf:info "domain policy type low latency data";
                }
                enum real-time-video  {
                  tailf:info "domain policy type real-time-video";
                }
                enum scavenger {
                  tailf:info "domain policy type scavenger";
                }
                enum voice {
                  tailf:info "domain policy type voice";
                }
              }
            }
          }

          // domain * / vrf * / master hub / class * / match application *
          list application {
            tailf:info "Specify the application names";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key services-value;
            leaf services-value {
              type string {
                tailf:info "WORD;;user-defined application name";
              }
            }
            leaf policy {
              tailf:info "Specify the policy (user defined/predefined)";
              type enumeration {
                enum best-effort {
                  tailf:info "domain policy type best effort";
                }
                enum bulk-data {
                  tailf:info "domain policy type bulk data";
                }
                enum custom {
                  tailf:info "custom user-defined policy";
                }
                enum low-latency-data {
                  tailf:info "domain policy type low latency data";
                }
                enum real-time-video  {
                  tailf:info "domain policy type real-time-video";
                }
                enum scavenger {
                  tailf:info "domain policy type scavenger";
                }
                enum voice {
                  tailf:info "domain policy type voice";
                }
              }
            }
          }
        }

        // domain * / vrf * / master hub / class * / path-preference
        uses domain-path-preference-grouping;

        // domain * / vrf * / master hub / class * / path-last-resort
        leaf path-last-resort {
          tailf:info "Specify path of last resort provider";
          type string {
            tailf:info "Specify path of last resort provider";
          }
        }
      }
    }
  }

  grouping domain-border-grouping {
    container border {
      tailf:info "Enter border router configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-domain-vrf-br";
      tailf:cli-full-command;
      presence true;

      // domain * / vrf * / border / master
      leaf master {
        tailf:info "Specify IP address of Domain master controller";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of Domain master controller";
          }
          type enumeration {
            enum local {
              tailf:info "local;;Local Domain master controller";
            }
          }
        }
      }

      // domain * / vrf * / border / source-interface
      container source-interface {
        tailf:info "Source Interface for border";
        uses interface-name-grouping;
      }

      // domain * / vrf * / border / password
      container password {
        tailf:info "MD5 password to be used with MC";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }
    }
  }

  grouping carrier-delay-grouping {
    choice delay-choice {
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<0-60>;;Carrier Transitions delay seconds";
          range "0..60";
        }
      }
      leaf msec {
        tailf:info "delay specified in milliseconds";
        type uint16 {
          tailf:info "<0-1000>;;Carrier Transitions delay milliseconds";
          range "0..1000";
        }
      }
    }
  }


  // =========================================================================
  //                        MODEL
  // =========================================================================


  /// ========================================================================
  /// upgrade
  /// ========================================================================

  container upgrade {
    tailf:info "Global upgrade configuration subcommands";

    // upgrade fpd
    container fpd {
      tailf:info "Configure field programmable devices upgrade options";
      // upgrade fpd auto
      leaf auto {
        tailf:info "Auto upgrade all FPD images";
        type empty;
      }
      // upgrade fpd path
      leaf "path" {
        tailf:info "Set path to locate the FPD image package file for auto "+
          "upgrade";
        type string;
      }
    }
  }


  /// ========================================================================
  /// tailfned
  /// ========================================================================
  /// TAILF NED device info used for device specific support.

  container tailfned {

    // tailfned police
    leaf police {
      tailf:cli-no-value-on-delete;
      tailf:cli-suppress-no;
      type string {
        tailf:info "cirmode | bpsflat | numflat | cirflat";
      }
    }

    // tailfned new-ip-access-list
    container api {
      tailf:info "DO NOT MODIFY, contents here are set by ned-settings only";
      leaf new-ip-access-list {
        tailf:info "DO NOT MODIFY, this leaf is set by ned-settings only";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// version
  /// ========================================================================

  leaf version {
    tailf:info "Version";
    type string {
      tailf:info "WORD;;Version number";
    }
  }


  /// ========================================================================
  /// service
  /// ========================================================================

  container service {
    tailf:info "Modify use of network based services";

    // service config
    leaf "config" {
      tailf:info "TFTP load config files";
      tailf:cli-full-command;
      type empty;
    }

    // service exec-callback
    leaf exec-callback {
      tailf:info "Enable exec callback";
      tailf:cli-full-command;
      type empty;
    }

    // service nagle
    leaf nagle {
      tailf:info "Enable Nagle's congestion control algorithm";
      tailf:cli-full-command;
      type empty;
    }

    // no service slave-log
    leaf slave-log {
      tailf:info "Enable log capability of slave IPs";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service pad cmns
    // service pad from-xot
    // service pad to-xot
    container pad {
      tailf:info "Enable PAD commands";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      leaf to-xot {
        tailf:info "Allow outgoing PAD over XOT connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf from-xot {
        tailf:info "Accept XOT to PAD connections";
        tailf:cli-full-command;
        type empty;
      }
      leaf cmns {
        tailf:info "Enable PAD over CMNS connections";
        tailf:cli-full-command;
        type empty;
      }
    }

    // no service pad
    container conf {
      tailf:cli-drop-node-name;
      leaf pad {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service tcp-keepalives-in
    leaf tcp-keepalives-in {
      tailf:info "Generate keepalives on idle incoming network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service tcp-keepalives-out
    leaf tcp-keepalives-out {
      tailf:info "Generate keepalives on idle outgoing network connections";
      tailf:cli-full-command;
      type empty;
    }

    // service timestamps
    container timestamps {
      tailf:info "Timestamp debug/log messages";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;

      // service timestamps debug
      container debug {
        tailf:info "Timestamp debug messages";

        choice timestamp-choice {
          // service timestamps debug uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps debug datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }

      // service timestamps log
      container log {
        tailf:info "Timestamp log messages";

        choice timestamp-choice {
          // service timestamps log uptime
          leaf uptime {
            tailf:info "Timestamp with system uptime";
            type empty;
          }
          // service timestamps log datetime
          container datetime {
            tailf:info "Timestamp with date and time";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
            leaf msec {
              tailf:info "Include milliseconds in timestamp";
              type empty;
            }
            leaf localtime {
              tailf:info "Use local time zone for timestamps";
              type empty;
            }
            leaf show-timezone {
              tailf:info "Add time zone information to timestamp";
              type empty;
            }
            leaf year {
              tailf:info "Include year in timestamp";
              type empty;
            }
          }
        }
      }
    }

    // service password-encryption
    container password-encryption {
      tailf:info "Encrypt system passwords";
      tailf:cli-show-no;
      presence true;
    }

    // service password-recovery
    // no service password-recovery
    leaf password-recovery {
      tailf:info "Disable password recovery";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // service exec-wait
    leaf exec-wait {
      tailf:info "Delay EXEC startup on noisy lines";
      tailf:cli-full-command;
      type empty;
    }

    // service linenumber
    leaf linenumber {
      tailf:info "enable line number banner for each exec";
      tailf:cli-full-command;
      type empty;
    }

    // service compress-config
    leaf compress-config {
      tailf:info "Compress the configuration file";
      tailf:cli-full-command;
      type empty;
    }

    // service udp-small-servers
    leaf udp-small-servers {
      tailf:info "Enable small UDP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // no service prompt config
    container prompt {
      tailf:info "Enable mode specific prompt (WARNING: will deadlock NED) if set to 'no'";
      leaf "config" {
        tailf:info "Enable configuration mode prompt";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // service tcp-small-servers
    leaf tcp-small-servers {
      tailf:info "Enable small TCP servers (e.g., ECHO)";
      tailf:cli-full-command;
      type empty;
    }

    // service old-slip-prompts
    leaf old-slip-prompts {
      tailf:info "Allow old scripts to operate with slip/ppp";
      tailf:cli-full-command;
      type empty;
    }

    // service pt-vty-logging
    leaf pt-vty-logging {
      tailf:info "Log significant VTY-Async events";
      tailf:cli-full-command;
      type empty;
    }

    // service disable-ip-fast-frag
    leaf disable-ip-fast-frag {
      tailf:info "Disable IP particle-based fast fragmentation";
      tailf:cli-full-command;
      type empty;
    }

    // service sequence-numbers
    leaf sequence-numbers {
      tailf:info "Stamp logger messages with a sequence number";
      tailf:cli-full-command;
      type empty;
    }

    // service divert-rate-limit
    container divert-rate-limit {
      tailf:info "Set WAN-side divert-rate-limit parameters";

      // service divert-rate-limit ip *
      list ip {
        tailf:info "WAN-IPv4 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit ipv6 *
      list ipv6 {
        tailf:info "WAN-IPv6 configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key divert-code;
        leaf divert-code {
          type string {
            tailf:info "WORD;;divert code";
          }
        }
        leaf rate {
          tailf:info "rate in packets/sec";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;rate in packets/second";
          }
        }
        leaf limit {
          tailf:info "limit in packets";
          type uint16 {
            tailf:info "<4-4194>;;limit in packets";
            range "4..4194";
          }
        }
      }

      // service divert-rate-limit trusted-site *
      list trusted-site {
        tailf:info "trusted-site configuration for WAN-IPv4";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address mask-ip-address tos mask";
        max-elements 4;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;source IP address";
          }
        }
        leaf mask-ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP prefix mask";
          }
        }
        leaf tos {
          tailf:info "ToS value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS value";
          }
        }
        leaf mask {
          tailf:info "ToS mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;ToS mask";
          }
        }
        // [ global | vrf vrf-name ]
      }

      // service divert-rate-limit trusted-site-ipv6 *
      list trusted-site-ipv6 {
        tailf:info "trusted-site configuration for WAN-IPv6";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "ip-address traffic-class mask";
        max-elements 4;
        leaf ip-address {
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 Source address/Prefix length."+
              "(e.g., 1234::1/<prefix-length>)";
          }
        }
        leaf traffic-class {
          tailf:info "traffic-class value";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class value";
          }
        }
        leaf mask {
          tailf:info "traffic-class mask";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "<0-255>;;traffic-class mask";
          }
        }
        // [ global | vrf vrf-name ]
      }
    }

    // service counters
    container counters {
      tailf:info "Control aging of interface counters";
      container max {
        tailf:info "Maximum counter aging threshold";
        leaf age {
          tailf:info "Aging threshold";
          type uint8 {
            tailf:info "<0-60>;;Aging threshold value in seconds";
            range "0..60";
          }
        }
      }
    }

    // service alignment
    container alignment {
      tailf:info "Control alignment correction and logging";
      // no service alignment detection
      leaf detection {
        tailf:info "Enable detection of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // no service alignment logging
      leaf logging {
        tailf:info "Enable logging of alignment issues";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // service call-home
    leaf call-home {
      tailf:info "Enable call-home service";
      tailf:cli-full-command;
      type empty;
    }

    // no service dhcp
    leaf dhcp {
      tailf:info "Enable DHCP server and relay agent";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // service finger
    leaf finger {
      tailf:info "Allow responses to finger requests";
      tailf:cli-full-command;
      type empty;
    }

    // service heartbeat
    container heartbeat {
      tailf:info "Enable heartbeat processing";

      // service heartbeat fatal-count
      leaf fatal-count {
        tailf:info "Set heartbeat fatal count";
        type uint8 {
          tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          range "1..60";
        }
      }

      // service heartbeat interrupt-interval
      leaf interrupt-interval {
        tailf:info "Set heartbeat interrupt test interval";
        type uint8 {
          tailf:info "<0-60>;;Interval between interrupt level tests";
          range "0..60";
        }
      }

      // service heartbeat interrupt-max
      leaf interrupt-max {
        tailf:info "Set maximum message count from interrupt test";
        type uint8 {
          tailf:info "<0-60>;;Maximum number of messages from interrupt test";
          range "0..60";
        }
      }

      // service heartbeat transmit-interval
      leaf transmit-interval {
        tailf:info "Set heartbeat transmit interval";
        type uint8 {
          tailf:info "<1-30>;;Interval between heartbeat transmissions";
          range "1..30";
        }
      }

      // service heartbeat warning-timeout
      leaf warning-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<3-60>;;Interval between heartbeat timeout warnings";
          range "3..60";
        }
      }

      // service heartbeat fatal-timeout
      leaf fatal-timeout {
        tailf:info "Set heartbeat warning timeout interval";
        type uint8 {
          tailf:info "<5-60>;;Interval between heartbeat timeouts until a "+
            "fatal timeout error occurs";
          range "5..60";
        }
      }

      // service heartbeat cslipc-timeout
      leaf cslipc-timeout {
        tailf:info "Set heartbeat csl ipc timeout interval";
        type uint16 {
          tailf:info "<10-4800>;;Interval between linecard insertion "+
            "and csl ipc reception";
          range "10..4800";
        }
      }

      // service heartbeat alive-timeout
      leaf alive-timeout {
        tailf:info "Set heartbeat alive timeout interval";
        type uint16 {
          tailf:info "<600-1200>;;Interval between linecard insertion "+
            "and heartbeat starting";
          range "600..1200";
        }
      }
    }

    // service hide-telnet-addresses
    leaf hide-telnet-addresses {
      tailf:info "Hide destination addresses in telnet command";
      tailf:cli-full-command;
      type empty;
    }

    // service unsupported-transceiver
    leaf unsupported-transceiver {
      tailf:cli-full-command;
      type empty;
    }

    // service internal
    leaf internal {
      // Note: allow additional control of the LTE modem
      type empty;
    }
  }


  /// ========================================================================
  /// boot
  /// ========================================================================

  container boot {
    tailf:info "Modify system boot parameters";

    // boot config
    leaf "config" {
      tailf:info "Configuration file";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;URL of the config file";
      }
    }

    // boot network
    container network {
      tailf:info "Network-wide config file";
      leaf remote-url {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;TFTP filename or URL";
        }
      }
    }
  }


  /// ========================================================================
  /// password
  /// ========================================================================

  container password {
    tailf:info "Configure encryption password (key)";
    container encryption {
      tailf:info "Encrypt system passwords";

      // password encryption aes
      leaf aes {
        tailf:info "Enable stronger (AES) password encryption";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// login
  /// ========================================================================

  container login {
    tailf:info "Enable secure login checking";

    // login block-for
    container block-for {
      tailf:info "Set quiet-mode active time period";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Time period in seconds";
          range "1..65535";
        }
      }
      leaf attempts {
        tailf:info "Set max number of fail attempts";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-65535>;;Fail attempts max value";
          range "1..65535";
        }
      }
      leaf within {
        tailf:info "Watch period for fail attempts";
        type uint16 {
          tailf:info "<1-65535>;;Time period in seconds";
          range "1..65535";
        }
      }
    }

    // on-failure
    container on-failure {
      tailf:info "Set options for failed login attempt";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf log {
        tailf:info "Generate syslogs on failure logins";
        type empty;
      }
      leaf every {
        tailf:info "Periodicity for logs generated";
        type uint16 {
          tailf:info "<1-65535>;;Number defining periodicity";
          range "1..65535";
        }
        default 1;
      }
    }

    // on-success
    container on-success {
      tailf:info "Set options for successful login attempt";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf log {
        tailf:info "Generate syslogs on successful logins";
        type empty;
      }
      leaf every {
        tailf:info "Periodicity for logs generated";
        type uint16 {
          tailf:info "<1-65535>;;Number defining periodicity";
          range "1..65535";
        }
        default 1;
      }
    }
  }


  /// ========================================================================
  /// cdp
  /// ========================================================================
  // Must be before interface * / cdp enable

  container cdp {
    tailf:info "Global CDP configuration subcommands";

    // no cdp run
    leaf run {
      tailf:info "Enable CDP";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // no cdp advertise-v2
    leaf advertise-v2 {
      tailf:info "CDP sends version-2 advertisements";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }

    container tlv {
      tailf:info "Enable exchange of specific tlv information";

      // no cdp tlv location
      leaf location {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // no cdp tlv app
      leaf app {
        tailf:info "Enable app tlv";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  /// ========================================================================
  /// platform
  /// ========================================================================

  container platform {
    tailf:info "platform specific configuration";

    // platform shell
    leaf shell {
      tailf:info "Control platform shell access command availability";
      tailf:cli-full-command;
      type empty;
    }

    // platform console
    leaf console {
      tailf:info "Direct IOS output to console";
      tailf:cli-full-command;
      type enumeration {
        enum auto {
          tailf:info "Autodetect console (Serial,VGA) for IOS output";
        }
        enum serial {
          tailf:info "Use Serial console for IOS output";
        }
        enum virtual {
          tailf:info "Use VM (VGA) console for IOS output";
        }
      }
    }

    // platform bfd allow-svi
    container bfd {
      tailf:info "Platform specific BFD commands";
      leaf allow-svi {
        tailf:cli-full-command;
        type empty;
      }
    }

    // platform bfd-debug-trace
    leaf bfd-debug-trace {
      tailf:cli-full-command;
      type uint32;
    }

    // platform enable controller *
    container enable {
      list controller {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Controller name";
          }
        }
      }
    }

    // platform hardware throughput level
    container hardware {
      tailf:info "Configure platform hardware";
      container throughput {
        tailf:info "Configure throughput";
        container level {
          tailf:info "Configure the current traffic throughput level";
          choice throughput-choice {
            leaf MB {
              tailf:info "throughput in mbps";
              type uint32;
            }
            leaf kbps {
              tailf:cli-drop-node-name;
              type uint32;
            }
          }
        }
      }
    }

    // platform ipccl log-history
    container ipccl {
      leaf log-history {
        type uint32;
      }
    }

    // platform ipv4 pbr optimize tcam
    container ipv4 {
      container pbr {
        container optimize {
          leaf tcam {
            type empty;
          }
        }
      }
    }

    // platform ring rx 256
    container ring {
      leaf rx {
        type uint32;
      }
    }

    // platform tcam-parity-error enable
    container tcam-parity-error {
      leaf enable {
        type empty;
      }
    }

    // platform tcam-threshold alarm-frequency
    container tcam-threshold {
      leaf alarm-frequency {
        type uint32;
      }
    }

    // platform multicast lre off
    container multicast {
      tailf:info "Configure multicast";
      container lre {
        leaf off {
          type empty;
        }
      }
    }

    // platform punt-keepalive disable-kernel-core
    // no platform punt-keepalive disable-kernel-core
    container punt-keepalive {
      tailf:info "punt-keepalive messages";
      leaf disable-kernel-core {
        tailf:info "Disable IOSXE kernel core generation for keepalive fault";
        tailf:cli-boolean-no;
        type boolean;
      }
    }

    // platform punt-policer *
    list punt-policer {
      tailf:info "Configures punt policers";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key cause;
      leaf cause {
        type uint8 {
          tailf:info "<1-108>;;Punt cause to be policed";
          range "1..108";
        }
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<10-146484>;;max punt rate for cause Incomplete adjacency";
          range "10..146484";
        }
      }
    }

    // platform punt-policer * high
    container punt-policer-high {
      tailf:cli-drop-node-name;
      list punt-policer {
        tailf:info "Configures punt policers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key cause;
        leaf cause {
          type uint8 {
            tailf:info "<1-108>;;Punt cause to be policed";
            range "1..108";
          }
        }
        leaf rate {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<10-146484>;;max punt rate for cause Incomplete adjacency";
            range "10..146484";
          }
        }
        leaf high {
          tailf:info "High priority traffic only";
          type empty;
        }
      }
    }

    // platform punt-sbrl
    container punt-sbrl {
      tailf:info "Punt-path Source-Based Rate-Limit configuration";

      // platform punt-sbrl wan punt-cause *
      container wan {
        tailf:info "SBRL WAN-side config";
        list punt-cause {
          tailf:info "sub-side punt-cause for per-MAC-addr rate-limiting";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key cause;
          leaf cause {
            type uint8 {
              tailf:info "<1-108>;;Punt cause to be policed";
              range "1..108";
            }
          }
          leaf rate {
            tailf:info "WAN-side rate in pkts-per-sec";
            type uint16 {
              tailf:info "<1-256>;;rate in pkts/sec (powers-of-2 only) for: MPLS ICMP Can't Fragment";
              range "1..256";
            }
          }
          leaf quarantine-time {
            tailf:info "WAN-side quarantine time";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-60>;;quarantine time in minutes";
              range "1..60";
            }
          }

          leaf burst-factor {
            tailf:info "WAN-side quarantine burst-factor";
            type uint16 {
              tailf:info "<50-1000>;;quarantine burst-factor in packets";
              range "50..1000";
            }
          }
        }
      }

      // platform punt-sbrl subscriber
      container subscriber {
        tailf:info "SBRL subscriber-side config";

        // platform punt-sbrl subscriber rate
        leaf rate {
          tailf:info "subscriber-side CM rate in pkts-per-sec";
          type uint16 {
            tailf:info "<1-256>;;rate (powers-of-2 only)";
            range "1..256";
          }
        }
      }
    }

    // platform qos
    container qos {
      tailf:info "Platform specific qos configuration";

      // platform qos marker-statistics
      leaf marker-statistics {
        tailf:info "Configure marking statistics";
        tailf:cli-full-command;
        type empty;
      }

      // platform qos match-statistics
      container match-statistics {
        tailf:info "Configure match stats";
        leaf per-filter {
          tailf:info "Configure per-filter match statistics";
          type empty;
        }
        leaf per-ace {
          tailf:info "Configure per-ace match statistics"+
            "(per-filter must be enabled first)";
          tailf:cli-diff-dependency "../per-filter";
          type empty;
        }
      }

      // platform qos performance-monitor
      leaf performance-monitor {
        tailf:info "Configure performance-monitor statistics";
        tailf:cli-full-command;
        type empty;
      }

      // platform qos punt-path-matching
      leaf punt-path-matching {
        tailf:info "Configure punt-path matching on input interface "+
          "(PPPoE-Discovery, PPPoE-PPP-LCP)";
        tailf:cli-full-command;
        type empty;
      }
    }

    // platform power redundancy-mode nplus1
    container power {
      container redundancy-mode {
        leaf nplus1 {
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// hostname
  /// ========================================================================

  leaf hostname {
    tailf:info "Set system's network name";
    type string {
      tailf:info "This system's network name";
    }
  }


  /// ========================================================================
  /// boot system
  /// ========================================================================

  container boot-marker {
    tailf:cli-drop-node-name;

    // boot-start-marker

    container boot {
      tailf:info "Modify system boot parameters";

      // boot system *
      list system {
        tailf:info "System image file";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key entry;
        leaf entry {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;boot system entry";
          }
        }
      }
    }

    // boot-end-marker
  }


  /// ========================================================================
  /// shell
  /// ========================================================================

  container shell {
    tailf:info "Configure shell command";

    // no shell processing
    leaf processing {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// aqm-register-fnf
  /// ========================================================================

  container aqm-register-fnf {
    tailf:info "Export audio/voice stats to flow record";
    presence true;
  }


  /// ========================================================================
  /// service-module
  /// ========================================================================

  // service-module wlan-ap 0 bootimage
  container service-module {
    tailf:info "Service Module bootimage config";
    list wlan-ap {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key interface-number;
      leaf interface-number {
        type uint8 {
          tailf:info "<0-0>;;wlan-ap interface number";
          range "0";
        }
      }
      leaf bootimage {
        tailf:info "AP boot image";
        type enumeration {
          enum autonomous {
            tailf:info "Set AP boot image to autonomous";
          }
          enum unified {
            tailf:info "Set AP boot image to unified";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vrf
  /// ========================================================================
  // Note: /vrf must be before /ip and /ipv6

  container vrf {
    tailf:info "VRF commands";

    // vrf definition *
    list definition {
      tailf:info "VRF definition mode";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-vrf";
      unique rd;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // vrf definition * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // vrf definition * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type rd-type;
      }

      // vrf definition * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }

      // vrf definition * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // vrf definition * / address-family ipv4
        container ipv4 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;

          // vrf definition * / address-family ipv4 / mdt
          container mdt {
            tailf:info "Backbone Multicast Distribution Tree";

            // vrf definition * / address-family ipv4 / mdt default
            container "default" {
              tailf:info "The default group";
              leaf address {
                // Note: when set, mdt/data & mdt/log-reuse should be deleted
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-remove-before-change;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP multicast group address";
                }
              }
              container mpls {
                tailf:info "MPLS tunnel options";
                leaf mldp {
                  tailf:info "Use a MLDP LSP to create the default MDT";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;MP2MP LSP root address";
                  }
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt data
            container data {
              tailf:info "MDT data trees";
              list multicast {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address wildcard";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP multicast group address";
                  }
                }
                leaf wildcard {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Wildcard bits";
                  }
                }
              }
              leaf "list" {
                tailf:info "Access-list";
                type ext-acl-type;
              }
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in kilobits per second";
                }
              }
            }

            // vrf definition * / address-family ipv4 / mdt log-reuse
            leaf log-reuse {
              tailf:info "Event logging for data MDT reuse";
              type empty;
            }

            // vrf definition * / address-family ipv4 / mdt preference
            leaf-list preference {
              tailf:info "MDT preference (default pim mldp)";
              tailf:cli-flat-list-syntax {
                tailf:cli-replace-all;
              }
              type enumeration {
                enum mldp {
                  tailf:info "MDT preference mLDP";
                }
                enum pim {
                  tailf:info "MDT preference PIM";
                }
              }
            }
          }
        }

        // vrf definition * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-vrf-af";
          tailf:cli-exit-command "exit-address-family";
          tailf:cli-full-command;
          presence true;
          uses vrf-definition-af-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// security
  /// ========================================================================

  container security {
    tailf:info "Infra Security CLIs";

    // security passwords min-length
    container passwords {
      tailf:info "Password security CLIs";
      leaf min-length {
        tailf:info "Minimum length of passwords";
        type uint8 {
          tailf:info "<0-16>;;Minimum length of all user/enable passwords";
          range "0..16";
        }
      }
    }

    // security authentication failure rate
    container authentication {
      tailf:info "Authentication security CLIs";
      container failure {
        tailf:info "Authentication failure logging";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:info "Authentication failure threshold rate";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<2-1024>;;Authentication failure threshold rate";
            range "2..1024";
          }
        }
        leaf log {
          tailf:info "log a message if the Authentication failures over "+
            "the last one minute equalled this number";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// enable
  /// ========================================================================

  container enable {
    tailf:info "Modify enable password parameters";

    // enable password
    container password {
      tailf:info "Assign the privileged level password (MAX of 25 characters)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }

    // enable password level *
    container password-conf {
      tailf:cli-drop-node-name;
      container password {
        tailf:info "Assign the privileged level password (MAX of 25 characters)";
        list level {
          tailf:info "Set exec level password";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key level;
          leaf level {
            type uint8 {
              tailf:info "<1-15>;;Level number";
              range "1..15";
            }
          }
          uses password-grouping;
        }
      }
    }

    // enable last-resort
    leaf last-resort {
      tailf:info "Define enable action if no TACACS servers respond";
      tailf:cli-full-command;
      type enumeration {
        enum password {
          tailf:info "Enable by giving the local enable password";
        }
        enum succeed {
          tailf:info "Enable without further question";
        }
      }
    }

    // enable secret
    container secret {
      tailf:info "Assign the privileged level secret";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf "type" {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum "4" {
            tailf:info "Specifies a HIDDEN secret will follow"; // which?
          }
          enum "5" {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
          enum "8" {
            tailf:info "Specifies a PBKDF2 HASHED secret will follow";
          }
          enum "9" {
            tailf:info "Specifies a SCRYPT HASHED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|4|5|8|9|key-chain";
        tailf:meta-data "secret-password";
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) 'enable' secret";
        }
      }
    }

    // enable secret level *
    container secret-conf {
      tailf:cli-drop-node-name;
      container secret {
        tailf:info "Assign the privileged level secret";
        list level {
          tailf:info "Set exec level password";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key level;
          leaf level {
            tailf:cli-suppress-range;
            type uint8 {
              tailf:info "<1-15>;;Level number";
              range "1..15";
            }
          }
          leaf "type" {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "0" {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum "4" {
                tailf:info "Specifies a HIDDEN secret will follow"; // which?
              }
              enum "5" {
                tailf:info "Specifies an ENCRYPTED secret will follow";
              }
              enum "8" {
                tailf:info "Specifies a PBKDF2 HASHED secret will follow";
              }
              enum "9" {
                tailf:info "Specifies a SCRYPT HASHED secret will follow";
              }
            }
          }
          leaf secret {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-disallow-value "0|4|5|8|9|key-chain";
            tailf:meta-data "secret-password" {
              tailf:meta-value "enable secret level <level> <PASSWORD>";
            }
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) 'enable' secret";
            }
          }
        }
      }
    }

    // enable use-tacacs
    leaf use-tacacs {
      tailf:info "Use TACACS to check enable passwords";
      tailf:cli-full-command;
      type empty;
    }

  }


  /// ========================================================================
  /// aaa
  /// ========================================================================

  container aaa {
    tailf:info "Authentication, Authorization and Accounting.";
    tailf:cli-incomplete-command;

    // aaa new-model
    leaf new-model {
      tailf:info "Enable NEW access control commands and functions."+
        "(Disables OLD commands.)";
      type empty;
    }

    // aaa group
    container group {
      tailf:info "AAA group definitions";
      tailf:cli-diff-dependency "../new-model";

      // aaa group server
      container server {
        tailf:info "AAA Server group definitions";

        // aaa group server radius *
        list radius {
          tailf:info "Radius server-group definition";
          tailf:cli-mode-name "config-sg-radius";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server radius * / server
          container server {
            tailf:info "Specify a RADIUS server";

            // aaa group server radius * / server name
            list name {
              tailf:info "Name of radius server";
              tailf:cli-suppress-mode;
              //FIXME:delete-when-empty??
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "../../../name";
                }
                type string {
                  tailf:info "WORD;;Name";
                }
              }
            }

            // aaa group server radius * / server *
            list direct {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-suppress-mode;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                }
              }
              leaf auth-port {
                tailf:info "UDP port for RADIUS authentication server "+
                  "(default is 1645)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
              leaf acct-port {
                tailf:info "UDP port for RADIUS accounting server "+
                  "(default is 1646)";
                type uint16 {
                  tailf:info "<0-65535>;;Port number";
                  range "0..65535";
                }
              }
            }
          }

          // aaa group server radius * / server-private *
          list server-private {
            tailf:info "Define a private RADIUS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key name;
            leaf name {
              type inet:host {
                tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address of RADIUS server";
              }
            }
            uses radius-server-grouping;
          }

          // aaa group server radius * / backoff exponential
          container backoff {
            tailf:info "Retry backoff pattern (Default is retransmits with constant delay)";
            container exponential {
              tailf:info "Exponential retransmit backoff";
              tailf:cli-delete-when-empty;
              presence true;
              // aaa group server radius * / backoff exponential max-delay
              leaf max-delay {
                tailf:info "Max delay between retransmits(default is 3 min)";
                type uint8 {
                  tailf:info "<1-120>;;Max time (in minutes) to delay between retransmits";
                  range "1..120";
                }
                default 3;
              }
              leaf backoff-retry {
                tailf:info "Exponential backoff retry number(default is 8)";
                type uint8 {
                  tailf:info "<1-50>;;Number of retransmits in the exponential backoff mode";
                  range "1..50";
                }
                default 8;
              }
            }
          }

          // aaa group server radius * / ip
          container ip {
            tailf:info "Internet Protocol config commands";

            // aaa group server radius * / ip vrf forwarding
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/vrf/name";
                }
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }

            // aaa group server radius * / ip radius source-interface
            container radius {
              tailf:info "RADIUS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in RADIUS "
                  +"packets";
                uses interface-name-grouping;
              }
            }
          }

          // aaa group server radius * / deadtime
          leaf deadtime {
            tailf:info "Specify time in minutes to ignore an unresponsive "+
              "server";
            type uint16 {
              tailf:info "<0-1440>;;Dead-time in minutes for this server "+
                "group";
              range "0..1440";
            }
          }
        }

        // aaa group server tacacs+ *
        list tacacs-plus {
          tailf:alt-name "tacacs+";
          tailf:info "Tacacs+ server-group definition";
          tailf:cli-mode-name "config-sg-tacacs+";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Server-group name";
            }
          }

          // aaa group server tacacs+ * / server
          container server {
            tailf:info "Specify a TACACS server";

            // aaa group server tacacs+ * / server name *
            list name {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Tacacs server name";
                }
              }
            }

            // aaa group server tacacs+ * / server *
            list server-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                tailf:cli-disallow-value "name";
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
                }
              }
            }
          }

          // aaa group server tacacs+ * / server-private *
          list server-private {
            tailf:info "Define a private TACACS server (per group)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key name;
            leaf name {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
              }
            }

            // aaa group server tacacs+ * / server-private * timeout
            leaf timeout {
              tailf:info "Time to wait for this TACACS server to reply "+
                "(overrides default)";
              tailf:cli-optional-in-sequence;
              type uint16 {
                tailf:info "<1-1000>;;Timeout value in seconds to wait "+
                  "for server to reply";
                range "1..1000";
              }
            }

            // aaa group server tacacs+ * / server-private * key
            container "key" {
              tailf:info "per-server encryption key (overrides default)";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping;
            }
          }

          // aaa group server tacacs+ * / ip
          container ip {
            tailf:info "Internet Protocol config commands";

            // aaa group server tacacs+ * / ip vrf forwarding
            container vrf {
              tailf:info "Set VPN Routing Forwarding to use with the servers";
              leaf forwarding {
                tailf:info "Configure forwarding table";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/vrf/name";
                }
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }

            // aaa group server tacacs+ * / ip tacacs source-interface
            container tacacs {
              tailf:info "TACACS configuration commands";
              container source-interface {
                tailf:info "Specify interface for source address in "+
                  "TACACS packets";
                uses interface-name-grouping;
              }
            }
          }
        }

      }
    }

    // aaa authentication
    container authentication {
      tailf:info "Authentication configurations parameters.";
      tailf:cli-diff-dependency "../new-model";

      // aaa authentication attempts login
      container attempts {
        tailf:info "Set the maximum number of authentication attempts";
        leaf login {
          tailf:info "Set the max. number of attempts for login service";
          type uint8 {
            tailf:info "<1-25>;;Specify value for the number of attempts";
          }
          default 3;
        }
      }

      // aaa authentication username-prompt
      leaf username-prompt {
        tailf:info "Text to use when prompting for a username";
        type string {
          tailf:info "WORD;;Text of prompt";
        }
      }

      // aaa authentication dot1x *
      list dot1x {
        tailf:info "Set authentication lists for IEEE 802.1x.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        leaf cache {
          tailf:info "Use Cached-group";
          type aaa-group-type;
        }
        leaf group {
          tailf:info "Use Server-group";
          type aaa-group-type;
        }
      }

      // aaa authentication login *
      list login {
        tailf:info "Set authentication lists for logins.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }

      // aaa authentication enable default
      container enable {
        tailf:info "Set authentication list for enable.";
        container "default" {
          tailf:info "The default authentication list.";
          tailf:cli-compact-syntax;
          uses aaa-authentication-method-grouping;
        }
      }

      // aaa authentication ppp *
      list ppp {
        tailf:info "Set authentication lists for ppp.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authentication-name-type;
        }
        uses aaa-authentication-method-grouping;
      }
    }

    // aaa authorization
    container authorization {
      tailf:info "Authorization configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      // aaa authorization console
      leaf console {
        tailf:info "For enabling console authorization";
        type empty;
      }

      // aaa authorization config-commands
      leaf config-commands {
        tailf:info "For configuration mode commands.";
        type empty;
      }

      // aaa authorization exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-reset-container;
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization eventmanager *
      list eventmanager {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }

      // aaa authorization auth-proxy *
      list auth-proxy {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type aaa-authorization-name-type;
        }
        uses aaa-authorization-method-grouping;
      }
    }

    // aaa accounting
    container accounting {
      tailf:info "Accounting configurations parameters.";
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../new-model";

      // aaa accounting send stop-record authentication
      container send  {
        tailf:info "Send records to accounting server.";
        container stop-record {
          tailf:info "Generate STOP records for a specified event.";
          container authentication {
            tailf:info "Generate STOP records for authentication failures.";

            // aaa accounting send stop-record authentication failure
            leaf failure {
              tailf:info "Generate STOP records for authentication failures.";
              type empty;
            }

            // aaa accounting send stop-record authentication failure vrf *
            container failure-vrf {
              tailf:cli-drop-node-name;
              container failure {
                tailf:info "Generate STOP records for authentication failures.";
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                list vrf {
                  tailf:info "VPN Routing/Forwarding parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;VRF name";
                    }
                  }
                }
              }
            }
          }
        }
      }

      // aaa accounting nested
      container nested {
        tailf:info "When starting PPP from EXEC, generate NETWORK records before EXEC-STOP record.";
        tailf:cli-delete-when-empty;
        presence true;
        // aaa nested suppress stop
        container suppress {
          tailf:info "Exec accounting records suppression options";
          leaf stop {
            tailf:info "Suppress stop record for exec if network start record sent";
            type empty;
          }
        }
      }

      // aaa accounting commands *
      list commands {
        tailf:info "For exec (shell) commands.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "level name";
        leaf level {
          type uint8 {
            tailf:info "<0-15>;;Enable level";
            range "0..15";
          }
        }
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting exec *
      list exec {
        tailf:info "For starting an exec (shell).";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting network *
      list network {
        tailf:info "For network services. (PPP, SLIP, ARAP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting auth-proxy *
      list auth-proxy {
        tailf:info "For authentication proxy events.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting connection *
      list connection {
        tailf:info "For outbound connections. (telnet, rlogin)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting dot1x *
      list dot1x {
        tailf:info "For dot1x sessions.";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type aaa-accounting-name-type;
        }
        uses aaa-accounting-method-grouping;
      }

      // aaa accounting system default
      container system {
        tailf:info "For system events.";
        container "default" {
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          uses aaa-accounting-method-grouping;
        }
      }

      // aaa accounting suppress
      container suppress {
        tailf:info "Do not generate accounting records "+
          "for a specific type of user.";
        leaf null-username {
          tailf:info "Do not generate accounting records for users "+
            "with a null-username";
          type empty;
        }
      }

      // aaa accounting update
      container update {
        tailf:info "Enable accounting update records.";
        tailf:cli-compact-syntax;
        leaf newinfo {
          tailf:info "Only send accounting update records when we have new acct info.";
          type empty;
        }
        leaf periodic {
          tailf:info "Send accounting update records at regular intervals.";
          type uint32 {
            tailf:info "<1-71582>;;Periodic intervals to send accounting "+
              "update records(in minutes)";
            range "1..71582";
          }
        }
      }

      // aaa accounting delay-start
      container delay-start {
        tailf:info "Delay PPP Network start record until peer IP address is known.";
        //NOTE: tailf:cli-keep-when-empty;
        presence true;
        // aaa accounting delay-start all
        leaf all {
          tailf:info "Delay start records for all vrf and non-vrf users.";
          type empty;
        }
      }
    }

    // aaa session-id
    leaf session-id {
      tailf:info "AAA Session ID";
      tailf:cli-diff-dependency "../new-model";
      tailf:meta-data "suppress-no-command";
      type enumeration {
        enum common {
          tailf:info "Common Session ID";
        }
        enum "unique" {
          tailf:info "Unique Session ID for different accounting types";
        }
      }
    }

    // aaa attribute list *
    container attribute {
      tailf:info "AAA attribute definitions";
      tailf:cli-diff-dependency "../new-model";
      list "list" {
        tailf:info "AAA attribute list definition";
        tailf:cli-mode-name "config-attr-list";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;name";
          }
        }

        // aaa attribute list * / attribute type interface-config
        container attribute {
          tailf:info "Specify an AAA attribute";
          container "type" {
            tailf:info "Specify an AAA attribute type";
            leaf interface-config {
              tailf:info "Configuration commands for an interface";
              type string {
                tailf:info "WORD;;string";
              }
            }
          }
        }
      }
    }

    // aaa server radius dynamic-author
    container server {
      tailf:info "Local AAA server";
      tailf:cli-diff-dependency "../new-model";
      container radius {
        tailf:info "Profile for local radius server";
        container dynamic-author {
          tailf:info "Local server profile for RFC 3576 support";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-locsvr-da-radius";

          // aaa server radius dynamic-author / client *
          list client {
            tailf:info "Specify a RADIUS client";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key address;
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;IP address of RADIUS client";
              }
            }
            // aaa server radius dynamic-author / client * server-key
            container server-key {
              tailf:info "Specify a RADIUS client server-key";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses password-grouping {
                refine "secret" {
                  tailf:meta-data "secret-password" {
                    tailf:meta-value "aaa server radius dynamic-author<NL><*> :: client <client> server-key <PASSWORD>";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// switch
  /// ========================================================================

  // switch *
  list "switch" {
    tailf:info "Config commands for the switches in the stack";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-incomplete-command;
    key id;
    leaf id {
      type uint8 {
        tailf:info "<1-9>;;Switch Number";
        range "1..9";
      }
    }

    // switch * provision
    leaf provision {
      tailf:info "Configure Switch provision / offline config";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;provision a XXX switch with YYY";
      }
    }
  }


  /// ========================================================================
  /// resource
  /// ========================================================================

  container resource {
    tailf:info "Configure Embedded Resource Manager (ERM)";

    // resource policy
    container policy {
      tailf:info "policy  Configure Embedded Resource Manager (ERM)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-erm";
      tailf:cli-full-command;
      presence true;

      // resource policy / policy * global
      list policy {
        tailf:info "Configure Resource Policy";
        tailf:cli-mode-name "config-erm-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Resource Policy Name";
          }
        }
        leaf global {
          tailf:info "Configure a Global Policy";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // resource policy / policy * global / system
        leaf system {
          tailf:info "Configure System Level Resource Owners";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// cns
  /// ========================================================================

  container cns {
    tailf:info "CNS agents";

    // cns trusted-server *
    list trusted-server {
      tailf:info "Trusted Server Configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "agent name";
      leaf agent {
        type enumeration {
          enum "all-agents" {
            tailf:info "trusted  for all agents";
          }
          enum "config" {
            tailf:info "trusted for config agent";
          }
          enum "event" {
            tailf:info "trusted for event agent";
          }
          enum "exec" {
            tailf:info "trusted for exec agent";
          }
          enum "image" {
            tailf:info "trusted for image agent";
          }
        }
      }
      leaf name {
        type string {
          tailf:info "WORD;;Host name or address of trusted-server";
        }
      }
    }

    // cns id
    container id {
      tailf:info "Get CNS ID for CNS agents";

      // cns id string
      leaf string {
        tailf:info "Use an arbitrary string as the unique ID";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;e.g. hostname";
        }
      }

      // cns id string ? image
      // cns id string ? event
      container id-services-list {
        tailf:cli-drop-node-name;
        list string {
          tailf:info "Use an arbitrary string as the unique ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          key service;
          leaf string {
            tailf:cli-prefix-key;
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;e.g. hostname";
            }
          }
          leaf service {
            type enumeration {
              enum event {
                tailf:info "Set this ID as the event ID";
              }
              enum image {
                tailf:info "Set this ID as the image ID";
              }
            }
          }
        }
      }
    }

    // cns event *
    list event {
      tailf:info "Event Agent";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Host name or ip address of event gateway";
        }
      }
      leaf port-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Event Gateway port number, default is 11011";
          range "0..65535";
        }
      }
      // cns event * source
      container source {
        tailf:info "bind socket to a source ip";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      // cns event * keepalive
      container keepalive {
        tailf:info "Keepalive timeout retry_count";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;timeout in seconds , default is 0";
          }
        }
        leaf retry-count {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;retry count , default is 0";
          }
        }
      }
    }

    // cns image
    container image {
      tailf:info "CNS Image Agent";

      // cns image server
      container server {
        tailf:info "CNS Image Agent management server";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf server-url {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;URL to POST to for the management server";
          }
        }
        leaf "status" {
          tailf:info "CNS Image Agent status server";
          type string {
            tailf:info "WORD;;URL to POST status messages to";
          }
        }
      }
    }

    // cns config
    container "config" {
      tailf:info "Configuration Agent";

      // cns config notify
      container notify {
        tailf:info "Configuration change notification";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf capture {
          tailf:cli-drop-node-name;
          type enumeration {
            enum all {
              tailf:info "notify all config commands";
            }
            enum diff {
              tailf:info "notify config changes only";
            }
          }
        }
        leaf interval {
          tailf:info "send config change event if nothing entered in config "+
            "mode for this many minutes";
          type uint16 {
            tailf:info "<0-35791>;;number in minutes, default is 5";
            range "0..35791";
          }
        }
      }

      // cns config partial
      container partial {
        tailf:info "Partial Configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf host {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "WORD;;Host name or address of configuration server";
          }
        }
        leaf port-number {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-65535>;;the port number of the config service. default is 80";
          }
        }
      }
    }

    // cns exec
    list exec {
      tailf:info "Exec Agent";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      max-elements 1;
      key port-number;
      leaf encrypt {
        tailf:info "Use an encrypted link to the server";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf port-number {
        type uint16 {
          tailf:info "<1-65535>;;port number of plaintext exec service.";
          range "1..65535";
        }
      }
      container source {
        tailf:info "bind socket to a source ip";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
    }

    // cns dhcp
    leaf dhcp {
      tailf:info "Allow DHCP option 43 message to pass in config commands";
      type empty;
    }
  }


  /// ========================================================================
  /// epm
  /// ========================================================================

  container epm {
    tailf:info "EPM Global Configuration Commands";

    // epm logging
    leaf logging {
      tailf:info "Enable EPM logging";
      type empty;
    }
  }


  /// ========================================================================
  /// clock
  /// ========================================================================

  container clock {
    tailf:info "Configure time-of-day clock";

    // clock timezone
    container timezone {
      tailf:info "Configure time zone";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;name of time zone";
        }
      }
      leaf offset {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum +;
          enum -;
        }
      }
      leaf hours {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<-23 - 23>;;Hours offset from UTC";
          range "-23..23";
        }
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type int8 {
          tailf:info "<0-59>;;Minutes ofset from UTC";
          range "0..59";
        }
      }
    }

    // clock summer-time
    container summer-time {
      tailf:info "Configure summer (daylight savings) time";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf zone {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-disallow-value "date|recurring";
        type string {
          tailf:info "WORD;;name of time zone in summer";
        }
      }
      choice summer-choice {
        // clock summer-time date
        case date-case {
          leaf date {
            tailf:info "Configure absolute summer time";
            type empty;
          }
          leaf date-start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf date-start-date {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-31>;;Date to start";
              range "1..31";
            }
          }
          leaf date-start-year {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1993-2035>;;Year to start";
              range "1993..2035";
            }
          }
          leaf date-start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf date-end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf date-end-date {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-31>;;Date to end";
              range "1..31";
            }
          }
          leaf date-end-year {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1993-2035>;;Year to end";
              range "1993..2035";
            }
          }
          leaf date-end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
          leaf date-offset {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1440>;;Offset to add in minutes";
              range "1..1440";
            }
          }
        }

        // clock summer-time recurring
        case recurring-case {
          leaf recurring {
            tailf:info "Configure recurring summer time";
            type empty;
          }
          leaf start {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to start";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf start-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to start";
            }
          }
          leaf start-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to start";
            }
          }
          leaf start-time {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type hhmm-type {
              tailf:info "hh:mm;;Time to start (hh:mm)";
            }
          }
          leaf end {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type union {
              type uint8 {
                tailf:info "<1-4>;;Week number to end";
                range "1..4";
              }
              type enumeration {
                enum first {
                  tailf:info "First week of the month";
                }
                enum last {
                  tailf:info "Last week of the month";
                }
              }
            }
          }
          leaf end-day {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type weekday-type {
              tailf:info "DAY;;Weekday to end";
            }
          }
          leaf end-month {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type month-type {
              tailf:info "MONTH;;Month to end";
            }
          }
          leaf end-time {
            tailf:cli-drop-node-name;
            type hhmm-type {
              tailf:info "hh:mm;;Time to end (hh:mm)";
            }
          }
          leaf offset {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1440>;;Offset to add in minutes";
              range "1..1440";
            }
          }
        }
      }
    }

    // clock calendar-valid
    container calendar-valid {
      tailf:info "Calendar time is authoritative";
      presence true;
    }

  }


  /// ========================================================================
  /// device-sensor
  /// ========================================================================

  container device-sensor {
    tailf:info "IOS Sensor Commands";

    // device-sensor accounting
    leaf accounting {
      tailf:info "Trigger accounting updates with sensor TLVs/Options";
      type empty;
    }

    // device-sensor notify
    leaf notify {
      type enumeration {
        enum all-changes {
          tailf:info "Trigger identity update when TLVs are added/modified/removed";
        }
        enum new-tlvs {
          tailf:info "Trigger identity update only when TLVs are added";
        }
      }
      default new-tlvs;
    }
  }


  /// ========================================================================
  /// call-home
  /// ========================================================================

  container call-home {
    tailf:info "Enter call-home configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "cfg-call-home";

    // call-home / contact-email-addr
    leaf contact-email-addr {
      tailf:info "System Contact's email address";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Contact person's email address";
      }
    }

    // call-home / source-interface
    container source-interface {
      tailf:info "Specify source interface";
      uses interface-name-grouping;
    }

    // call-home / vrf
    leaf vrf {
      tailf:info "VPN Routing/Forwarding instance name";
      tailf:cli-diff-dependency "../../ip/vrf";
      tailf:cli-diff-dependency "../../vrf/definition";
      type string {
        tailf:info "WORD;;VRF instance name";
      }
    }

    // call-home / http-proxy
    container http-proxy {
      tailf:info "Specify proxy server for http request";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf server {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Http proxy server";
        }
      }
      leaf port {
        tailf:info "proxy server port number";
        type uint16 {
          tailf:info "<1-65535>;;http proxy server port number";
          range "1..65535";
        }
      }
    }

    // call-home / profile *
    list profile {
      tailf:info "Enter call-home profile configuration mode";
      tailf:cli-mode-name "cfg-call-home-profile";
      tailf:cli-full-command;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Profile name";
        }
      }

      // call-home / profile * / anonymous-reporting-only
      leaf anonymous-reporting-only {
        tailf:info "Enable call-home anonymous reporting only";
        type empty;
      }

      // call-home / profile * / no active
      leaf active {
        tailf:info "Activate the current profile";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // call-home / profile * / destination
      container destination {
        tailf:info "Message destination related configuration";

        // call-home / profile * / destination transport-method
        container transport-method {
          tailf:info "To specify transport method for this profile";

          // call-home / profile * / destination transport-method http
          leaf http {
            tailf:info "Enable http as transport method";
            type empty;
          }

          // call-home / profile * /  no destination transport-method email
          leaf email {
            tailf:info "Enable email as transport method";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // call-home / profile * / destination address
        container address {
          tailf:info "To add destination address to this profile";

          // call-home / profile * / destination address http
          leaf http {
            tailf:info "To add http address to this profile";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;HTTP url (1-200) characters";
            }
          }

          // call-home / profile * / destination address email
          leaf email {
            tailf:info "To add email address to this profile";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;HTTP url (1-200) characters";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// facility-alarm
  /// ========================================================================

  container facility-alarm {
    tailf:info "Alarm thresholds configuration";

    // facility-alarm core-temperature
    container core-temperature {
      tailf:info "Threshold for processor module temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm outlet-temperature
    container outlet-temperature {
      tailf:info "Threshold for air outlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm intake-temperature
    container intake-temperature {
      tailf:info "Threshold for air inlet temperature";
      uses facility-alarm-grouping;
    }

    // facility-alarm critical exceed-action shutdown
    container critical {
      tailf:info "Behavior on critical threshold exceed";
      leaf exceed-action {
        tailf:info "Behavior on critical threshold exceed";
        type enumeration {
          enum shutdown {
            tailf:info "Behavior on critical threshold exceed";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cef
  /// ========================================================================

  container cef {
    tailf:info "Cisco Express Forwarding";
    container table {
      tailf:info "Set CEF forwarding table characteristics";
      container output-chain {
        tailf:info "Set table output chain characteristics";
        container build {
          tailf:info "Set table output chain building characteristics";

          // cef table output-chain build favor
          leaf favor {
            tailf:info "Set which table output chain building "+
              "characteristics to favor";
            type enumeration {
              enum convergence-speed {
                tailf:info "Favor faster convergence";
              }
              enum memory-utilization {
                tailf:info "Favor smaller memory utilization";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ipdr
  /// ========================================================================

  container ipdr {
    tailf:info "IPDR Configuration";

    // ipdr session *
    list session {
      tailf:info "IPDR session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf session-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR session name";
        }
      }
      leaf session-descr {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;IPDR session description";
        }
      }
    }

    // ipdr type *
    list "type" {
      tailf:info "IPDR session type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      choice type-choice {
        leaf ad-hoc {
          tailf:info "Ad-hoc type session";
          type empty;
        }
        leaf event {
          tailf:info "Event type session";
          type empty;
        }
        leaf time-interval {
          tailf:info "Time interval type session";
          type uint16 {
            tailf:info "<15-1440>;;Interval in minute";
          }
        }
      }
    }

    // ipdr collector *
    list collector {
      tailf:info "IPDR collector";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;IPDR collector name string";
        }
      }
      leaf ip-addr {
        tailf:cli-drop-node-name;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IPDR collector ip address";
        }
      }
      leaf port {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;IPDR collector port";
          range "1..65535";
        }
      }
    }

    // ipdr associate *
    list associate {
      tailf:info "IPDR collector to session association";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf collector-name {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;IPDR collector name";
        }
      }
      leaf priority {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Priority of the collector in session, "+
            "lower number is higher priority";
          range "1..10";
        }
      }
    }

    // ipdr template *
    list template {
      tailf:info "IPDR template";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key session-id;
      leaf session-id {
        type uint8 {
          tailf:info "<1-255>;;IPDR session id";
          range "1..255";
        }
      }
      leaf template-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Template name";
        }
      }
    }

    // ipdr exporter
    container exporter {
      tailf:info "IPDR exporter";

      // ipdr exporter start
      leaf start {
        tailf:info "start IPDR exporter";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// qos
  /// ========================================================================

  // qos
  container qos-conf {
    tailf:cli-drop-node-name;
    leaf qos {
      tailf:info "Global QoS configuration subcommands";
      type empty;
    }
  }

  // qos X
  container qos {
    tailf:info "Global QoS configuration subcommands";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // qos dbl
    container dbl {
      tailf:info "Global DBL configuration";
      tailf:cli-display-separated;
      presence true;

      // qos dbl exceed-action
      container exceed-action {
        tailf:info "mark the packets when dbl limit is exceeded";

        // qos dbl exceed-action ecn
        leaf ecn {
          tailf:info "use explicit congestion notification";
          type empty;
        }

        // qos dbl exceed-action probability
        leaf probability {
          tailf:info "specify marking probability";
          type uint8 {
            tailf:info "<0-100>;;probability";
            range "0..100";
          }
        }
      }
    }

    // qos map
    container map {
      tailf:info "QoS mapping tables";

      // qos map dscp
      container dscp {
        tailf:info "Configure DSCP mapping tables";

        // qos map dscp * to tx-queue
        list dscp-to-tq-queue {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key "to tx-queue";
          leaf to {
            type enumeration {
              enum "to" {
                tailf:info "Map DSCP to";
              }
            }
          }
          leaf tx-queue  {
            tailf:info "Map DSCP to transmit queue";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<1-4>;;Transmit queue number";
              range "1..4";
            }
          }
          uses dscp-value-0-7-grouping;
        }

        // qos map dscp * to cos
        list dscp-to-cos {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key "to cos";
          leaf to {
            type enumeration {
              enum "to" {
                tailf:info "Map DSCP to";
              }
            }
          }
          leaf cos {
            tailf:info "Map DSCP to CoS";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-7>;;Mapped CoS value";
              range "0..7";
            }
          }
          uses dscp-value-0-7-grouping;
        }
      }

      // qos map cos * to dscp
      container cos {
        tailf:info "Configure CoS mapping tables";
        list cos-to-dscp {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key "to dscp";
          leaf to {
            type enumeration {
              enum "to" {
                tailf:info "Map CoS to";
              }
            }
          }
          leaf dscp {
            tailf:info "Map CoS to DSCP";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-63>;;Mapped DSCP value";
              range "0..63";
            }
          }
          uses cos-value-0-7-grouping;
        }
      }
    }

    // qos account layer2 encapsulation
    container account {
      tailf:info "Additional lengths to be accounted by QoS Features";
      container layer2 {
        tailf:info "Accounting Layer 2 headers";
        container encapsulation {
          tailf:info "Account Layer 2 Encapsulation when applying QoS features";

          // qos account layer2 encapsulation length
          leaf "length" {
            tailf:info "Layer2 Encapsulation length in bytes";
            type uint8 {
              tailf:info "<0-64>;;Layer2 Encapsulation length in bytes";
              range "0..64";
            }
          }
        }
      }
    }

    // no qos rewrite ip dscp
    container rewrite {
      tailf:info "QoS Rewrite Configuration";
      container ip {
        tailf:info "QoS IP Rewrite Configuration";
        leaf dscp {
          tailf:info "Rewrite DSCP bits in the ToS Byte of IP Header";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // qos aggregate-policer *
    list aggregate-policer {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Aggregate policer name";
        }
      }
      leaf rate {
        tailf:cli-drop-node-name;
        type uint64 {
          tailf:info "<32000-32000000000>;;Rate in bits per second (postfix k, m, g optional; decimal point allowed)";
          range "32000..32000000000";
        }
      }
      leaf xps {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum pps {
            tailf:info "Treat 'rate' value in packets-per-second";
          }
          enum bps {
            tailf:info "Treat 'rate' value in bytes-per-second";
          }
        }
      }
      leaf burst {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1000-512000000>;;Normal burst bytes";
          range "1000..512000000";
        }
      }
      leaf burst-type {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum byte {
            tailf:info "Treat 'burst' value as bytes";
          }
        }
      }
      container conform-action {
        tailf:info "action when rate is not exceeded";
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice action-choice {
          leaf drop {
            tailf:info "drop packet";
            type empty;
          }
          leaf transmit {
            tailf:info "transmit packet";
            type empty;
          }
        }
      }
      leaf exceed-action {
        tailf:info "action when rate is exceeded";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum drop {
            tailf:info "drop packet";
          }
          enum policed-dscp-transmit {
            tailf:info "change dscp per policed-dscp map and send it";
          }
          enum transmit {
            tailf:info "transmit packet";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// card
  /// ========================================================================

  container card {
    tailf:info "Configure card type";

    // card * 4jacket-1
    // Note: Cisco 10000
    list card-slot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "slot card-type";
      leaf slot {
        type uint8 {
          tailf:info "<1-3>;;Enter odd slot";
          range "1|3";
        }
      }
      leaf card-type {
        type enumeration {
          enum "4jacket-1" {
            tailf:info "create a 4jacket-1 cardtype";
          }
        }
      }
    }

    // card *
    // Note: Cisco 10000
    list card-slot-subslot {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key "slot-subslot card-type";
      leaf slot-subslot {
        type string {
          tailf:info "<0-9>/<0-3>;;Enter slot/subslot "+
            "(subslot 2 and 3 is for SPA only)";
          pattern "[0-9]/[0-3]";
        }
      }
      leaf card-type {
        type enumeration {
          enum "24rfchannel-spa-1" {
            tailf:info "create a Wideband DOCSIS SPA";
          }
          enum "2cable-dtcc" {
            tailf:info "Utility Card w/DTI (EightBells)";
          }
          enum "2cable-tccplus" {
            tailf:info "Utility Card";
          }
          enum SPA-1XTENGE-XFP-V2 {
            tailf:info "create a 10GE SPA 1 PORT cardtype";
          }
          enum SPA-2X1GE-V2 {
            tailf:info "create a GE SPA 2 PORT cardtype";
          }
          enum SPA-5X1GE-V2 {
            tailf:info "create a GE SPA 5 PORT cardtype";
          }
          enum SPA-8X1GE-V2 {
            tailf:info "create a GE SPA 8 PORT cardtype";
          }
          enum SPA-DOCSIS-HD-V1 {
            tailf:info "create a High Density DOCSIS SPA";
          }
          enum ubr10k-clc-3g60 {
            tailf:info "create a uBR10000 line card with MC3Gx60";
          }
          enum ubr10k-clc-mc2020v {
            tailf:info "create a uBR10000 line card with MC20x20";
          }
          enum 1gigethernet-1 {
            tailf:info "create a GE_1_PORT cardtype";
          }
          enum 1gigethernet-hh-1 {
            tailf:info "create a GE1H_1_PORT cardtype";
          }
          enum cBR-CCAP-LC-40G {
            tailf:info "create a cBR line card with CCAP-LC-40G";
          }
          enum sup-pic-8x10g {
            tailf:info "create a sup-pic 8x10G card";
          }
        }
      }
      leaf SPA-DOCSIS-HD-V1-port {
        when "../card-type = 'SPA-DOCSIS-HD-V1'"  {
          tailf:dependency "../card-type";
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum "1x10GE" {
            tailf:info "using 1x10GE port";
          }
          enum "3x1GE" {
            tailf:info "using 3x1GE port";
          }
        }
      }
      leaf license {
        tailf:info "create a license for the line card";
        type string {
          tailf:info "WORD;;License string";
        }
      }
    }

    // card type
    container "type" {
      tailf:info "Configure card type";

      // card type t1 *
      list t1 {
        tailf:info "T1";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key slot;
        leaf slot {
          type uint8;
        }
      }
      container t1-bay {
        tailf:cli-drop-node-name;
        list t1 {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "slot bay";
          leaf slot {
            type uint8 {
              tailf:info "<0-2>;;Card slot number (always 0 "+
                "for 1800 series & 2801 routers)";
            }
          }
          leaf bay {
            type uint8 {
              tailf:info "<0-3>;;WIC slot number "+
                "(0:WIC, 1:Onboard for NM-HDV2)";
            }
          }
        }
      }

      // card type t3 *
      list t3 {
        tailf:info "T3";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot subslot";
        leaf slot {
          type uint8 {
            tailf:info "<0-6>;;Card slot number";
          }
        }
        leaf subslot {
          type uint8 {
            tailf:info "<0-6>;;Card subslot number";
          }
        }
      }

      // card type e1 *
      list e1 {
        tailf:info "E1";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot bay";
        leaf slot {
          type uint8 {
            tailf:info "<0-x>;;Card slot number";
          }
        }
        leaf bay {
          type uint8 {
            tailf:info "<0-x>;;WIC slot number";
          }
        }
      }

      // card type e3 *
      list e3 {
        tailf:info "E3";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "slot subslot";
        leaf slot {
          type uint8 {
            tailf:info "<0-6>;;Card slot number";
          }
        }
        leaf subslot {
          type uint8 {
            tailf:info "<0-6>;;Card subslot number";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// hw-module
  /// ========================================================================

  container hw-module {
    tailf:info "Slot/subslot/port level commands";

    // hw-module bay * shutdown
    list bay {
      tailf:info "Bay level commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;<1-3>/<0-3>";
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the target subslot";
        type empty;
      }
      choice power-choice {
        leaf powered {
          tailf:info "Hold the target subslot in reset";
          type empty;
        }
        leaf unpowered {
          tailf:info "Power-off the target subslot";
          type empty;
        }
      }
    }

    // hw-module ism *
    list ism {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "<0-1>;;Service module slot number";
        }
      }
    }

    // hw-module slot *
    list slot {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-6>;;slot number of line card";
        }
      }

      // hw-module slot * process-max-time
      leaf process-max-time {
        tailf:info "Maximum time for process to run before voluntarily "+
          "relinquishing processor";
        type uint16 {
          tailf:info "<20-200>;;The number of millisecs before voluntary suspend";
          range "20..200";
        }
      }
    }

    // hw-module module
    container "module" {
      tailf:info "Specify a linecard slot for the hw-module command";

      // hw-module module * port-group *
      list module-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key "name port-group";
        leaf name {
          type uint8 {
            tailf:info "<1-7>;;module slot number";
          }
        }
        leaf port-group {
          tailf:info "onfigure port-group";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-4>;;port-group number";
          }
        }
        leaf select {
          tailf:info "Select a port-group interface type";
          type enumeration {
            enum gigabitethernet {
              tailf:info "Select this port-group's gigabit interfaces";
            }
            enum tengigabitethernet {
              tailf:info "Select this port-group's 10G interfaces";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// cable
  /// ========================================================================

  container cable {
    tailf:info "Global cable configuration";

    // cable profile
    container profile {
      tailf:info "Global profile configuration";

      // cable profile mac-domain *
      list mac-domain {
        tailf:info "Select a mac-domain common profile to configure";
        tailf:cli-mode-name "config-profile-md";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;mac-domain common profile name";
          }
        }

        // cable profile mac-domain * / cable
        container cable {
          tailf:info "Cable interface subcommands";

          // cable profile mac-domain * / cable dynamic-secret reject
          container dynamic-secret {
            tailf:info "Enable dynamic secret for CM config files";
            container reject {
              tailf:info "Reject registration request from modems violating dynamic secret";
              tailf:cli-delete-when-empty;
              presence true;
              leaf nocrypt {
                tailf:info "Do not encrypt modem config file name";
                type empty;
              }
            }
          }

          // cable profile mac-domain * / cable privacy bpi-plus-policy total-enforcement
          container privacy {
            tailf:info "Cable Privacy";
            leaf bpi-plus-policy {
              tailf:info "Privacy requires BPI+";
              type enumeration {
                enum capable-enforcement {
                  tailf:info "BPI+ required for all capable modems with BPI+ enabled (policy 1)";
                }
                enum d11-enabled-enforcement {
                  tailf:info "BPI+ required for all D1.1 and later modems with BPI+ enabled (policy 2)";
                }
                enum d11-enforcement {
                  tailf:info "BPI+ required for all D1.1 and later modems (policy 3)";
                }
                enum total-enforcement {
                  tailf:info "BPI+ required for all modems (policy 4)";
                }
              }
            }
          }
        }
      }

      // cable profile wideband-interface *
      list wideband-interface {
        tailf:info "Select a wideband interface common profile to configure";
        tailf:cli-mode-name "config-profile-wb";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;wideband interface common profile name";
          }
        }

        // cable profile wideband-interface * / cable downstream
        container cable {
          tailf:info "Wideband-Cable interface subcommands";
          container downstream {
            tailf:info "Downstream parameter configuration";
            leaf attribute-mask {
              tailf:info "Downstream channel provisioned Attribute Mask";
              type string {
                tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
              }
            }
          }
        }
      }

      // cable profile downstream *
      list downstream {
        tailf:info "Select a downstream interface common profile to configure";
        tailf:cli-mode-name "config-profile-ds";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;downstream interface common profile name";
          }
        }

        // cable profile downstream * / cable
        container cable {
          tailf:info "Integrated-Cable interface subcommands";

          // cable profile downstream * / cable rf-bandwidth-percent
          container rf-bandwidth-percent {
            tailf:info "% of reserved RF channel bandwidth";
            leaf percent-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
          }

          // cable profile downstream * / cable attribute-mask
          leaf attribute-mask {
            tailf:info "Downstream channel provisioned Attribute Mask";
            type string {
              tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
            }
          }
        }
      }

      // cable profile service-group *
      list service-group {
        tailf:info "Create fiber-node service group profile";
        tailf:cli-mode-name "config-profile-sg";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;fiber-node service group profile name";
          }
        }

        // cable profile service-group * / cable bundle
        container cable {
          tailf:info "cable subcommand";
          leaf bundle {
            tailf:info "Bundle number for bundling of cable interfaces";
            type uint8 {
              tailf:info "<1-255>;;Bundle number";
              range "1..255";
            }
          }
        }

        // cable profile service-group * / mac-domain *
        list mac-domain {
          tailf:info "Cable Mac Domain";
          tailf:cli-mode-name "config-profile-sg-md";
          tailf:cli-sequence-commands;
          key id;
          leaf id {
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-15>;;mac-domain id";
              range "0..15";
            }
          }
          leaf profile {
            tailf:info "mac-domain profile";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "../../../mac-domain/name";
            }
            type string {
              tailf:info "WORD;;mac-domain profile name";
            }
          }

          // cable profile service-group * / mac-domain * / downstream
          container downstream {
            tailf:cli-break-sequence-commands;
            tailf:info "Add a ds service group channel to a MD";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;

            // cable profile service-group * / mac-domain * / downstream sg-channel *
            list sg-channel {
              tailf:info "ds service group channel";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key profile;
              leaf profile {
                tailf:info "IC interface profile";
                tailf:cli-expose-key-name;
                tailf:cli-suppress-range;
                type string {
                  tailf:info "WORD;;IC interface profile name";
                }
              }
              leaf-list id {
                // Note: List separated by ',' in NCS, on device by ' '. Java converts.
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                tailf:cli-range-list-syntax;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                type uint8 {
                  tailf:info "<grouplist>;;List of Ranges for sg-channels <0-254>";
                  range "0..254";
                }
              }
              leaf upstream {
                tailf:info "Upstream sg-channels serving these downstream sg-channels";
                type string {
                  tailf:info "<grouplist>;;List of Ranges for upstream sg-channels <0-7>";
                }
              }
            }
          }

          // cable profile service-group * / mac-domain * / upstream *
          list upstream {
            tailf:info "Add a us service group channel to a MD";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-15>;;US channel index in MD";
                range "0..15";
              }
            }
            leaf sg-channel {
              tailf:info "us service group channel";
              type uint8 {
                tailf:info "<0-254>;;US sg-channel index";
                range "0..254";
              }
            }
          }

          // cable profile service-group * / mac-domain * / us-bonding-group *
          list us-bonding-group {
            tailf:info "Configure upstream bonding group";
            tailf:cli-mode-name "config-profile-sg-md-usb";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;bonding group id";
                range "1..65535";
              }
            }

            // cable profile service-group * / mac-domain * / us-bonding-group * / admission-control
            container admission-control {
              tailf:info "Configure Cable Admission Control";
              leaf max-reserved-bandwidth {
                tailf:info "Configure maximum AC reserved bandwidth for this bonding group.";
                type uint32 {
                  tailf:info "NUM;;Maximum AC reserved bandwidth Value in kbps";
                }
              }
            }

            // cable profile service-group * / mac-domain * / us-bonding-group * / upstream *
            list upstream {
              tailf:info "Add an upstream to this bonding group";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-15>;;upstream to add";
                  range "0..15";
                }
              }
            }
          }
        }

        // cable profile service-group * /  wideband-interface * profile
        list wideband-interface {
          tailf:info "Downstream bonding group";
          tailf:cli-mode-name "config-profile-sg-bg";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-63>;;downstream bonding group id";
              range "0..63";
            }
          }
          leaf profile {
            tailf:info "wideband interface profile";
            tailf:cli-hide-in-submode;
            tailf:non-strict-leafref {
              path "../../../wideband-interface/name";
            }
            type string {
              tailf:info "WORD;;wideband interface profile name";
            }
          }

          // cable profile service-group * /  wideband-interface * / downstream sg-channel *
          container downstream {
            tailf:info "Add a ds service group channel to a BG";
            list sg-channel {
              tailf:info "ds service group channel";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                tailf:cli-multi-value;
                tailf:cli-suppress-range;
                type string {
                  tailf:info "<grouplist>;;List of Ranges for sg-channels <0-254>";
                }
              }
              leaf rf-bandwidth-percent {
                tailf:info "ds service group channel";
                type uint8 {
                  tailf:info "<1-100>;;bandwidth";
                  range "1..100";
                }
              }
            }
          }
        }
      }
    }

    // cable downstream
    container downstream {
      tailf:info "configure at chassis level";

      // cable downstream freq-profile *
      list freq-profile {
        tailf:info "configure chassis level freq profile";
        tailf:cli-mode-name "config-freq-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;RFGW Frequency profile ID or Name";
          }
        }

        // cable downstream freq-profile * / lane *
        list lane {
          tailf:info "lane configurations";
          tailf:cli-mode-name "config-freq-prof-lane";
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-4>;;lane id ";
              range "1..4";
            }
          }
          leaf start-freq {
            tailf:info "starting freq keyword for the lane";
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<48000000-995000000>;;lane start frequency";
              range "48000000..995000000";
            }
          }

          // cable downstream freq-profile * / lane * / block *
          list block {
            tailf:info "block configurations";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-4>;;block id ";
                range "1..4";
              }
            }
            leaf start-freq {
              tailf:info "starting freq keyword for the block";
              type uint32 {
                tailf:info "<48000000-995000000>;;block start frequency";
              }
            }
          }
        }
      }

      // cable downstream rf-profile *
      list rf-profile {
        tailf:info "configure chassis level rf profile";
        tailf:cli-mode-name "config-rf-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;RFGW RF profile ID or Name";
          }
        }

        // cable downstream rf-profile * / cable downstream
        container cable {
          tailf:info "cable keyword under rf profile config mode";
          container downstream {
            tailf:info "downstream configurations for the rf profile";

            // cable downstream rf-profile * / cable downstream annex
            leaf annex {
              tailf:info "MPEG framing format, annex A|B|C";
              tailf:cli-full-command;
              type enumeration {
                enum "A" {
                  tailf:info "annex A, European Standard";
                }
                enum "B" {
                  tailf:info "annex B, North American Standard";
                }
                enum "C" {
                  tailf:info "annex C, Japan Standard";
                }
              }
            }

            // cable downstream rf-profile * / cable downstream modulation
            leaf modulation {
              tailf:info "set QAM modulation format";
              tailf:cli-full-command;
              type enumeration {
                enum "256" {
                  tailf:info "256QAM";
                }
                enum "64" {
                  tailf:info "64QAM ";
                }
              }
            }

            // cable downstream interleaver-depth
            container interleaver-depth {
              tailf:info "Interleaver Depth, allows 2 options";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf option1 {
                tailf:info "Interleaver Depth option 1";
                tailf:cli-incomplete-command;
                type cable-downstream-interleaver-depth-option;
              }
              leaf option2 {
                tailf:info "Interleaver Depth option 2";
                type cable-downstream-interleaver-depth-option;
              }
            }

            // cable downstream symbol-rate
            leaf symbol-rate {
              tailf:info "set the symbol rate";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<3500000-7000000>;;symbols per second";
              }
            }
          }
        }
      }

      // cable downstream qam-profile *
      list qam-profile {
        tailf:info "configure chassis level qam profile";
        tailf:cli-mode-name "config-qam-prof";
        key name;
        leaf name {
          type string {
            tailf:info "<0-31>;;Qam Profile ID (<0-3> system defined, "+
              "<4-31> user defined)";
          }
        }

        // cable downstream qam-profile * / annex B
        leaf annex {
          tailf:info "MPEG framing format, annex A|B|C";
          type enumeration {
            enum "A" {
              tailf:info "annex A, European Standard";
            }
            enum "B" {
              tailf:info "annex B, North American Standard";
            }
            enum "C" {
              tailf:info "annex C, Japan Standard";
            }
          }
        }

        // cable downstream qam-profile * / modulation 64
        leaf modulation {
          tailf:info "set QAM modulation format";
          type enumeration {
            enum "256" {
              tailf:info "256QAM";
            }
            enum "64" {
              tailf:info "64QAM ";
            }
          }
        }

        // cable downstream qam-profile * / interleaver-depth I32-J4
        leaf interleaver-depth {
          tailf:info "Interleaver Depth";
          type enumeration {
            enum I12-J17 {
              tailf:info "INTERLEAVER-I-12-J-17 for Annex A or C";
            }
            enum I128-J1 {
              tailf:info "INTERLEAVER-I-128-J-1 for Annex B";
            }
            enum I128-J2 {
              tailf:info "INTERLEAVER-I-128-J-2 for Annex B";
            }
            enum I128-J3 {
              tailf:info "INTERLEAVER-I-128-J-3 for Annex B";
            }
            enum I128-J4 {
              tailf:info "INTERLEAVER-I-128-J-4 for Annex B";
            }
            enum I128-J5 {
              tailf:info "INTERLEAVER-I-128-J-5 for Annex B";
            }
            enum I128-J6 {
              tailf:info "INTERLEAVER-I-128-J-6 for Annex B";
            }
            enum I128-J7 {
              tailf:info "INTERLEAVER-I-128-J-7 for Annex B";
            }
            enum I128-J8 {
              tailf:info "INTERLEAVER-I-128-J-8 for Annex B";
            }
            enum I16-J8  {
              tailf:info "INTERLEAVER-I-16-J-8 for Annex B ";
            }
            enum I32-J4  {
              tailf:info "INTERLEAVER-I-32-J-4 for Annex B ";
            }
            enum I64-J2  {
              tailf:info "INTERLEAVER-I-64-J-2 for Annex B ";
            }
            enum I8-J16  {
              tailf:info "INTERLEAVER-I-8-J-16 for Annex B ";
            }
          }
        }

        // cable downstream qam-profile * / symbol-rate 5057
        leaf symbol-rate {
          tailf:info "set the symbol rate";
          type uint32 {
            tailf:info "<NUM>;;set symbol rate value in kilo-symbol/sec";
          }
        }

        // cable downstream qam-profile * / spectrum-inversion off
        leaf spectrum-inversion {
          tailf:info "set spectrum inversion";
          type enumeration {
            enum off {
              tailf:info "spectrum-inversion off ";
            }
            enum on {
              tailf:info "spectrum-inversion on";
            }
          }
        }

        // cable downstream qam-profile * / description default-annex-b-64-qam
        uses description-grouping;
      }

      // cable downstream controller-profile *
      list controller-profile {
        tailf:info "configure downstream controller profile mode";
        tailf:cli-mode-name "config-controller-profile";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-255>;;Downstream controller-profile ID";
          }
        }

        // cable downstream controller-profile * / shutdown
        leaf shutdown {
          tailf:info "Shutdown RF Port";
          type empty;
        }

        // cable downstream controller-profile * / description
        uses description-grouping;

        // cable downstream controller-profile * / max-carrier
        leaf max-carrier {
          tailf:info "Max Carrier of a RF Port";
          type uint8 {
            tailf:info "<1-158>;;RF Port Max Carrier Value";
            range "1..158";
          }
        }

        // cable downstream controller-profile * / base-channel-power
        leaf base-channel-power {
          tailf:info "set base channel power level";
          type uint8 {
            tailf:info "<35-44>;;Base Channel Power Value in dBmV";
          }
        }

        // cable downstream controller-profile * / rf-chan
        container rf-chan {
          tailf:info "Configure RF Channel";
          list rf-chan {
            tailf:cli-drop-node-name;
            tailf:cli-mode-name "config-prof-rf-chan";
            key start;
            leaf start {
              type uint8 {
                tailf:info "<0-162>;;Starting Qam ID";
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint8 {
                tailf:info "<1-162>;;Ending QAM ID";
                range "1..162";
              }
            }
            uses controller-integrated-cable-rf-chan-grouping;
          }
        }
      }
    }

    // cable upstream
    container upstream {
      tailf:info "global upstream parameters";

      // cable upstream rate-adapt
      container rate-adapt {
        tailf:info "rate adapt";
        tailf:cli-compact-syntax;
        leaf priority {
          tailf:info "Configure priority to enable rate-adapt";
          type uint8 {
            tailf:info "<0-7>;;priority at or above enables rate-adapt.";
            range "0..7";
          }
        }
        leaf rate {
          tailf:info "Configure rate to enable rate-adapt";
          type uint32 {
            tailf:info "<0-30000000>;;rate at or above enables rate-adapt.";
            range "0..30000000";
          }
        }
        leaf local {
          tailf:info "Enable rate-adapt locally per upstream";
          type empty;
        }
      }

      // cable upstream controller-profile *
      list controller-profile {
        tailf:info "configure upstream controller profile mode";
        tailf:cli-mode-name "config-controller-profile";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<0-511>;;upstream controller-profile number";
          }
        }

        // cable upstream controller-profile * / description
        uses description-grouping;

        // cable upstream controller-profile * / us-channel *
        uses us-channel-grouping;
      }
    }

    // cable linecard *
    list linecard {
      tailf:info "Linecard related configuration";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<3-12>;;linecard slot number";
          range "3..12";
        }
      }

      // cable linecard * encryption
      leaf encryption {
        tailf:info "encryption options are pkey or dvb or or pme or clear";
        type enumeration {
          enum clear {
            tailf:info "Encryption type is CLEAR";
          }
          enum dual-crypt {
            tailf:info "Encryption type is dual-crypt";
          }
          enum dvb {
            tailf:info "Encryption type is DVB";
          }
          enum pkey {
            tailf:info "Encryption type is PowerKEY";
          }
          enum pme {
            tailf:info "Encryption type is PME";
          }
        }
      }

      // cable linecard * scrambler
      leaf scrambler {
        tailf:info "scrambler options are des or csa or none";
        type enumeration {
          enum none {
            tailf:info "Scrambling algorithm is NONE";
          }
          enum csa {
            tailf:info "Scrambling algorithm is CSA";
          }
          enum des {
            tailf:info "Scrambling algorithm is DES";
          }
        }
      }
    }

    // cable admission-control preempt priority-voice
    // no cable admission-control preempt priority-voice
    container admission-control {
      tailf:info "Configure Cable Admission Control";
      container preempt {
        tailf:info "Reason for preemption";
        leaf priority-voice {
          tailf:info "Priority Voice call can preempt normal";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable flap-list
    container flap-list {
      tailf:info "Cable flap-list configuration";

      // cable flap-list aging
      leaf aging {
        tailf:info "Flap-list aging";
        type uint32 {
          tailf:info "<1-86400>;;Maximum number of minutes the cable modem "+
            "is kept in the flap-list";
          range "1..86400";
        }
      }
    }

    // cable source-verify
    container source-verify {
      tailf:info "Source verify";

      // cable source-verify leasequery-filter
      container leasequery-filter {
        tailf:info "Source verify Lease query filter";

        // cable source-verify leasequery-filter downstream
        container downstream {
          tailf:info "Source verify Lease query filter for downstream pkts";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf threshold {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-255>;;Number of lease queries for unknown sid";
              range "0..255";
            }
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-10>;;size of time window in seconds";
              range "1..10";
            }
          }
        }
      }
    }

    // cable modem
    container modem {
      tailf:info "Modem polling using SNMP query";

      // cable modem remote-query
      container remote-query {
        tailf:info "Modem polling using SNMP query";

        // cable modem remote-query <interval> <community string>
        container gather {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf polling-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-86400>;;Periodic polling interval in seconds";
              range "1..86400";
            }
          }
          leaf community-string {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Community string ";
            }
          }
        }

        // cable modem remote-query src-ip
        leaf src-ip {
          tailf:info "source IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source IP addr";
          }
        }
      }

      // cable modem max-cpe
      leaf max-cpe {
        tailf:info "Max CPE override";
        type union {
          type uint8 {
            tailf:info "<1-255>;;Number";
          }
          type enumeration {
            enum unlimited {
              tailf:info "Max CPE not enforced";
            }
          }
        }
      }

      // cable modem v6-max-cpe-prefix
      leaf v6-max-cpe-prefix {
        tailf:info "Max CPE override";
        type uint16 {
          tailf:info "<0-1023>;;Number";
          range "0..1023";
        }
      }

      // cable modem vendor *
      list vendor {
        tailf:info "Cable modem vendor information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key oui;
        leaf oui {
          type string {
            tailf:info "WORD;;OUI of the vendor in the format "+
              "xx.xx.xx or xx:xx:xx";
          }
        }
        leaf vendor-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;Vendor name";
          }
        }
      }
    }

    // cable modulation-profile
    container modulation-profile {
      tailf:info "Modulation profile";

      // cable modulation-profile *
      list modulation-profile-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key profile;
        leaf profile {
          type string {
            tailf:info "WORD;;Modulation Profile Group";
          }
        }
        // cable modulation-profile * atdma
        container atdma {
          tailf:info "DOCSIS2.0 atdma mode";
          uses cable-modulation-profile-list-grouping;
        }
        // cable modulation-profile * tdma
        container tdma {
          tailf:info "DOCSIS1.x tdma mode";
          uses cable-modulation-profile-list-grouping;
        }
        // cable modulation-profile * mixed
        container mixed {
          tailf:info "DOCSIS1.x/2.0 tdma-atdma mixed mode";
          uses cable-modulation-profile-list-grouping;
        }
        uses cable-modulation-profile-list-grouping;
      }
    }

    // cable tag *
    list tag {
      tailf:info "cable tag";
      tailf:cli-mode-name "config-cmts-tag";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-1000>;;The id of the tag";
          range "1..1000";
        }
      }
      // cable tag * / name
      leaf name {
        tailf:info "Name of the tag";
        type string {
          tailf:info "WORD;;Globally unique name string of the tag";
        }
      }

      // cable tag * / service-type-id
      leaf service-type-id {
        tailf:info "Set the match rule for service type id";
        type string {
          tailf:info "WORD;;Service Type ID";
        }
      }

      // cable tag * / docsis-version
      leaf docsis-version {
        tailf:info "Set the match rule for DOCSIS version";
        type enumeration {
          enum docsis10 {
            tailf:info "Match docsis 1.0 modems";
          }
          enum docsis11 {
            tailf:info "Match docsis 1.1 modems";
          }
          enum docsis20 {
            tailf:info "Match docsis 2.0 modems";
          }
          enum docsis30 {
            tailf:info "Match docsis 3.0 modems";
          }
        }
      }

      // cable tag * / service-class
      leaf service-class {
        tailf:info "Set the match rule for service class name";
        type string {
          tailf:info "WORD;;Service class name";
        }
      }
    }

    // cable service
    container service {
      tailf:info "Service flow/class setting";

      // cable service class *
      list class {
        tailf:info "Service class settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key class-index;
        leaf class-index {
          type uint16 {
            tailf:info "<1-1023>;;Class Index";
            range "1..1023";
          }
        }

        // cable service class * name
        leaf name {
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;The ascii string identifier for this "+
              "Service Class";
          }
        }

        // cable service class * downstream
        // cable service class * upstream
        choice direction-choice {
          leaf downstream {
            tailf:info "Service Class is downstream";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../name";
            tailf:meta-data "suppress-delete-error-invalid";
            type empty;
          }
          leaf upstream {
            tailf:info "Service Class is upstream";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../name";
            tailf:meta-data "suppress-delete-error-invalid";
            type empty;
          }
        }

        // cable service class * peak-rate
        leaf peak-rate {
          tailf:info "Peak Rate within maximum traffic burst";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Peak Rate (bps";
          }
        }

        // cable service class * max-concat-burst
        leaf max-concat-burst {
          tailf:info "Max Concat Burst";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Max Concat Burst (bytes)";
          }
        }

        // cable service class * tos-overwrite
        container tos-overwrite {
          tailf:info "Overwrite TOS byte by setting mask bits to value";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../name";
          leaf and-mask {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xFF>;,TOS-overwrite-mask-and byte in hex";
            }
          }
          leaf or-mask {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "<0x0-0xFF>;;TOS-overwrite-mask-or byte in hex";
            }
          }
        }

        // cable service class * req-trans-policy
        leaf req-trans-policy {
          tailf:info "Request Transmission Policy Bit Field";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../name";
          type string {
            tailf:info "<0x0-0xFFFFFFFF>;;Enter Request Transmission Policy Bit Field in hex";
          }
        }

        // cable service class * max-rate
        leaf max-rate {
          tailf:info "Max Rate";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Max Rate (bps)";
          }
        }

        // cable service class * max-burst
        leaf max-burst {
          tailf:info "Max Tx Burst";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<1522-4294967295>;;Enter Max Tx Burst (bytes)";
            range "1522..4294967295";
          }
        }

        // cable service class * min-rate
        leaf min-rate {
          tailf:info "Min Rate";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Min Resv Rate (bps)";
          }
        }

        // cable service class * min-packet-size
        leaf min-packet-size {
          tailf:info "Min Packet Size for Reserved Rate";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Min Packet Size for Reserved Rate(bytes)";
          }
        }

        // cable service class * max-latency
        leaf max-latency {
          tailf:info "Max Latency";
          tailf:cli-diff-dependency "../name";
          type uint32 {
            tailf:info "<0-4294967295>;;Enter Max Latency(usecs)";
          }
        }

        // cable service class * req-attr-mask
        leaf req-attr-mask {
          tailf:info "Required Attribute Mask";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../name";
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }

        // cable service class * admission-timeout
        leaf admission-timeout {
          tailf:info "Admitted QoS Param Set Timeout";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter Admitted QoS Param Set Timeout";
          }
        }

        // cable service class * activity-timeout
        leaf activity-timeout {
          tailf:info "QoS Param Set Activity Timeout";
          tailf:cli-diff-dependency "../name";
          type uint16 {
            tailf:info "<0-65535>;;Enter QoS Param Set Activity Timeout";
          }
        }

        // cable service class * priority
        leaf priority {
          tailf:info "Priority";
          tailf:cli-diff-dependency "../name";
          type uint8 {
            tailf:info "<0-7>;;Enter Priority";
            range "0..7";
          }
        }

        // cable service class * sched-type
        leaf sched-type {
          tailf:info "Service Class Schedule Type";
          tailf:cli-diff-dependency "../name";
          type enumeration {
            enum "2" {
              tailf:info "Best Effort Schedule Type";
            }
            enum "3" {
              tailf:info "Non Real-Time Polling Service Schedule Type";
            }
            enum "4" {
              tailf:info "Real-Time Polling Service Schedule Type";
            }
            enum "5" {
              tailf:info "Unsolicited Grant Service with Activity "+
                "Detection Schedule Type";
            }
            enum "6" {
              tailf:info "Unsolicited Grant Service Schedule Type";
            }
          }
        }
      }

      // cable service type *
      list "type" {
        tailf:info "service type";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Service Type Id";
          }
        }
        leaf ds-frequency {
          tailf:info "downstream frequency";
          type uint32 {
            tailf:info "<55000000-858000000>;;Frequency - Hz";
            range "55000000..858000000";
          }
        }
      }

      // cable service attribute
      container attribute {
        tailf:info "Service attribute settings";

        // cable service attribute ds-bonded downstream-type bonding-enabled
        container ds-bonded {
          tailf:info "Downstream Bonding Settings";
          container downstream-type {
            tailf:info "Bonding downstream-type settings";
            container bonding-enabled {
              tailf:info "Channel Bonding only supported on Bonding-capable interfaces";
              tailf:cli-delete-when-empty;
              presence true;
              leaf enforce {
                tailf:info "Enforce Bonding-capable interface selection";
                type empty;
              }
            }
          }
        }

        // cable service attribute withhold-tlvs peak-rate
        container withhold-tlvs {
          tailf:info "Withhold D3.0 TLVs from pre-D3.0 modems";
          leaf peak-rate {
            tailf:info "Peak Traffic Rate TLV 24/25.27";
            type empty;
          }
        }
      }

      // cable service flow activity-timeout
      container flow {
        tailf:info "Service flow settings";
        leaf activity-timeout {
          tailf:info "Default value for Service flow activity timeout";
          type uint16 {
            tailf:info "<0-65535>;;Seconds";
          }
        }
      }
    }

    // cable qos
    container qos {
      tailf:info "Cable Quality of Service";

      // cable qos permission
      container permission {
        tailf:info "Permission for Creating Cable Quality of Service Profile";
        // cable qos permission create
        // no cable qos permission create
        leaf create {
          tailf:info "Allow create by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission update
        // no cable qos permission update
        leaf update {
          tailf:info "Allow update by management";
          tailf:cli-show-no;
          type empty;
        }
        // cable qos permission modems
        // no cable qos permission modems
        leaf modems {
          tailf:info "Allow create by modems";
          tailf:cli-show-no;
          type empty;
        }
      }
    }

    // cable multicast mdf-disable WB-Incapable-CM
    container multicast {
      tailf:info "Cable Multicast";
      container mdf-disable {
        tailf:info "Disable Multicast DSID Forwarding mode";
        leaf WB-Incapable-CM {
          tailf:info "Wideband Incapable modems only";
          type empty;
        }
      }
    }

    // cable filter
    container filter {
      tailf:info "CMTS packet filter settings";

      // cable filter group *
      list group {
        tailf:info "CMTS packet filter group settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key group-id;
        leaf group-id {
          type uint8 {
            tailf:info "<1-254>;;Group ID";
            range "1..254";
          }
        }
        // cable filter group * index *
        list index {
          tailf:info "CMTS packet filter index settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index-num;
          leaf index-num {
            type uint8 {
              tailf:info "<1-255>;;Filter Index";
            }
          }
          // cable filter group * index * src-ip
          leaf src-ip {
            tailf:info "IP source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address";
            }
          }
          // cable filter group * index * src-mask
          leaf src-mask {
            tailf:info "IP source address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP source address mask";
            }
          }
          // cable filter group * index * dest-ip
          leaf dest-ip {
            tailf:info "IP destination address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address";
            }
          }
          // cable filter group * index * dest-mask
          leaf dest-mask {
            tailf:info "IP destination address mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP destination address mask";
            }
          }
          // cable filter group * index * v6-src-address
          leaf v6-src-address {
            tailf:info "IPv6 source address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Enter IPv6 source address";
            }
          }
          // cable filter group * index * v6-src-pfxlen
          leaf v6-src-pfxlen {
            tailf:info "IPv6 source address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Source Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-dest-address
          leaf v6-dest-address {
            tailf:info "IPv6 destination address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Enter IPv6 destination address";
            }
          }
          // cable filter group * index * v6-dest-pfxlen
          leaf v6-dest-pfxlen {
            tailf:info "IPv6 destination address prefix length";
            type uint8 {
              tailf:info "<0-128>;;Enter Destination Address Prefix Length";
              range "0..128";
            }
          }
          // cable filter group * index * v6-flow-label
          leaf v6-flow-label {
            tailf:info "IPv6 flow label";
            type uint32 {
              tailf:info "<0-1048575>;;Enter IPv6 flow label";
              range "0..1048575";
            }
          }
          // cable filter group * index * ip-proto
          leaf ip-proto {
            tailf:info "IP protocol";
            type uint16 {
              tailf:info "<0-256>;;Enter IP protocol type";
              range "0..256";
            }
          }
          // cable filter group * index * ip-tos
          container ip-tos {
            tailf:info "IP TOS byte settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf tos-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0xFF>;;Enter mask against TOS value, "+
                  "byte in hex";
              }
            }
            leaf tos-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0xFF>;;Enter TOS value, byte in hex";
              }
            }
          }
          // cable filter group * index * src-port
          leaf src-port {
            tailf:info "TCP/UDP source port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Source Port";
            }
          }
          // cable filter group * index * dest-port
          leaf dest-port {
            tailf:info "TCP/UDP destination port";
            type uint16 {
              tailf:info "<0-65535>;;Enter TCP/UDP Destination Port";
            }
          }
          // cable filter group * index * ip-version
          leaf ip-version {
            tailf:info "IP version of filter";
            type enumeration {
              enum IPv4 {
                tailf:info "Filter is for IPv4 (default)";
              }
              enum IPv6 {
                tailf:info "Filter is for IPv6";
              }
            }
            default IPv4;
          }
          // cable filter group * index * tcp-flags
          container tcp-flags {
            tailf:info "TCP flags settings";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf flags-mask {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0x3F;;Enter TCP Flags Mask in Hex";
              }
            }
            leaf flags-value {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "<0x0-0x3F>;;Enter TCP Flags Value in Hex";
              }
            }
          }
          // cable filter group * index * match-action
          leaf match-action {
            tailf:info "Filter Match action processing";
            type enumeration {
              enum accept {
                tailf:info "Accept Packet on Match";
              }
              enum drop {
                tailf:info "Drop Packet on Match";
              }
            }
          }
          // cable filter group * index * status
          leaf "status" {
            tailf:info "Status of filter";
            type enumeration {
              enum active {
                tailf:info "Filter is active";
              }
              enum inactive {
                tailf:info "Filter is inactive";
              }
            }
            default active;
          }
        }
      }
    }

    // cable submgmt
    container submgmt {
      tailf:info "CMTS Subscriber Management Objects";
      container "default" {
        tailf:info "Defaults";
        container filter-group {
          tailf:info "Configure Filter Group";
          // cable submgmt default filter-group cm
          container cm {
            tailf:info "CM Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group cpe
          container cpe {
            tailf:info "CPE Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group mta
          container mta {
            tailf:info "MTA Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group stb
          container stb {
            tailf:info "STB Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
          // cable submgmt default filter-group ps
          container ps {
            tailf:info "PS Group Defaults";
            uses cable-submgmt-default-filter-group-grouping;
          }
        }
        // cable submgmt default active
        leaf active {
          tailf:info "CPE Control for Subscriber Management Filtering";
          type empty;
        }
      }
    }

    // cable logging
    container logging {
      tailf:info "Logs specific cable messages";

      // cable logging badipsource
      container badipsource {
        tailf:info "cable BADIPSOURCE messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging layer2events
      container layer2events {
        tailf:info "cable layer 2 messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging overlapip
      container overlapip {
        tailf:info "cable OVERLAPIP messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging ironbus
      container ironbus {
        tailf:info "cable IRONBUS messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }

      // cable logging downstream-index
      container downstream-index {
        tailf:info "cable downstream index messages";
        tailf:cli-delete-when-empty;
        presence true;
        leaf buffer-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<4096-4121440>;;Buffer size";
          }
        }
      }
    }

    // cable default-tos-qos10 tos-overwrite
    container default-tos-qos10 {
      tailf:info "Default DOCSIS 1.0 ToS Overwrite";
      container tos-overwrite {
        tailf:info "Overwrite ToS byte by setting mask bits to value";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf tos-and {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-and byte in hex";
          }
        }
        leaf tos-or {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "<0x0-0xFF>;;ToS-overwrite-mask-or byte in hex";
          }
        }
      }
    }

    // cable primary-sflow-qos11 keep
    container primary-sflow-qos11 {
      tailf:info "Keep the primary service flows after CM in QoS DOCSIS11 "+
        "mode offline";
      leaf keep {
        tailf:info "Keep the primary service flows after CM in QoS "+
          "DOCSIS11 mode offline";
        type enumeration {
          enum all {
            tailf:info "Keep CLI and SNMP counters after CM in QoS DOCSIS11 "+
            "mode offline";
          }
          enum snmp-only {
            tailf:info "Keep SNMP counters only after CM in QoS DOCSIS11 "+
              "mode offline";
          }
        }
      }
    }

    // cable sflog
    container sflog {
      tailf:info "CMTS Service Flow Logging Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf max-entry {
        tailf:info "Max. number of entries in service flow log.";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<30000-59999>;;Max. number of entries in the service "+
            "flow log.";
          range "30000..59999";
        }
      }
      leaf entry-duration {
        tailf:info "Service flow log entry duration in second";
        type uint32 {
          tailf:info "<3600-86400>;;Service flow log entry duration in second.";
          range "3600..86400";
        }
      }
    }

    // cable trust *
    list trust {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type string {
          tailf:info "H.H.H;;MAC address of the trusted host";
        }
      }
    }

    // cable dynamic-secret
    container dynamic-secret {
      tailf:info "Cable dynamic secret";

      // cable dynamic-secret exclude
      container exclude {
        tailf:info "Exclude single modem";
        // cable dynamic-secret exclude modem
        leaf modem {
          tailf:info "Exclude single modem";
          type string {
            tailf:info "H.H.H;;MAC address of the modem to exclude";
          }
        }
        // cable dynamic-secret exclude oui
        leaf oui {
          tailf:info "Exclude group of modems based on OUI";
          type string {
            tailf:info "WORD;;OUI to exclude";
          }
        }
      }

      // cable dynamic-secret tftp
      container tftp {
        tailf:info "TFTP Proxy Options";
        // cable dynamic-secret tftp insert-upgrade-server
        leaf insert-upgrade-server {
          tailf:info "Automatically insert upgrade server TLV into the "+
            "DOCSIS configuration file";
          type empty;
        }
      }
    }

    // cable docsis30-voice downstream
    container docsis30-voice {
      tailf:info "Docsis 3.0 voice default configurations";
      container downstream {
        tailf:info "Downstream Service parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf req-attr-mask {
          tailf:info "SF Required Attribute Mask";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
        leaf forb-attr-mask {
          tailf:info "SF Forbidden Attribute Mask";
          type string {
            tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
          }
        }
      }
    }

    // cable util-interval
    leaf util-interval {
      tailf:info "Set channel utilization interval";
      type uint32 {
        tailf:info "<1-86400>;;The time interval in seconds";
        range "1..86400";
      }
    }

    // cable clock
    container clock {
      tailf:info "Clock card";

      // cable clock dti
      leaf dti {
        tailf:info "set DTI clock reference mode";
        type empty;
      }

      // cable clock dti-server-type
      leaf dti-server-type {
        tailf:info "Server type configuration (Polylink/Symmetricom)";
        type enumeration {
          enum polylink {
            tailf:info "DTI server type - Polylink";
          }
          enum symmetricom {
            tailf:info "DTI server type - Symmetricom";
          }
        }
      }
    }

    // cable bgsync
    container bgsync {
      tailf:info "switch snmp sync state";

      // no cable bgsync active
      leaf active {
        tailf:info "set background sync status";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // cable bgsync ptime
      leaf ptime {
        tailf:info "set how long(unit second) a p packet sent";
        type uint32 {
          tailf:info "<5-86400>;;in second";
          range "5..86400";
        }
        default 5;
      }

      // cable bgsync itime
      leaf itime {
        tailf:info "set how long(unit second) a i packet sent";
        type uint32 {
          tailf:info "<5-31536000>;;in second";
          range "5..31536000";
        }
        default 86400;
      }
    }

    // cable privacy
    container privacy {
      tailf:info "Cable Privacy";

      // cable privacy encrypt-alg-priority
      leaf encrypt-alg-priority {
        tailf:info "Encryption algorithm priority";
        type enumeration {
          enum aes128-des40-des56 {
            tailf:info "Priority AES128, DES40, DES56";
          }
          enum aes128-des56-des40 {
            tailf:info "Priority AES128, DES56, DES40";
          }
          enum des40-aes128-des56 {
            tailf:info "Priority DES40, AES128, DES56";
          }
          enum des40-des56-aes128 {
            tailf:info "Priority DES40, DES56, AES128";
          }
          enum des56-aes128-des40 {
            tailf:info "Priority DES56, AES128, DES40";
          }
          enum des56-des40-aes128 {
            tailf:info "Priority DES56, DES40, AES128";
          }
        }
      }
    }

    // cable dsg
    container dsg {
      tailf:info "Set DSG advance mode global parameters";

      // cable dsg client-list * id-index *
      list client-list {
        tailf:info "DSG client list settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key client-list-id;
        leaf client-list-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG client list ID";
            range "1..65535";
          }
        }
        list id-index {
          tailf:info "DSG Client ID settings";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;DSG client ID index for the client list";
              range "1..65535";
            }
          }
          choice parameter-choice {
            leaf application-id {
              tailf:info "DSG Client type Application ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type "+
                  "Application ID";
              }
            }
            leaf broadcast {
              tailf:info "DSG Client type broadcast";
              type uint16 {
                tailf:info "<1--65535>;;DSG Broadcast client";
                range "1..65535";
              }
            }
            leaf ca-system-id {
              tailf:info "DSG Client type CA system ID";
              type string {
                tailf:info "<1-FFFF>;;Hex value of DSG Client type "+
                  "CA system ID";
              }
            }
            leaf mac-addr {
              tailf:info "DSG Client type Mac address";
              type string {
                tailf:info "H.H.H;;DSG Client MAC address";
              }
            }
          }
        }
      }

      // cable dsg tg *
      list tg {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key group-id;
        leaf group-id {
          type uint16 {
            tailf:info "<1-65535>;;DSG Tunnel Group ID";
            range "1..65535";
          }
        }
        // cable dsg tg * channel *
        list channel {
          tailf:info "DSG Channel";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key channel-id;
          leaf channel-id {
            type uint16 {
              tailf:info "<1-65535>;;DSG Channel ID";
              range "1..65535";
            }
          }
          // cable dsg tg * channel * priority
          leaf priority {
            tailf:info "DSG Rule priority";
            type uint8 {
              tailf:info "<0-255>;;DSG Rule priority";
            }
          }
          // cable dsg tg * channel * enable
          // cable dsg tg * channel * disable
          leaf "status" {
            tailf:cli-drop-node-name;
            type enumeration {
              enum disable {
                tailf:info "Disable DSG tunnel group";
              }
              enum enable {
                tailf:info "Enable DSG tunnel group";
              }
            }
            default enable;
          }
        }
      }

      // cable dsg tunnel *
      list tunnel {
        tailf:info "DSG tunnel";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key tunnel-id;
        leaf tunnel-id {
          type uint16 {
            tailf:info "<1-65535>;;Tunnel id";
            range "1..65535";
          }
        }
        leaf mac-addr {
          tailf:info "destination MAC address";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "H.H.H;;Multicast group MAC address";
          }
        }
        leaf tg {
          tailf:info "tunnel group id";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-65535>;;tunnel group id";
            range "1..65535";
          }
        }
        leaf clients {
          tailf:info "DSG Clients";
          type uint16 {
            tailf:info "<1-65535>;;DSG Clients";
            range "1..65535";
          }
        }
        leaf "status" {
          tailf:cli-drop-node-name;
          type enumeration {
            enum disable {
              tailf:info "disable tunnel";
            }
            enum enable {
              tailf:info "enable tunnel";
            }
          }
          default enable;
        }
      }

      // cable dsg cfr *
      list cfr {
        tailf:info "DSG classifier";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;Classifier index";
            range "1..65535";
          }
        }
        leaf dest-ip {
          tailf:info "destination IP address";
          type string {
            tailf:info "WORD;;Multicast group IP address or hostname";
          }
        }
        leaf tunnel {
          tailf:cli-break-sequence-commands;
          tailf:info "tunnel index";
          type uint16 {
            tailf:info "<1-65535>;;tunnel index";
            range "1..65535";
          }
        }
        leaf priority {
          tailf:info "Classifier priority";
          type uint8 {
            tailf:info "<0-255>;;Classifier priority";
          }
        }
        leaf src-ip {
          tailf:info "source IP address";
          type string {
            tailf:info "WORD;;source IP address or hostname";
          }
        }
        leaf in-dcd {
          tailf:info "classifier is included in DCD or not";
          type enumeration {
            enum ignore {
              tailf:info "classifier is not included in DCD regardless "+
              "of tunnel MAC address";
            }
            enum no {
              tailf:info "classifier is not included in DCD";
            }
            enum yes {
              tailf:info "classifier is included in DCD";
            }
          }
        }
      }

      // cable dsg timer *
      list timer {
        tailf:info "DSG Timer settings";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key index;
        leaf index {
          type uint16 {
            tailf:info "<1-65535>;;DSG Timer index";
            range "1..65535";
          }
        }
        leaf Tdsg1 {
          tailf:info "DSG Initialization Timeout (Tdsg1) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg1) value";
            range "1..65535";
          }
        }
        leaf Tdsg2 {
          tailf:info "DSG Operational Timeout (Tdsg2) setting";
          type uint16 {
            tailf:info "<1-65535>;;DSG Initialization Timeout (Tdsg2) value";
            range "1..65535";
          }
        }
        leaf Tdsg3 {
          tailf:info "DSG Two-Way Retry Timer (Tdsg3) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg3) value";
          }
        }
        leaf Tdsg4 {
          tailf:info "DSG One-Way Retry Timer (Tdsg4) setting";
          type uint16 {
            tailf:info "<0-65535>;;DSG Initialization Timeout (Tdsg4) value";
          }
        }
      }

      // cable dsg chan-list * index * freq
      list chan-list {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key "id index";
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;DSG Channel List index";
            range "1..65535";
          }
        }
        leaf index {
          tailf:info "DSG channel frequency entry setting";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;DSG channel frequency entry index";
            range "1..65535";
          }
        }
        leaf freq {
          tailf:info "DSG Channel Frequency setting";
          type uint32 {
            tailf:info "<47000000-862000000>;;Center frequency of the downstream channel in Hz";
          }
        }
      }
    }

    // cable load-balance
    container load-balance {
      tailf:info "DOCSIS load balancing";

      // cable load-balance docsis-enable
      leaf docsis-enable {
        tailf:info "Enable docsis 2.0 load balancing";
        type empty;
      }

      // cable load-balance docsis30-enable
      container docsis30-enable {
        tailf:info "Enable docsis 3.0 load balancing";
        tailf:cli-delete-when-empty;
        presence true;
        // cable load-balance docsis30-enable downstream-only
        leaf downstream-only {
          type empty;
        }
      }

      // cable load-balance modem max-failures
      container modem {
        tailf:info "Modem settings";
        leaf max-failures {
          tailf:info "Set the time of failed movements before modem is "+
            "removed from dynamic LB";
          type uint8 {
            tailf:info "<0-100>;;Maximum failures before modem is "+
              "removed from dynamic LB";
            range "0..100";
          }
        }
      }

      // cable load-balance rule *
      list rule {
        tailf:info "Enter docsis load balance rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key rule-id;
        leaf rule-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            range "1..4294967295";
          }
        }
        choice status-choice {
          container ds {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower "+
                "than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound ds
              leaf ds {
                tailf:info "Specify DS throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          container us {
            tailf:cli-drop-node-name;
            container disable-throughput-lowerbound {
              tailf:info "load balance is disabled if CM throughput is lower "+
                "than a threshold";
              // cable load-balance rule * disable-throughput-lowerbound us
              leaf us {
                tailf:info "Specify US throughput lowerbound";
                type uint32 {
                  tailf:info "<0-1000000>;;Throughput lowerbound in kbps";
                  range "0..1000000";
                }
              }
            }
          }
          leaf disabled {
            tailf:info "load balance is always disabled";
            type empty;
          }
          leaf enabled {
            tailf:info "load balance is always enabled";
            type empty;
          }
        }
      }

      // cable load-balance docsis-policy *
      list docsis-policy {
        tailf:info "Enter docsis load balance policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key policy-id;
        leaf policy-id {
          type uint32 {
            tailf:info "<1-4294967295>;;DOCSIS load balance policy ID";
            range "1..4294967295";
          }
        }
        // cable load-balance docsis-policy * rule *
        list rule {
          tailf:info "Enter docsis load balance rule";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key rule-id;
          leaf rule-id {
            type uint32 {
              tailf:info "<1-4294967295>;;DOCSIS load balance rule ID";
            }
          }
        }
        // cable load-balance docsis-policy * tag
        leaf tag {
          tailf:info "Tag name";
          type string {
            tailf:info "WORD;;Tag name";
          }
        }
        // cable load-balance docsis-policy * override
        leaf override {
          tailf:info "Override the default";
          type empty;
        }
      }

      // cable load-balance d20-ggrp-default
      container d20-ggrp-default {
        tailf:info "Set DOCSIS 2.0 general group default value ";

        // cable load-balance d20-ggrp-default init-tech-list
        leaf init-tech-list {
          tailf:info "Set DOCSIS GGRP DCC/DBC init tech as default";
          type uint32 {
            tailf:info "<grouplist>;;Set DCC/DBC Initialization technique list as default";
          }
        }

        // cable load-balance d20-ggrp-default method utilization
        container method {
          tailf:info "Set default load balancing type/method";
          container utilization {
            tailf:info "Interface utilization";
            presence true;
          }
        }

        // cable load-balance d20-ggrp-default policy
        container policy {
          tailf:info "Set default load balancing policy";

          // cable load-balance d20-ggrp-default policy pure-ds-load
          leaf pure-ds-load {
            tailf:info "Do not count US load when calculating DS utilization";
            type empty;
          }
        }

        // cable load-balance d20-ggrp-default threshold
        container threshold {
          tailf:info "Set default load balancing threshold in %";

          // cable load-balance d20-ggrp-default threshold load
          container load {
            tailf:info "Set default interface load threshold setting";
            leaf "value" {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Set threshold value in % as default";
                range "1..100";
              }
            }
          }
        }
      }

      // cable load-balance d30-ggrp-default
      container d30-ggrp-default {
        tailf:info "Set DOCSIS 3.0 general group default value";

        // cable load-balance d30-ggrp-default disable
        leaf disable {
          tailf:info "Set disable DOCSIS GGRP as default";
          type empty;
        }

        // cable load-balance d30-ggrp-default init-tech-list
        leaf init-tech-list {
          tailf:info "Set DOCSIS GGRP DCC/DBC init tech as default";
          type string {
            tailf:info "<grouplist>;;Set DCC/DBC Initialization technique "+
              "list as default";
          }
        }

        // cable load-balance d30-ggrp-default docsis-policy
        leaf docsis-policy {
          tailf:info "Set DOCSIS GGRP policy ID as default";
          type uint32 {
            tailf:info "<0-4294967295>;;Set DOCSIS load balance policy "+
              "ID as default";
          }
        }

        // cable load-balance d30-ggrp-default policy
        leaf policy {
          tailf:info "Set default load balancing policy";
          type enumeration {
            enum pcmm {
              tailf:info "Enable balancing of modems with active PCMM service flows";
            }
            enum pure-ds-load {
              tailf:info "Do not count US load when calculating DS utilization";
            }
            enum ugs {
              tailf:info "Enable balancing of modems with active UGS service flows";
            }
            enum us-across-ds {
              tailf:info "Load balancing on US groups across DS, DS method will be ignored";
            }
          }
        }

        // cable load-balance d30-ggrp-default threshold
        container threshold {
          tailf:info "Set default load balancing threshold in %";

          // cable load-balance d30-ggrp-default threshold load
          container load {
            tailf:info "Set default interface load threshold setting";
            leaf load-value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Set threshold value in % as default";
                range "1..100";
              }
            }
            // cable load-balance d30-ggrp-default threshold load minimum
            leaf minimum {
              tailf:info "Set minimum number of modems/flows difference before loadbalancing starts as default";
              type uint8 {
                tailf:info "<1-100>;;Set minimum number of modems/flows as default";
                range "1..100";
              }
            }
          }
        }
      }

      // cable load-balance docsis-group
      container docsis-group {
        tailf:info "DOCSIS group";

        // cable load-balance docsis-group FN *
        list FN {
          tailf:cli-mode-name "config-lb-group";
          key fn-id;
          leaf fn-id {
            type uint16 {
              tailf:info "<1-256>;;cable fiber-node ID";
              range "1..256";
            }
          }
          container MD {
            tailf:info "Enter MAC-domain interface";
            tailf:cli-hide-in-submode;
            tailf:cli-flatten-container;
            leaf Cable {
              tailf:info "Cable;;CMTS interface";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              tailf:cli-hide-in-submode;
              tailf:non-strict-leafref {
                path "../../../../../../interface/Cable/name";
              }
              type string {
                pattern '[0-9]+.*';
              }
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }

        // cable load-balance docsis-group *
        list docsis-group-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-lb-group";
          key docsis-group-id;
          leaf docsis-group-id {
            type uint32 {
              tailf:info "<1-2147483647>;;DOCSIS load balance group number";
              range "1..2147483647";
            }
          }
          uses cable-load-balance-docsis-group-grouping;
        }
      }

      // cable load-balance group *
      list group {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-256>;;Load balance group number";
            range "1..256";
          }
        }
      }

      // cable load-balance exclude
      container exclude {
        tailf:info "Exclude modems from load balancing";

        // cable load-balance exclude oui *
        list oui {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key word;
          leaf word {
            type string {
              tailf:info "WORD;;OUI of exclude modem in the formatxx.xx.xx "+
                "or xx:xx:xx";
            }
          }
          leaf assignment {
            tailf:info "Exclude modem at assigning phase";
            tailf:cli-full-command;
            type empty;
          }
          leaf enforce {
            tailf:info "Exclude only for enforced load balancing";
            tailf:cli-full-command;
            type empty;
          }
          leaf static {
            tailf:info "Exclude only for static load balancing";
            type empty;
          }
          leaf strict {
            tailf:info "Exclude all forms of load balancing";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

    }

    // cable metering
    container metering {
      tailf:info "CMTS Metering Configuration";

      // cable metering destination
      // cable metering ipdr-d3 session
      choice cable-metering-choice {
        container destination {
          tailf:info "Cable Metering Collector IP address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf ip-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of primary";
            }
          }
          leaf port {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of primary";
              range "1..65535";
            }
          }
          leaf ip-address2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter IP address of secondary";
            }
          }
          leaf port2 {
            when "../ip-address2" {
              tailf:dependency "../ip-address2";
            }
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;Enter Port Number of secondary";
              range "1..65535";
            }
          }
          leaf retries {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-5>;;Enter number of retries ";
              range "0..5";
            }
          }
          leaf minutes {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<2-1440>;;Enter metering data collection interval "+
                "in minutes";
              range "2..1440";
            }
          }
          leaf security {
            tailf:cli-drop-node-name;
            type enumeration {
              enum non-secure {
                tailf:info "Non secure streaming";
              }
              enum secure {
                tailf:info "Secure streaming";
              }
            }
          }
          leaf flow-aggregate {
            tailf:cli-break-sequence-commands;
            tailf:info "Only aggregate service flow information";
            type empty;
          }
          leaf cpe-list-suppress {
            tailf:info "Suppress cpe information";
            type empty;
          }
          leaf full-records {
            tailf:info "Full service flow (active and idle) records";
            type empty;
          }
        }
        container ipdr-d3 {
          tailf:info "Cable Metering Exporter through IPDR D3.0";
          container session {
            tailf:info "IPDR D3 session";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf session-id {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-255>;;Enter metering ipdr D3 session id";
                range "1..255";
              }
            }
            leaf "type" {
              tailf:info "IPDR D3 Service Definition Type of Metering";
              type uint8 {
                tailf:info "<1-2>;;Enter metering IPDR D3 Service "+
                  "Definition Type";
                range "1..2";
              }
            }
            leaf flow-aggregate {
              tailf:info "Only aggregate service flow information";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf full-records {
              tailf:info "Full service flow (active and idle) records";
              type empty;
            }
          }
        }
      }

      // cable metering ipdr ? session ?
      container ipdr {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<2-1440>;;Enter metering data streaming interval in minutes";
            range "2..1440";
          }
        }
        leaf session {
          tailf:info "IPDR session";
          type uint8 {
            tailf:info "<1-255>;;Enter metering ipdr session id";
            range "1..255";
          }
        }
        leaf flow-aggregate {
          tailf:info "Only aggregate service flow information";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf full-records {
          tailf:info "Full service flow (active and idle) records";
          type empty;
        }
      }

      // cable metering source-interface
      container source-interface {
        tailf:info "source-interface for the billing packets";
        uses interface-name-grouping;
      }

      // cable metering data-per-session
      container data-per-session {
        tailf:info "Number of flows per session";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf data-per-session {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<3-30>;;Enter # of data flows per session";
            range "3..30";
          }
        }
        leaf timer {
          tailf:info "CLC timer to wake up ";
          type uint16 {
            tailf:info "<8-500>;;Enter timer wake up interval in msec";
            range "8..500";
          }
        }
      }
    }

    // cable rf-change-trigger
    container rf-change-trigger {
      tailf:info "NP RF status change trigger";
      tailf:cli-compact-syntax;
      leaf percent {
        tailf:info "% of CM report NP RF status change";
        type uint8 {
          tailf:info "<1-100>;;% of CM report NP RF status change";
          range "1..100";
        }
      }
      leaf count {
        tailf:info "#of CM report NP RF status change";
        type uint16 {
          tailf:info "<1-65535>;;#of CM report NP RF status change";
          range "1..65535";
        }
      }
      leaf secondary {
        tailf:info "move secondary service flows";
        type empty;
      }
    }

    // cable rf-change-dampen-time
    leaf rf-change-dampen-time {
      tailf:info "NP RF status change dampen time";
      type uint16 {
        tailf:info "<1-65535>;;#of seconds NP RF status change must persist";
        range "1..65535";
      }
    }

    // cable resiliency
    container resiliency {
      tailf:info "Resiliency functionality";
      // cable resiliency ds-bonding
      leaf ds-bonding {
        tailf:info "Downstream resiliency bonding groups";
        type empty;
      }
    }

    // cable throttle-modem
    container throttle-modem {
      tailf:info "Manage CM initialization/registration throttling on "+
        "large systems";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf init-rate {
        tailf:info "Maximum number of modems pass the initialization "+
          "step per second";
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-1000>;;Default value is 32 CM/Sec";
          range "1..1000";
        }
      }
      leaf holdoff-time {
        tailf:info "Maximum number of seconds a modem waiting in "+
          "throttling queue";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<5-100>;;Default value is 45 Seconds";
          range "5..100";
        }
      }
      leaf flush-rate {
        tailf:info "Maximum number of modems flushing from throttling queue "+
          "once holdoff time is expired";
        type uint16 {
          tailf:info "<100-1000>;;Default value is 300 CM/Sec";
          range "100..1000";
        }
      }
    }

    // cable ds-max-burst
    container ds-max-burst {
      tailf:info "Enable maximum traffic burst";
      tailf:cli-delete-when-empty;
      presence true;
      choice optional {
        leaf burst-threshold {
          tailf:info "Threshold to enable maximum traffic burst";
          type uint32 {
            tailf:info "<64-1000000>;;Burst Threshold in Kbytes "+
              "(default = 1000)";
            range "64..1000000";
          }
          default 1000;
        }
        leaf peak-rate {
          tailf:info "Peak rate within the maximum traffic burst";
          type uint32 {
            tailf:info "<0-1000000>;;Peak Rate in Kbps (default is unshaped)";
            range "0..1000000";
          }
        }
      }
    }

    // cable acfe
    container acfe {
      tailf:info "Configure Fairness across DOCSIS interfaces";

      // cable acfe enable
      leaf enable {
        tailf:info "Enable Fairness across DOCSIS interfaces "+
          "(Adaptive CIR Fair EIR)";
        type empty;
      }

      // cable acfe period
      leaf period {
        tailf:info "Set EIR rebalance period";
        type uint8 {
          tailf:info "<5-60>;;seconds";
          range "5..60";
        }
      }
    }

    // cable l2-vpn-service xconnect nsi
    container l2-vpn-service {
      tailf:info "Use Layer-2 Tunnels for CPE traffic behind certain CMs";
      container xconnect {
        tailf:info "Tunnel traffic to L2VPN circuit";
        container nsi {
          tailf:info "Network System Interface";

          // cable l2-vpn-service xconnect nsi dot1q
          container dot1q {
            tailf:info "Tunnel traffic to DOT1Q L2VPN";
            tailf:cli-display-separated;
            presence true;
            // cable l2-vpn-service xconnect nsi dot1q interface
            container interface {
              tailf:info "Default Ethernet NSI interface";
              uses interface-name-grouping;
            }
          }

          // cable l2-vpn-service xconnect nsi mpls
          container mpls {
            tailf:info "Tunnel traffic to ATOM/MPLS PW";
            presence true;
          }
        }
      }
    }

    // cable dot1q-vc-map *
    list dot1q-vc-map {
      tailf:info "Map a CM to an Ethernet VLAN";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      container ethernet-interface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        uses interface-name-grouping;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<2-4095>;;IEEE 802.1Q VLAN ID";
          range "2..4095";
        }
      }
      leaf cust-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }
    }

    // cable l2vpn *
    list l2vpn {
      tailf:info "Cable Modem Ethernet L2VPN Service";
      tailf:cli-mode-name "config-l2vpn";
      tailf:cli-sequence-commands;
      key mac-address;
      leaf mac-address {
        type string {
          tailf:info "H.H.H;;Modem MAC address";
        }
      }
      leaf customer-name {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type string {
          tailf:info "WORD;;Customer Name";
        }
      }

      // cable l2vpn * / service instance * ethernet
      container service {
        tailf:cli-break-sequence-commands;
        tailf:info "Ethernet service";
        list instance {
          tailf:info "Ethernet service Instance";
          tailf:cli-mode-name "config-ethsrv";
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          max-elements 1;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-8000>;;Ethernet service Instance id";
            }
          }
          leaf ethernet {
            tailf:info "Service Type  - Ethernet";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type empty;
          }

          // cable l2vpn * / service instance * ethernet / encapsulation
          // encapsulation default  - READ ONLY

          // cable l2vpn * / service instance * ethernet / xconnect
          container xconnect {
            tailf:cli-break-sequence-commands;
            tailf:info "Xconnect service";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-xconn";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-hide-in-submode;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Pseudo-wire Peer IP address";
              }
            }
            leaf vcid {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<1-4294967295>;;Pseudo Wire VCID";
                range "1..4294967295";
              }
            }
            leaf encapsulation {
              tailf:info "Data encapsulation method";
              tailf:cli-hide-in-submode;
              type enumeration {
                enum mpls {
                  tailf:info "Use MPLS encapsulation";
                }
              }
            }
            leaf pw-type {
              tailf:info "MPLS Pseudo-wire Type";
              tailf:cli-optional-in-sequence;
              tailf:cli-hide-in-submode;
              type uint8 {
                tailf:info "<4-5>;;Type-5 : Ethernet Port, Type-4 : Ethernet VLAN";
                range "4..5";
              }
            }

            // cable l2vpn * / service instance * ethernet / xconnect / backup
            container backup {
              tailf:cli-break-sequence-commands;
              tailf:info "Xconnect backup configuration commands";

              // cable l2vpn * / service instance * ethernet / xconnect / backup peer *
              list peer {
                tailf:info "Backup pseudowire";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                max-elements 3;
                key "peer-router-ip-addr vcid";
                leaf peer-router-ip-addr {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address of peer";
                  }
                }
                leaf vcid {
                  type uint32 {
                    tailf:info "<1-4294967295>;;Enter VC ID value";
                    range "1..4294967295";
                  }
                }
                leaf priority {
                  tailf:info "Optional priority to use for backup pseudowire.";
                  type uint8 {
                    tailf:info "Peer priority";
                    range "1..10";
                  }
                }
              }

              // interface * / xconnect encapsulation / backup delay
              container delay {
                tailf:info "Backup delay";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf enable-delay {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-180>;;Enable delay";
                    range "0..180";
                  }
                  default 0;
                }
                leaf disable-delay {
                  tailf:cli-drop-node-name;
                  type union {
                    type uint8 {
                      tailf:info "<0-180>;;Disable delay";
                      range "0..180";
                    }
                    type enumeration {
                      enum never {
                        tailf:info "Disallow disable";
                      }
                    }
                  }
                  default 0;
                }
              }
            }
          }

          // cable l2vpn * / service instance * ethernet / cable set
          container cable {
            tailf:info "Cable Specific commands";
            container set {
              tailf:info "Set parameters";
              leaf mpls-experimental {
                tailf:info "Set MPLS Pseudo-wire Experimental bits";
                type uint8 {
                  tailf:info "<0-7>;;MPLS Experimental Bits Value";
                }
              }
            }
          }
        }
      }
    }

    // cable wideband auto-reset
    container wideband {
      tailf:info "Wideband Configuration";
      leaf auto-reset {
        tailf:info "Reset WCMs reg'd traditional-DOCSIS";
        type empty;
      }
    }

    // cable rcc-template *
    list rcc-template {
      tailf:info "Create Cable RCC-Template";
      tailf:cli-mode-name "config-rcc-template";
      key index;
      leaf index {
        type uint8 {
          tailf:info "<1-255>;;cable rcc-template id";
          range "1..255";
        }
      }

      // cable rcc-template * / rcp-id
      leaf rcp-id {
        tailf:info "Receive Channel Profile ID";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "<0x0-0xFF>;;RCP ID in hex";
        }
      }

      // cable rcc-template * / receive-module
      list receive-module {
        tailf:info "Receive Module entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-10>;;Receive Module index";
            range "1..10";
          }
        }
        leaf first-center-frequency {
          tailf:info "Module Center frequency";
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
      }

      // cable rcc-template * / receive-channel
      list receive-channel {
        tailf:info "Receive Channel entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key index;
        leaf index {
          type uint8 {
            tailf:info "<1-24>;;Receive Channel index";
            range "1..24";
          }
        }
        leaf center-frequency {
          tailf:info "Channel Center frequency";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<55000000-1050000000>;;Center Frequency - Hz";
            range "55000000..1050000000";
          }
        }
        leaf connected-receive-module {
          tailf:info "Receive Modules";
          type uint8 {
            tailf:info "<1-10>;;Connected Receive Module index";
            range "1..10";
          }
        }
        leaf primary {
          tailf:info "Receive Channel Primary indicator";
          type empty;
        }
      }
    }

    // cable video
    container video {
      tailf:info "Cable video config commands";
      presence true;
    }

    // cable fiber-node *
    list fiber-node {
      tailf:info "Create Cable fiber-node";
      tailf:cli-mode-name "config-fiber-node";
      key fiber-node-id;
      leaf fiber-node-id {
        type uint16 {
          tailf:info "<1-256>;;cable fiber-node id";
          range "1..256";
        }
      }

      // cable fiber-node * / description
      leaf "description" {
        tailf:info "Fiber node name/description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this fiber node that will be "+
            "truncated to 80 characters.";
        }
      }

      // cable fiber-node * / downstream
      container downstream {
        tailf:info "Set downstream RF channels";

        // cable fiber-node * / downstream Downstream-Cable *
        list Downstream-Cable {
          tailf:info "Downstream-Cable controller";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream Modular-Cable *
        list Modular-Cable {
          tailf:info "Modular cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream Integrated-Cable *
        list Integrated-Cable {
          tailf:info "Integrated cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / downstream sg-channel *
        list sg-channel {
          tailf:info "Associate/Remove DS-SG channels into this FN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key low;
          leaf low {
            type uint8 {
              tailf:info "<0-254>;;Low DS SG channel";
              range "0..254";
            }
          }
          leaf high {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-254>;;High DS SG channel";
              range "0..254";
            }
          }
          choice cable-choice {
            leaf downstream-Cable {
              tailf:info "Downstream-Cable controller";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf integrated-Cable {
              tailf:info "Integrated-Cable controller";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
          }
          leaf rf-channel {
            tailf:info "Associate/Remove Downstream channels into this FN";
            type uint8 {
              tailf:info "<0-162>;;Low Downstream rf-channel";
              range "0..162";
            }
          }
          leaf rf-channel-high {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-162>;;High Downstream rf-channel";
              range "1..162";
            }
          }
        }
      }

      // cable fiber-node * / upstream
      container upstream {
        tailf:info "Cable upstream channel";

        // cable fiber-node * / upstream Upstream-Cable *
        list Upstream-Cable {
          tailf:info "Upstream cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf connector {
            tailf:info "Physical upstream port connector on LC";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / upstream Cable *
        list Cable {
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf connector {
            tailf:info "Physical upstream port connector on LC";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // cable fiber-node * / upstream sg-channel
        list sg-channel {
          tailf:info "Associate/Remove US-SG channels into this FN";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key low;
          leaf low {
            type uint8 {
              tailf:info "<0-254>;;Low US SG channel";
              range "0..254";
            }
          }
          leaf high {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-254>;;High US SG channel";
              range "0..254";
            }
          }
          leaf Upstream-Cable {
            tailf:info "Upstream-Cable controller";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Controller number";
              }
          }
          leaf us-channel {
            tailf:info "Associate/Remove Upstream channels into this FN";
            type uint8 {
              tailf:info "<0-15>;;Low Upstream us-channel";
              range "0..15";
            }
          }
          leaf us-channel-high {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-15>;;High Upstream us-channel";
              range "0..15";
            }
          }
        }
      }

      // cable fiber-node * / service-group profile
      container service-group {
        tailf:info "Fiber node service group profile association";
        leaf profile {
          tailf:info "Fiber node service group profile";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "LINE;;Fiber Node(Service Group) Profile name will be truncated to 16 characters.";
          }
        }
      }
    }

    // cable rpd *
    list rpd {
      tailf:info "Create Cable RPD";
      tailf:cli-mode-name "config-rpd";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Unique RPD Name";
        }
      }

      // cable rpd * / description
      uses description-grouping;

      // cable rpd * / identifier
      leaf identifier {
        tailf:info "Identifier";
        tailf:cli-full-command;
        type string {
          tailf:info "H.H.H;;MAC Address of This RPD";
        }
      }

      // cable rpd * / core-interface Te*
      container core-interface {
        tailf:info "Core-interface configuration";
        list Te {
          tailf:info "Ten Gigabit Ethernet";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-rpd-core";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;TenGigabitEthernet interface number";
              pattern '[0-9]+.*';
            }
          }

          // cable rpd * / core-interface Te* / principal
          leaf principal {
            tailf:info "Specify the principal core";
            type empty;
          }

          // cable rpd * / core-interface Te* / rpd-ds *
          list rpd-ds {
            tailf:info "RPD DS port";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key "port downstream-cable";
            leaf port {
              tailf:info "<0-0>;;RPD DS port num";
              type uint8 {
                range "0";
              }
            }
            leaf downstream-cable {
              tailf:cli-expose-key-name;
              tailf:info "Downstream-Cable controller";
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf profile {
              tailf:info "DS controller profile";
              type uint8 {
                tailf:info "<0-255>;;Profile number";
              }
            }
          }

          // cable rpd * / core-interface Te* / rpd-us *
          list rpd-us {
            tailf:info "RPD DS port";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key "port upstream-cable";
            leaf port {
              tailf:info "<0-0>;;RPD DS port num";
              type uint8 {
                range "0";
              }
            }
            leaf upstream-cable {
              tailf:cli-expose-key-name;
              tailf:info "Upstream-Cable controller";
              type string {
                tailf:info "WORD;;Controller number";
              }
            }
            leaf profile {
              tailf:info "DS controller profile";
              type uint8 {
                tailf:info "<0-255>;;Profile number";
              }
            }
          }
        }
      }

      // cable rpd * / r-dti
      leaf r-dti {
        tailf:info "R-DTI set";
        type uint8 {
          tailf:info "<1-64>;;R-DTI configuration ID";
          range "1..64";
        }
      }

      // cable rpd * / rpd-event profile
      container rpd-event {
        tailf:info "rpd-event profile set";
        leaf profile {
          tailf:info "rpd-event profile set";
          type uint8 {
            tailf:info "<0-63>;;rpd-event profile ID";
            range "0..63";
          }
        }
      }

      // cable rpd * / ptp profile
      container ptp {
        tailf:info "PTP clock set";
        leaf profile {
          tailf:info "PTP clock profile set";
          type uint8 {
            tailf:info "<0-63>;;PTP Clock Profile ID";
            range "0..63";
          }
        }
      }
    }

    // cable ipv6
    container ipv6 {
      tailf:info "Configure CMTS-wide IPv6 commands";

      // cable ipv6 pd-route
      container pd-route {
        tailf:info "Configure PD enclosing route";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf "prefix" {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type ios:ipv6-prefix {
            tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
          }
        }
        leaf Bundle {
          tailf:info "Virtual Bundle";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint8 {
            tailf:info "<1-255>;;Bundle interface number";
            range "1..255";
          }
        }
      }

      // cable ipv6 source-verify
      container source-verify {
        tailf:info "IPv6 Source verify";
        container leasequery-filter {
          tailf:info "Source verify Lease query filter";
          container downstream {
            tailf:info "Source verify IPv6 Lease query filter for "+
              "downstream pkts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf threshold {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-255>;;Number of ipv6 lease queries "+
                  "for unknown sid";
                range "0..255";
              }
            }
            leaf interval {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-10>;;size of time window in seconds";
                range "1..10";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2tp-class
  /// ========================================================================

  // l2tp-class *
  list l2tp-class {
    tailf:info "l2tp-class configuration";
    tailf:cli-mode-name "config-l2tp-class";
    key l2tp-class-name;
    leaf l2tp-class-name {
      type string {
        tailf:info "WORD;;l2tp-class name";
      }
    }

    // l2tp-class * / authentication
    leaf authentication {
      tailf:info "Authenticate the L2TP control connection";
      tailf:cli-full-command;
      type empty;
    }

    // l2tp-class * / hello
    leaf hello {
      tailf:info "Set HELLO message interval";
      type uint16 {
        tailf:info "<0-1000>;;Seconds, default is 60";
        range "0..1000";
      }
      default 60;
    }

    // l2tp-class * / password
    container password {
      tailf:info "Password for control connection authentication, AVP hiding";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }

    // l2tp-class * / retransmit
    container retransmit {
      tailf:info "Control message retransmission parameters";

      // l2tp-class * / retransmit retries
      leaf retries {
        tailf:info "Number of retries before tearing down a control connection";
        type uint16 {
          tailf:info "<5-1000>;;Maximum retransmissions";
          range "5..1000";
        }
      }

      // l2tp-class * / retransmit timeout
      container timeout {
        tailf:info "Control packet retransmission timeout parameters";
        choice timeout-choice {
          leaf max {
            tailf:info "Maximum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
          }
          leaf min {
            tailf:info "Minimum timeout";
            type uint8 {
              tailf:info "<1-8>;;Seconds";
              range "1..8";
            }
          }
        }
      }

      // l2tp-class * / initial retransmit retries
      container initial {
        tailf:info "SCCRQ message retries/timeout settings";
        leaf retries {
          tailf:info "Number of initial retries before halting attempts";
          type uint16 {
            tailf:info "<1-1000>;;Maximum SCCRQ retransmissions";
            range "1..1000";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// packetcable
  /// ========================================================================

  container packetcable {
    tailf:info "Global packetcable configuration";
    tailf:cli-display-separated;
    presence true;

    // packetcable multimedia
    leaf multimedia {
      tailf:info "Enable Packetcable Multimedia functionality";
      type empty;
    }

    // packetcable authorize vanilla-docsis-mta
    container authorize {
      tailf:info "authorize non-packetcable settings";
      leaf vanilla-docsis-mta {
        tailf:info "vanilla docsis mta";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// depi-class
  /// ========================================================================

  // depi-class *
  list depi-class {
    tailf:info "depi-class configuration";
    tailf:cli-mode-name "config-depi-class";
    key depi-class-name;
    leaf depi-class-name {
      type string {
        tailf:info "WORD;;depi-class name";
      }
    }

    // depi-class * / mode
    container mode {
      tailf:info "Set DEPI Mode";
      leaf mpt {
        tailf:info "MPT Mode";
        type empty;
      }
    }

    // depi-class * / l2tp-class
    leaf l2tp-class {
      tailf:info "Set l2tp-class";
      tailf:non-strict-leafref {
        path "../../l2tp-class/l2tp-class-name";
      }
      type string {
        tailf:info "WORD;;depi-l2tp-class name";
      }
    }
  }


  /// ========================================================================
  /// depi-tunnel
  /// ========================================================================

  // depi-tunnel *
  list depi-tunnel {
    tailf:info "depi-tunnel configuration";
    tailf:cli-mode-name "config-depi-tunnel";
    key depi-tunnel-name;
    leaf depi-tunnel-name {
      type string {
        tailf:info "WORD;depi-tunnel name";
      }
    }

    // depi-tunnel * / dest-ip
    leaf dest-ip {
      tailf:info "Set Destination IP address of Tunnel";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;Peer IP address";
      }
    }

    // depi-tunnel * / l2tp-class
    leaf l2tp-class {
      tailf:info "Set l2tp-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;L2TP class with which this depi-tunnel is "+
          "associated";
      }
    }

    // depi-tunnel * / depi-class
    leaf depi-class {
      tailf:info "Set depi-class to associate depi tunnel with";
      type string {
        tailf:info "WORD;;depi-class with which this depi-tunnel is "+
          "associated";
      }
    }

    // depi-tunnel * / protect-tunnel
    leaf protect-tunnel {
      tailf:info "Specify protect depi-tunnel";
      type string {
        tailf:info "WORD;;protect depi-tunnel with which this depi-tunnel is "+
          "associated";
      }
    }
  }


  /// ========================================================================
  /// chat-script
  /// ========================================================================

  list chat-script {
    tailf:info "Define a modem chat script";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of chat script";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Chat script in form EXPECT SEND EXPECT SEND ...";
      }
    }
  }


  /// ========================================================================
  /// autonomic
  /// ========================================================================

  container autonomic {
    tailf:info "Autonomic Networking";
    tailf:cli-incomplete-command;
    tailf:cli-incomplete-no;

    // autonomic registrar
    container registrar {
      tailf:info "Registrar";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-registrar";

      // autonomic registrar / domain-id
      leaf domain-id {
        tailf:info "Autonomic Domain ID";
        type string {
          tailf:info "WORD;;Autonomic Domain ID in string format";
        }
      }

      // autonomic registrar / CA
      container CA {
        tailf:info "Create a Certificate Authority";
        choice CA-choice {

          // autonomic registrar / CA local
          leaf local {
            tailf:info "Create local Certificate Authority";
            type empty;
          }

          // autonomic registrar / CA url
          leaf url {
            tailf:info "url to enroll";
            type string {
              tailf:info "WORD;;HTTP URL";
            }
          }
        }
      }

      // autonomic registrar / whitelist
      leaf whitelist {
        tailf:info "File with list of whitelisted devices";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;File with list of whitelisted devices";
        }
      }

      // autonomic registrar / no shut
      leaf shut {
        tailf:info "Shut the Autonomic Registrar";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }
  }


  // autonomic
  container autonomic-enable {
    tailf:cli-drop-node-name;
    leaf autonomic {
      tailf:info "Autonomic Networking";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// controller
  /// ========================================================================

  container controller {
    tailf:info "Configure controller";

    // controller E1 *
    // controller T1 *
    // controller T3 *
    list controller-tx-ex-list {
      tailf:cli-mode-name "config-controller";
      tailf:cli-drop-node-name;
      key "name number";
      leaf name {
        type enumeration {
          tailf:info "Controller name";
          enum T1 {
            tailf:info "T1 controller";
          }
          enum E1 {
            tailf:info "E1 controller";
          }
          enum T3 {
            tailf:info "T3 controller";
          }
        }
      }
      leaf number {
        type string {
          tailf:info "WORD;;slot/subslot or port[/:]port";
        }
      }

      // controller * / framing
      leaf framing {
        tailf:info "Specify the type of Framing on a DS1 link";
        tailf:cli-full-command;
        type string;
      }

      // controller * / fdl
      leaf fdl {
        tailf:info "Specify the FDL standard for a DS1 data link";
        tailf:cli-full-command;
        type enumeration {
          enum ansi {
            tailf:info "ANSI T1.403";
          }
          enum att {
            tailf:info "AT&T TR54016";
          }
          enum both {
            tailf:info "ANSI T1.403 and AT&T TR54016";
          }
        }
      }

      // controller * / cem-group *
      list cem-group {
        tailf:info "Specify the timeslots to cem-group mapping";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;Channel number";
            range "0..30";
          }
        }

        // controller * / cem-group * unframed
        leaf unframed {
          tailf:info "Unframed in the cem group";
          type empty;
        }

        // controller * / cem-group * timeslots *
        leaf-list timeslots {
          tailf:info "List of timeslots in the cem group";
          tailf:cli-range-list-syntax;
          tailf:cli-remove-before-change;
          type uint8 {
            tailf:info "<1-31>;List of timeslots which comprise the channel";
            range "1..31";
          }
        }
      }

      // controller * / clock
      container clock {
        tailf:info "Specify the clock source for a DS1 link";

        // controller * / clock source
        container source {
          tailf:info "Specify the clock source for a DS1 link";
          choice source-choice {
            container line {
              tailf:info "Recovered Clock";
              tailf:cli-delete-when-empty;
              presence true;
              leaf line-mode {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type enumeration {
                  enum primary {
                    tailf:info "Primary Source";
                  }
                  enum secondary {
                  }
                  enum bits {
                    tailf:info "Bits Clocking";
                  }
                  enum independent {
                    tailf:info "Independent Source";
                  }
                }
              }
            }
            leaf internal {
              tailf:info "Internal Clock";
              tailf:cli-full-command;
              type empty;
            }
            leaf loop-timed {
              tailf:cli-full-command;
              type empty;
            }
            leaf free-running {
              tailf:info "Free Running Clock";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // controller * / linecode
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
          enum hdb3 { // E1 only (default)
          }
        }
      }

      // controller * / cablelength
      container cablelength {
        tailf:info "Specify the cable length for a DS1 link";
        choice cablelength-choice {
          leaf "value" {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32;
          }
          leaf long {
            tailf:info "long cable";
            tailf:cli-full-command;
            type string;
          }
          leaf short {
            tailf:info "short cable";
            tailf:cli-full-command;
            type string;
          }
        }
      }

      // controller * / pri-group
      container pri-group {
        tailf:info "Configure the specified timeslots for PRI";
        list timeslots {
          tailf:info "List of timeslots in the pri-group";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type uint8;
          }
          leaf nfas_d {
            tailf:info "Specify the operation of the D-channel timeslot.";
            type enumeration {
              enum primary {}
              enum backup {}
              enum none {}
            }
          }
          leaf nfas_int {
            when "../nfas_d" {
              tailf:dependency "../nfas_d";
            }
            tailf:info "Specify the provisioned NFAS interface value.";
            type uint32 {
              tailf:info "<0-48>;;The NFAS interface value.";
            }
          }
          leaf nfas_group {
            when "../nfas_int" {
              tailf:dependency "../nfas_int";
            }
            tailf:info "Specify the NFAS group.";
            type uint8 {
              range "1..24";
            }
          }
          leaf service {
            tailf:info "Specify the service type";
            type enumeration {
              enum mgcp {
                tailf:info "Media Gateway Control Protocol service";
              }
            }
          }
        }
      }

      // controller * / channel-group
      list channel-group {
        tailf:info "Specify the timeslots to channel-group "+
          "mapping for an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key number;
        leaf number {
          type uint8 {
            range "0..30";
          }
        }
        leaf-list timeslots {
          tailf:info "List of timeslots in the channel group";
          tailf:cli-replace-all;
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "<1-31>;;List of timeslots which comprise the channel";
          }
        }
      }

      // controller * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
        }
      }

      // controller * / t1 *
      list t1 {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint8;
        }
        leaf channel-group {
          type uint8 {
            range "0..23";
          }
        }
        leaf-list timeslots {
          tailf:cli-range-list-syntax;
          type uint8 {
            range "1..24";
          }
        }
        leaf speed {
          type enumeration {
            enum "56" {}
            enum "64" {}
          }
        }
        container clock {
          leaf source {
            type enumeration {
              enum line {
                tailf:info "Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
            }
          }
        }
      }

      // controller * / ima-group
      container ima-group {
        tailf:info "Configure IMA group";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf group-number {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-41>;;IMA group ID";
            range "0..41";
          }
        }
        leaf scrambling-payload {
          type empty;
        }
      }

      // controller * / shutdown
      leaf shutdown {
        tailf:info "Shut down a DS1 link (send Blue Alarm)";
        type empty;
      }
    }

    // controller BITS input applique
    container BITS {
      tailf:info "Configure BITS Interface";
      container "input" {
        tailf:info "Configure BITS input";
        container applique  {
          tailf:info "Link type E1 or T1";
          container E1 {
            tailf:info "E1;;Link type E1";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            choice E1-choice {
              case clock-case {
                leaf clock-if {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "2048KHz" {
                      tailf:info "2048 KHz clock interface";
                    }
                  }
                }
              }
              case framing-case {
                leaf framing {
                  tailf:info "BITS framing options for E1";
                  tailf:cli-incomplete-command;
                  type enumeration {
                    enum fas_crc4 {
                      tailf:info "FASCRC4";
                    }
                    enum fas_nocrc {
                      tailf:info "FAS";
                    }
                    enum mfas_crc4 {
                      tailf:info "MFASCRC4";
                    }
                    enum mfas_nocrc {
                      tailf:info "MFAS";
                    }
                  }
                }
                leaf linecode {
                  tailf:info "BITS linecode options for E1";
                  type enumeration {
                    enum ami {
                      tailf:info "AMI encoding";
                    }
                    enum hdb3 {
                      tailf:info "HDB3 encoding";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // controller Cellular *
    list Cellular {
      tailf:info "3G/4G WWAN Cellular controller";
      tailf:cli-mode-name "config-controller";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Controller slot/subslot or port number";
          pattern '[0-9]+.*';
        }
      }

      // controller Cellular * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
          length "1..80";
        }
      }

      // controller Cellular * / lte gps nmea
      container lte {
        tailf:info "LTE type carrier";

        // controller Cellular * / lte gps
        container gps {
          tailf:info "GPS configuration";

          // controller Cellular * / lte gps enable
          leaf enable {
            tailf:info "enable GPS feature";
            type empty;
          }

          // controller Cellular * / lte gps mode
          container mode {
            tailf:info "select GPS mode";
            leaf standalone {
              tailf:info "select Standalone mode";
              type empty;
            }
          }

          // controller Cellular * / lte gps nmea
          container nmea {
            tailf:info "enable NMEA data";
            choice nmea-choice {
              container ip {
                tailf:info "NMEA over IP interface";
                presence true;
              }
              container serial {
                tailf:info "NMEA over serial interface";
                presence true;
                leaf streaming {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum "38400" {
                      tailf:info "38400 bps, 8 databits, No parity, 1 stopbit";
                    }
                    enum "4800" {
                      tailf:info "4800 bps, 8 databits, No parity, 1 stopbit "+
                        "(default)";
                    }
                    enum line-config {
                      tailf:info "Use tty line configuration";
                    }
                  }
                }
              }
            }
          }
        }

        // controller Cellular * / lte modem
        container modem {
          tailf:info "Modem logging configuration";
          container link-recovery {
            tailf:info "Cellular Link Recovery";
            leaf enable {
              type empty;
            }
            container rssi {
              tailf:info "RSSI Onset Threshold value";
              leaf onset-threshold {
                tailf:info "RSSI Onset Threshold";
                type int8 {
                  tailf:info "<-125 - -90>;;RSSI value in -dbm";
                  range "-125..-90";
                }
              }
            }
            leaf monitor-timer {
              tailf:info "Monitor Timer";
              type uint8 {
                tailf:info "<20 - 60>;;Monitor Timer value in seconds";
                range "20..60";
              }
            }
            leaf wait-timer {
              tailf:info "Wait Timer";
              type uint8 {
                tailf:info "<5 - 60>;;Wait Timer value in seconds";
                range "5..60";
              }
            }
            leaf debounce-count {
              tailf:info "Debounce Count";
              type uint8 {
                tailf:info "<6 - 20>;;Debounce Count value";
                range "6..20";
              }
            }
          }
        }
      }
    }

    // controller VDSL *
    list VDSL {
      tailf:info "VDSL2 controller";
      tailf:cli-mode-name "config-controller";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Controller slot/subslot or port number";
          pattern '[0-9]+.*';
        }
      }

      // controller VDSL * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this interface";
          length "1..80";
        }
      }
    }

    // controller Upstream-Cable *
    list Upstream-Cable {
      tailf:info "Upstream-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Upstream-Cable * / description
      uses description-grouping;

      // controller Upstream-Cable * / us-channel *
      uses us-channel-grouping;
    }

    // controller Downstream-Cable *
    list Downstream-Cable {
      tailf:info "Downstream-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Downstream-Cable * / description
      uses description-grouping;
    }

    // controller Modular-Cable *
    list Modular-Cable {
      tailf:info "Modular-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Modular-Cable * / description
      uses description-grouping;

      // controller Modular-Cable * / ip-address
      leaf ip-address {
        tailf:info "Configure IP address";
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP address of Blaze";
        }
      }

      // controller Modular-Cable * / modular-host subslot
      container modular-host {
        tailf:info "Configure modular host";
        leaf subslot {
          tailf:info "Configure slot";
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;slot/subslot";
          }
        }
      }

      // controller Modular-Cable * / rf-channel *
      uses controller-modular-cable-rf-channel-grouping;
    }

    // controller Integrated-Cable *
    list Integrated-Cable {
      tailf:info "Integrated-Cable controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller Integrated-Cable * / description
      uses description-grouping;

      // controller Integrated-Cable * / max-carrier
      leaf max-carrier {
        tailf:info "Max Carrier of a RF Port";
        type uint8 {
          tailf:info "<1-128>;;RF Port Max Carrier Value";
          range "1..128";
        }
      }

      // controller Integrated-Cable * / base-channel-power
      leaf base-channel-power {
        tailf:info "set base channel power level";
        type uint8 {
          tailf:info "<28-39>;;Base Channel Power Value in dBmV";
        }
      }

      // controller Integrated-Cable * / freq-profile
      leaf freq-profile {
        tailf:info "Frequency Profile of a RF Port";
        type uint8 {
          tailf:info "<0-15>;;RF Port Frequency Profile Number";
          range "0..15";
        }
      }

      // controller Integreated-Cable * / rf-chan
      container rf-chan {
        tailf:info "Configure RF Channel";

        // controller Integreated-Cable * / rf-chan *
        list rf-chan {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-rf-chan";
          key start;
          leaf start {
            type uint8 {
              tailf:info "<0-127>;;Starting Qam ID";
            }
          }
          uses controller-integrated-cable-rf-chan-grouping;
        }

        // controller Integreated-Cable * / rf-chan * *
        list rf-chan-range {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-rf-chan";
          key "start end";
          leaf start {
            type uint8 {
              tailf:info "<0-127>;;Starting Qam ID";
            }
          }
          leaf end {
            type uint8 {
              tailf:info "<0-127>;;Ending Qam ID";
            }
          }
          uses controller-integrated-cable-rf-chan-grouping;
        }
      }
    }

    // controller wanphy *
    list wanphy {
      tailf:info "WANPHY controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }
    }

    // controller dwdm *
    list dwdm {
      tailf:info "DWDM controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot";
        }
      }
      // controller dwdm * / shutdown
      leaf shutdown {
        tailf:info "Shut down the controller";
        type empty;
      }
    }

    // controller SONET *
    list SONET {
      tailf:info "Channelized SONET/SDH controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot/unit";
        }
      }

      // controller SONET * / description
      leaf "description" {
        tailf:info "Controller specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 240 characters describing this controller";
          length "1..240";
        }
      }

      // controller SONET * / shutdown
      leaf shutdown {
        tailf:info "Shut down the Sonet/SDH controller";
        type empty;
      }

      // controller SONET * / rate
      leaf rate {
        tailf:info "Set the SONET/SDH rates";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type string {
          tailf:info "OC<X>;;Set the controller to OC<X> rate";
          pattern "OC.*";
        }
      }

      // controller SONET * / ais-shut
      // controller SONET * / no ais-shut
      leaf ais-shut {
        tailf:info "Send LAIS when shutdown";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // controller SONET * / no TU-AIS
      leaf TU-AIS {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // controller SONET * / alarm-report
      leaf alarm-report {
        tailf:info "Enable reporting of selected alarms";
        type enumeration {
          enum "all" {
            tailf:info "All alarm reports";
          }
          // Note, skipping the other options, since no other except
          // "all" is displayed by the device
        }
      }

      // controller SONET * / threshold
      container threshold {
        tailf:info "Set BER threshold values";

        // controller SONET * / threshold sf-ber
        leaf sf-ber {
          tailf:info "set Signal Fail BER threshold";
          type uint8 {
            tailf:info "<3-5>;;Bit error rate (10 to the minus n)";
            range "3..5";
          }
        }
      }

      // controller SONET * / framing
      leaf framing {
        tailf:info "Configure to use in Sonet or SDH mode";
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
            tailf:info "Use SDH Framing";
          }
          enum sonet {
            tailf:info "Use Sonet Framing";
          }
        }
      }

      // controller SONET * / clock source
      container clock {
        tailf:info "Specify the clock source for Sonet/SDH port";
        leaf source {
          tailf:info "Specify the clock source for Sonet/SDH port";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Recovered Clock";
            }
            enum internal {
              tailf:info "Internal Clock";
            }
          }
        }
      }

      // controller SONET * / aug mapping
      container aug {
        tailf:info "Specify AU-3 or AU-4 mapping";
        leaf mapping {
          tailf:info "Specify AU-3 or AU-4 mapping";
          type enumeration {
            enum au-3 {
              tailf:info "AU-3";
            }
            enum au-4 {
              tailf:info "AU-4 (default)";
            }
          }
        }
      }

      // controller SONET * / overhead
      container overhead {
        tailf:info "Specify overhead settings";

        // controller SONET * / overhead j0
        leaf j0 {
          tailf:info "Set the j0 trace byte";
          type uint8 {
            tailf:info "<0-255>;;j0 trace byte";
          }
        }
      }

      // controller SONET * / au-3 *
      list au-3 {
        tailf:info "Specify au-3 number";
        tailf:cli-mode-name "config-ctrlr-au3";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-3>;;au-3 number";
            range "1..3";
          }
        }

        // controller SONET * / au-3 * / overhead
        container overhead {
          tailf:info "Configure sonet path overhead flags";
          container j1 {
            tailf:info "Path trace buffer config";
            tailf:cli-compact-syntax;
            leaf "length" {
              tailf:info "Path trace buffer length (16 or 64 bytes)";
              type enumeration {
                enum "16" {
                  tailf:info "Path trace buffer length, 16 bytes";
                }
                enum "64" {
                  tailf:info "Path trace buffer length, 64 bytes";
                }
              }
            }
          }
        }

        // controller SONET * / au-3 * / mode
        leaf mode {
          tailf:info "Specify path operation mode";
          tailf:cli-full-command;
          type enumeration {
            enum c-11 {
              tailf:info "Mode C-11";
            }
          }
        }

        // controller SONET * / au-3 * / tug-2 * t1 *
        list tug-2 {
          tailf:info "Tug-2 configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "tug-2 t1";
          leaf tug-2 {
            type uint8 {
              tailf:info "<1-7>;;Tug-2 number <1-7>";
              range "1..7";
            }
          }
          leaf t1 {
            tailf:info "T1 line configuration";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<1-3>;;E1 line number <1-4>";
              range "1..4";
            }
          }

          // controller SONET * / au-3 * / tug-2 * t1 * clock source
          container clock {
            tailf:info "Specify the clock source for a T1";
            leaf source {
              tailf:info "Specify the clock source for a T1";
              tailf:cli-full-command;
              type enumeration {
                enum line {
                  tailf:info "Line Recovered Clock";
                }
                enum internal {
                  tailf:info "Internal Clock";
                }
              }
            }
          }
        }
      }

      // controller SONET * / au-4 *
      list au-4 {
        tailf:info "Specify AU-4 number and TUG-3 number";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-4>;;au-4 number";
            range "1..4";
          }
        }

        // controller SONET * / au-4 * threshold b3-tca
        container threshold {
          tailf:info "Set Path BER threshold values";
          leaf b3-tca {
            tailf:info "B3 BER threshold crossing alarm";
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n)";
              range "3..9";
            }
          }
        }

        // controller SONET * / au-4 * tug-3 *
        list tug-3 {
          tailf:info "TUG-3 number";
          tailf:cli-mode-name "config-ctrlr-tug3";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug-3 number <1..3>";
              range "1..3";
            }
          }

          // controller SONET * / au-4 * tug-3 * / mode
          leaf mode {
            tailf:info "Specify path operation mode";
            tailf:cli-full-command;
            type enumeration {
              enum c-12 {
                tailf:info "Mode C-12";
              }
            }
          }

          // controller SONET * / au-4 * tug-3 * / tug-2 *
          list tug-2 {
            tailf:info "Tug-2 configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key "tug-2 e1";
            leaf tug-2 {
              type uint8 {
                tailf:info "<1-7>;;Tug-2 number <1-7>";
                range "1..7";
              }
            }
            leaf e1 {
              tailf:info "E1 line configuration";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-3>;;E1 line number <1-3>";
                range "1..3";
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * ima-group
            container ima-group {
              tailf:info "Configure IMA group";
              leaf group-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-41>;;IMA group ID";
                  range "0..41";
                }
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * channel-group *
            list channel-group {
              tailf:info "Specify the timeslots to channel-group mapping for an E1 interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-30>;;Channel group number";
                  range "0..30";
                }
              }

              // controller SONET * / au-4 * tug-3 * / tug-2 * channel-group * timeslots
              leaf-list timeslots {
                tailf:info "List of timeslots in the channel group";
                tailf:cli-replace-all;
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "<1-31>;;List of timeslots which comprise the channel";
                  range "1..31";
                }
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * cem-group *
            list cem-group {
              tailf:info "Specify the timeslots to cem-group mapping";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-64>;;Channel number";
                  range "0..64";
                }
              }

              // controller SONET * / au-4 * tug-3 * /
              // .. tug-2 * cem-group * unframed
              leaf unframed {
                tailf:info "Unframed in the cem group";
                tailf:cli-full-command;
                type empty;
              }

              // controller SONET * / au-4 * tug-3 * /
              // .. tug-2 * cem-group * timeslots
              leaf-list timeslots {
                tailf:info "List of timeslots in the cem group";
                tailf:cli-range-list-syntax;
                tailf:cli-remove-before-change;
                tailf:cli-full-command;
                type uint8 {
                  tailf:info "<1-31>;List of timeslots which comprise "+
                    "the channel";
                  range "1..31";
                }
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * framing
            leaf framing {
              tailf:info "Specify the type of Framing on an E1 line";
              type enumeration {
                enum crc4 {
                  tailf:info "E1 with CRC";
                }
                enum no-crc4 {
                  tailf:info "E1 with no CRC";
                }
                enum unframed {
                  tailf:info "No Framing Format";
                }
              }
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * unframed
            leaf unframed {
              tailf:info "Unframed E1";
              type empty;
            }

            // controller SONET * / au-4 * tug-3 * / tug-2 * clock source
            container clock {
              tailf:info "Specify the clock source for Sonet/SDH port";
              leaf source {
                tailf:info "Specify the clock source for Sonet/SDH port";
                tailf:cli-full-command;
                type enumeration {
                  enum line {
                    tailf:info "Recovered Clock";
                  }
                  enum internal {
                    tailf:info "Internal Clock";
                  }
                }
              }
            }
          }
        }
      }

      // controller SONET * / sts-1 * mode sts-3c
      container sts-3c {
        tailf:cli-drop-node-name;
        list sts-1 {
          tailf:info "Specify STS-1 number";
          tailf:cli-mode-name "config-ctrlr-sts3c";
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type string {
              tailf:info "<sts-1 start> - <sts-1 end>";
            }
          }
          leaf mode {
            tailf:info "mode to configure sts-3c";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum sts-3c {
                tailf:info "to assign set of sts as sts-3c";
              }
            }
          }

          // controller SONET * / sts-1 * mode sts-3c / cem-group ? cep
          container cem-group {
            tailf:info "Specify the timeslots to cem-group mapping";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf id {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-5375>;;Channel number";
                range "0..5375";
              }
            }
            leaf cep {
              tailf:info "cep configuration";
              type empty;
            }
          }

          // controller SONET * / sts-1 * mode sts-3c / clock source
          container clock {
            tailf:info "Specify the clock source for a PATH";
            leaf source {
              tailf:info "Specify the clock source for a PATH";
              type enumeration {
                enum line {
                  tailf:info "Line Recovered Clock";
                }
                enum internal {
                  tailf:info "Internal Clock";
                }
                enum recovered {
                  tailf:info "packet recovered Clock";
                }
                enum enhanced {
                  tailf:info "enhanced Clock";
                }
              }
            }
          }
        }
      }

      // controller SONET * / sts-1 *
      list sts-1 {
        tailf:info "Specify STS-1 number";
        tailf:cli-mode-name "config-ctrlr-sts1";
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-12>;;sts-1 number";
            range "1..12";
          }
        }

        // controller SONET * / sts-1 * / clock source
        container clock {
          tailf:info "Specify the clock source for a PATH";
          leaf source {
            tailf:info "Specify the clock source for a PATH";
            type enumeration {
              enum line {
                tailf:info "Line Recovered Clock";
              }
              enum internal {
                tailf:info "Internal Clock";
              }
              enum recovered {
                tailf:info "packet recovered Clock";
              }
              enum enhanced {
                tailf:info "enhanced Clock";
              }
            }
          }
        }

        // controller SONET * / sts-1 * / cem-group
        container cem-group {
          tailf:info "Specify the timeslots to cem-group mapping";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          when "../mode/t3" {
            tailf:dependency "../mode/t3";
          }
          leaf id {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../mode/t3";
            type uint16 {
              tailf:info "<0-5375>;;Channel number";
              range "0..5375";
            }
          }
          leaf unframed {
            tailf:info "Unframed in the cem group";
            type empty;
          }
        }

        // controller SONET * / sts-1 * / t3
        container t3 {
          tailf:info "t3 configuration";
          when "../mode/t3" {
            tailf:dependency "../mode/t3";
          }
          tailf:cli-diff-dependency "../mode/t3";

          // controller SONET * / sts-1 * / t3 framing
          // note: Not modelled, can't be modified(?)

          // controller SONET * / sts-1 * / t3 clock source
          container clock {
            tailf:info "Specify the clock source for a T3 link";
            leaf source {
              tailf:info "Specify the clock source for a T3 link";
              type enumeration {
                enum line {
                  tailf:info "Line Recovered Clock";
                }
                enum internal {
                  tailf:info "Internal Clock";
                }
                enum recovered {
                  tailf:info "Recovered Clock";
                }
              }
            }
          }
        }

        // controller SONET * / sts-1 * / vtg
        container vtg {
          tailf:info "vt-15 configuration";
          when "../mode/vt-15" {
            tailf:dependency "../mode/vt-15";
          }
          tailf:cli-diff-dependency "../mode/vt-15";
        }

        // controller SONET * / sts-1 * / mode
        container mode {
          tailf:info "Specify path operation mode";
          choice mode-choice {
            leaf ct3 {
              tailf:info "Mode CT3";
              type empty;
            }
            leaf ct3-e1 {
              tailf:info "Mode CT3-E1";
              type empty;
            }
            leaf t3 {
              tailf:info "Mode T3";
              type empty;
            }
            leaf unframed {
              tailf:info "Mode UNFRAMED";
              type empty;
            }
            leaf vt-15 {
              tailf:info "Mode VT-15";
              type empty;
            }
            leaf vt-2 {
              tailf:info "MODE VT-2";
              type empty;
            }
          }
        }
      }
    }

    // controller ISA *
    list ISA {
      tailf:info "ISA controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }
    }

    // controller nid *
    list nid {
      tailf:info "NID controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }
    }

    // controller MediaType *
    list MediaType {
      tailf:info "Generic MediaType Controller";
      tailf:cli-mode-name "config-controller";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Controller slot/subslot[/unit]";
        }
      }

      // controller MediaType * / description
      uses description-grouping;

      // controller MediaType * / mode
      leaf mode {
        tailf:info "MediaType mode";
        tailf:cli-full-command;
        type enumeration {
          enum ethernet {
            tailf:info "Ethernet";
          }
          enum sonet {
            tailf:info "Sonet / SDH";
          }
          enum t3 {
            tailf:info "T3";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vc-class
  /// ========================================================================

  container vc-class {
    tailf:info "Configure per VC parameters";

    // vc-class atm *
    list atm {
      tailf:info "Asynchronous transfer mode";
      tailf:cli-mode-name "config-vc-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VC-Class name";
        }
      }

      // vc-class atm * / vbr-nrt
      container vbr-nrt {
        tailf:info "Enter Variable Bit Rate (pcr)(scr)(bcs)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf pcr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<16-4608>;;Peak Cell Rate(PCR) in Kbps";
            range "16..4608";
          }
        }
        leaf scr {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<16-PCR>;;Sustainable Cell Rate(SCR) in Kbps";
            range "16..4608";
          }
        }
        leaf mbs {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-64000>;;Maximum Burst Size(MBS) in Cells";
            range "1..64000";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// fhrp
  /// ========================================================================

  container fhrp {
    tailf:info "Configure First Hop Redundancy Protocols";

    // fhrp version vrrp
    container version {
      tailf:info "Configure which FHRP version is allowed to run";
      leaf vrrp {
        tailf:info "Configure Virtual Router Rendundancy Protocol";
        type enumeration {
          enum v2 {
            tailf:info "Legacy VRRP - VRRPv2 for IPv4";
          }
          enum v3 {
            tailf:info "Unified VRRP - VRRPv3 for IPv4 and IPv6";
          }
        }
        default v2;
      }
    }
  }


  /// ========================================================================
  /// ip
  /// ========================================================================

  container ip {
    tailf:info "Global IP configuration subcommands";

    // no ip subnet-zero
    leaf subnet-zero {
      tailf:info "Allow 'subnet zero' subnets";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip source-route
    // no ip source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-show-with-default;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // no ip routing
    leaf routing {
      tailf:info "Enable IP routing";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      // dep: before this is created, change router
      tailf:cli-diff-dependency "../../router" {
        tailf:cli-trigger-on-set;
      }
      type boolean;
      default true;
    }

    // no ip routing protocol purge interface
    container routing-conf {
      tailf:cli-drop-node-name;
      container routing {
        tailf:info "Enable IP routing";
        container protocol {
          tailf:info "IP routing protocol";
          container purge {
            tailf:info "routes purge";
            leaf interface {
              tailf:info "Perform IP routing protocol routes purge on link failures";
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
      }
    }

    // ip options
    container options {
      tailf:info "IP Options treatment";

      // ip options drop
      leaf drop {
        tailf:info "Drop all IP options packets";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip auth-proxy
    container auth-proxy {
      tailf:info "Authentication Proxy";

      // ip auth-proxy max-login-attempts
      leaf max-login-attempts {
        tailf:info "Max Login failures per user";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of login failures (retries)";
          range "1..2147483647";
        }
      }

      // ip auth-proxy max-nodata-conns
      leaf max-nodata-conns {
        tailf:info "Max TCP NODATA Connections";
        type uint16 {
          tailf:info "<1-1000>;;Number of TCP NODATA";
          range "1..1000";
        }
        default 3;
      }
    }

    // ip admission
    container admission {
      tailf:info "Network Admission Control (NAC)";

      // ip admission max-login-attempts
      leaf max-login-attempts {
        tailf:info "Max Login failures per user";
        type uint32 {
          tailf:info "<1-2147483647>;;Number of login failures (retries)";
          range "1..2147483647";
        }
      }

      // ip admission max-nodata-conns
      leaf max-nodata-conns {
        tailf:info "Max TCP NODATA Connections";
        type uint16 {
          tailf:info "<1-1000>;;Number of TCP NODATA";
          range "1..1000";
        }
      }
    }

    // ip arp
    container arp {
      tailf:info "IP ARP global configuration";

      // ip arp proxy disable
      container proxy {
        tailf:info "Global proxy ARP configuration";
        leaf disable {
          tailf:info "Disable proxy ARP on all interfaces";
          tailf:cli-full-command;
          type empty;
        }
      }

      // ip arp inspection
      container inspection {
        tailf:info "Arp Inspection configuration";

        // ip arp inspection bridge-domain
        leaf-list bridge-domain {
          tailf:info "Enable/Disable ARP Inspection on bridge-domains";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip arp inspection bridge-domain * logging
        container bridge-domain-list {
          tailf:cli-drop-node-name;
          list bridge-domain {
            tailf:info "Enable/Disable ARP Inspection on bridge-domains";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint16 {
                tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
                range "1..4094";
              }
            }
            container logging {
              tailf:cli-flatten-container;
              choice logging-choice {
                // ip arp inspection bridge-domain * logging acl-match
                leaf acl-match {
                  tailf:info "Logging of packets that match ACLs";
                  type enumeration {
                    enum matchlog {
                      tailf:info "Log packets on ACE logging configuration";
                    }
                    enum none {
                      tailf:info "Do not log packets that match ACLs";
                    }
                  }
                }
                // ip arp inspection bridge-domain * logging dhcp-bindings
                leaf dhcp-bindings {
                  tailf:info "Logging of packet that match DHCP bindings";
                  type enumeration {
                    enum all {
                      tailf:info "Log all packets that match DHCP bindings";
                    }
                    enum none {
                      tailf:info "Do not log packets that match DHCP bindings";
                    }
                    enum permit {
                      tailf:info "Log DHCP Binding Permitted packets";
                    }
                  }
                }
              }
            }
          }
        }

        // ip arp inspection validate
        leaf-list validate {
          tailf:info "Validate addresses";
          tailf:cli-flat-list-syntax {
            tailf:cli-replace-all;
          }
          type enumeration {
            enum src-mac {
              tailf:info "Validate source MAC address";
            }
            enum dst-mac {
              tailf:info "Validate destination MAC address";
            }
            enum ip {
              tailf:info "Validate IP addresses";
            }
          }
        }

        // ip arp inspection log-buffer
        container log-buffer {
          tailf:info "Log Buffer Configuration";
          // ip arp inspection log-buffer entries
          leaf entries {
            tailf:info "Number of entries for log buffer";
            type uint16 {
              tailf:info "<0-1024>;;Number of entries for log buffer";
              range "0..1024";
            }
          }
          // ip arp inspection log-buffer logs interval
          container logs {
            tailf:info "Number of logs per interval";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<0-1024>;;Number of entries";
                range "0..1024";
              }
            }
            leaf interval {
              tailf:info "Interval for controlling logging rate";
              type uint32 {
                tailf:info "<0-86400>;;Interval (seconds)";
              }
            }
          }
        }

        // ip arp inspection vlan
        leaf-list vlan {
          tailf:info "Enable/Disable ARP Inspection on vlans";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
          }
        }

        // ip arp inspection filter *
        list filter {
          tailf:info "Specify ARP acl to be applied";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ARP acl name";
            }
          }
          leaf-list vlan {
            tailf:info "Vlans to apply the filter";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
              range "1..4094";
            }
          }
        }
      }
    }

    // ip gratuitous-arps
    choice gratuitous-arps-choice {
      // ip gratuitous-arps
      // no ip gratuitous-arps
      container gratuitous-arps-conf {
        tailf:cli-drop-node-name;
        leaf gratuitous-arps {
          tailf:info "Generate gratuitous ARPs for PPP/SLIP peer addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
        }
      }
      container gratuitous-arps {
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        // no ip gratuitous-arps non-local
        leaf non-local {
          tailf:info "Send only non-local PPP/SLIP gratuitous ARPs (default)";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
      default gratuitous-arps;
    }

    // ip cef
    // no ip cef
    container cef-conf {
      tailf:cli-drop-node-name;
      leaf cef {
        tailf:info "Cisco Express Forwarding";
        tailf:cli-show-no;
        type empty;
      }
    }

    // ip cef X
    container cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../cef-conf/cef";

      // ip cef distributed
      leaf distributed {
        tailf:info "Distributed Cisco Express Forwarding";
        tailf:cli-full-command;
        type empty;
      }

      // no ip cef optimize neighbor resolution
      container optimize {
        tailf:info "Optimizations";
        container neighbor {
          tailf:info "Optimizations for directly connected neighbors";
          leaf resolution {
            tailf:info "Trigger layer 2 address resolution directly from CEF";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // ip cef load-sharing algorithm
      container load-sharing {
        tailf:info "Load sharing";
        container algorithm {
          tailf:info "Per-destination load sharing algorithm selection";
          choice algorithm-choice {
            default universal;

            // ip cef load-sharing algorithm original
            leaf original {
              tailf:info "Original algorithm";
              type empty;
            }

            // ip cef load-sharing algorithm universal
            container universal {
              tailf:info "Algorithm for use in most environments";
              tailf:cli-delete-when-empty;
              presence true;
              leaf id {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "<1-FFFFFFFF>;;Fixed ID";
                }
              }
            }
          }
        }
      }
    }

    // ip vrf *
    list vrf {
      tailf:info "Configure an IP VPN Routing/Forwarding instance";
      tailf:cli-mode-name "config-vrf";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // ip vrf * / description
      leaf "description" {
        tailf:info "VRF specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 244 characters describing this VRF";
          length "1..244";
        }
      }

      // ip vrf * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-full-command;
        tailf:cli-remove-before-change;
        type rd-type;
      }

      // ip vrf * / vpn
      container vpn {
        tailf:info "Configure VPN ID as specified in rfc2685";
        leaf id {
          tailf:info "Configure VPN ID in rfc2685 format";
          type vpn-id-type;
        }
      }

      // ip vrf * / context
      leaf context {
        tailf:info "Associate SNMP context with this vrf";
        type string {
          tailf:info "WORD;;SNMP Context Name";
        }
      }

      // ip vrf * / import
      container "import" {
        tailf:info "VRF import";

        // ip vrf * / import map
        leaf map {
          tailf:info "Route-map based VRF import";
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../ipv4" {
            tailf:cli-trigger-on-set;
          }
          type string {
            tailf:info "WORD;;VRF import route-map name";
          }
        }

        // ip vrf * / import ipv4
        container ipv4 {
          tailf:info "Address family based VRF import";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-diff-dependency "../map" {
            tailf:cli-trigger-on-set;
          }
          leaf ipv4-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum unicast {
                tailf:info "Import prefixes from IPv4 Unicast table";
              }
              enum multicast {
                tailf:info "Import prefixes from IPv4 Multicast table";
              }
            }
          }
          leaf upper-limit {
            tailf:cli-break-sequence-commands;
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Upper limit on import prefixes "+
                "without hogging memory";
              range "1..2147483647";
            }
          }
          leaf map {
            tailf:info "Route-map based VRF import";
            type string {
              tailf:info "WORD;;VRF import route-map name";
            }
          }
        }
      }

      // ip vrf * / export
      container export {
        tailf:info "VRF export";
        leaf map {
          tailf:info "Route-map based VRF export";
          type string {
            tailf:info "WORD;;VRF export route-map name";
          }
        }
      }

      // ip vrf * / maximum
      container maximum {
        tailf:info "Set a limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        presence true;
        leaf routes {
          tailf:info "Maximum number of routes allowed in this routing table";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of routes allowed";
            range "1..4294967295";
          }
        }
        choice maximum-choice {
          case threshold-case {
            leaf threshold {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
                range "1..100";
              }
            }
            leaf reinstall {
              tailf:info "Reinstall previous rejected route due to over maximum route limit";
              type uint16 {
                tailf:info "<1-100>;;Threshold value (%) at which to reinstall routes back to VRF";
                range "1..100";
              }
            }
          }
          case warning-case {
            leaf warning-only {
              tailf:info "Only give a warning message if is limit exceeded";
              type empty;
            }
          }
        }
      }

      // ip vrf * / bgp next-hop Loopback
      container bgp {
        tailf:info "Commands pertaining to BGP";
        container next-hop {
          tailf:info "Next-hop for the routes of a VRF in the backbone";
          leaf Loopback {
            tailf:info "Loopback interface number";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Loopback interface number";
              range "0..2147483647";
            }
          }
        }
      }

      // ip vrf * / mdt
      container mdt {
        tailf:info "Backbone Multicast Distribution Tree";
        tailf:cli-incomplete-command;
        presence "Backbone Multicast Distribution Tree";
        leaf "default" {
          tailf:info "The default group";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP multicast group address";
          }
        }
        container data {
          tailf:info "MDT data group range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          leaf mulicast-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP multicast group address";
            }
          }
          leaf wildcard-bits {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Wildcard bits";
            }
          }
          choice mdt-data-choice {
            case mdt-data-threshold {
              leaf threshold {
                tailf:info "MDT switching threshold";
                type uint32 {
                  tailf:info "<1-4294967>;;Traffic rate in "
                    +"kilobits per second";
                  range "1..4294967";
                }
              }
              leaf threshold-list {
                tailf:info "Access-list";
                tailf:alt-name "list";
                type ext-acl-type;
              }
            }
            case mdt-data-list {
              leaf "list" {
                tailf:info "Access-list";
                type ext-acl-type;
              }
            }
          }
        }
        leaf log-reuse {
          tailf:info "Event logging for data MDT reuse";
          type empty;
        }
      }

      // ip vrf * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }
    }

    // ip dhcp-server
    container dhcp-server {
      tailf:info "Specify target DHCP server parameters";

      // ip dhcp-server *
      list dhcp-server-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key server;
        leaf server {
          //tailf:cli-disallow-value "vrf";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address or Name of DHCP server";
          }
        }
      }
    }

    // ip dhcp
    container dhcp {
      tailf:info "Configure DHCP server and relay parameters";
      tailf:cli-explicit-exit;

      // ip dhcp smart-relay
      leaf smart-relay {
        tailf:info "Enable Smart Relay feature";
        type empty;
      }

      // ip dhcp use
      container use {
        tailf:info "Configure use of certain parameters during allocation";

        // ip dhcp use vrf
        container vrf {
          tailf:info "Ignore or use receiving interface VRF";

          // no ip dhcp use vrf connected
          leaf connected {
            tailf:info "Use input interface VRF when servicing "+
              "connected clients";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip dhcp use vrf remote
          leaf remote {
            tailf:info "Use input interface VRF when servicing remote clients";
            type empty;
          }
        }
      }

      // no ip dhcp conflict logging
      container conflict {
        tailf:info "DHCP address conflict parameters";
        leaf logging {
          tailf:info "Record address conflicts in a log file";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip dhcp excluded-address *
      container excluded-address {
        tailf:info "Prevent DHCP from assigning certain addresses";
        uses ip-dhcp-excluded-address-grouping;
        list vrf {
          tailf:info "VRF name for excluded address range";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses ip-dhcp-excluded-address-grouping;
        }
      }

      // ip dhcp pool *
      list pool {
        tailf:info "Configure DHCP address pools";
        tailf:cli-mode-name "dhcp-config";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }

        // ip dhcp pool * / vrf
        leaf vrf {
          tailf:info "Associate this pool with a VRF";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ip dhcp pool * / import all
        container "import" {
          tailf:info "Programatically importing DHCP option parameters";
          leaf all {
            tailf:info "all DHCP options";
            type empty;
          }
        }

        // ip dhcp pool * / bootfile
        leaf bootfile {
          tailf:info "Boot file name";
          type string {
            tailf:info "WORD;;Boot file name";
          }
        }

        // ip dhcp pool * / host
        container host {
          tailf:info "Client IP address and mask";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address in dotted-decimal notation";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask or prefix length";
            }
          }
        }

        // ip dhcp pool * / hardware-address
        // ip dhcp pool * / client-identifier
        choice hardware-or-client {
          leaf hardware-address {
            tailf:info "Client hardware address";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Dotted-hexadecimal string (aabb.ccdd.eeff ...)";
            }
          }
          leaf client-identifier {
            tailf:info "Client identifier";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Dotted-hexadecimal string (aabb.ccdd.eeff ...)";
            }
          }
        }

        // ip dhcp pool * / network
        container network {
          tailf:info "Network number and mask";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf network-number {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "Network number in dotted-decimal notation";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            tailf:cli-remove-before-change;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
        }

        // ip dhcp pool * / next-server *
        leaf-list next-server {
          tailf:info "Next server in boot process";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / netbios-name-server *
        leaf-list netbios-name-server {
          tailf:info "NetBIOS (WINS) name servers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / dns-server *
        leaf-list dns-server {
          tailf:info "DNS servers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
          }
        }

        // ip dhcp pool * / default-router *
        leaf-list default-router {
          tailf:info "Default routers";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          max-elements 8;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Router's name or IP address";
          }
        }

        // ip dhcp pool * / domain-name
        leaf domain-name {
          tailf:info "Domain name";
          tailf:cli-full-command;
          type string {
            tailf:info "NAME;;Domain name";
          }
        }

        // ip dhcp pool * / option
        list option {
          tailf:info "Raw DHCP options";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key code;
          leaf code {
            type uint8 {
              tailf:info "<0-254>;;DHCP option code";
              range "0..254";
            }
          }
          choice option-config {
            leaf ascii {
              tailf:info "Data is an NVT ASCII string";
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type string {
                tailf:info "LINE;;NVT ASCII string";
              }
            }
            leaf hex {
              tailf:info "Data is a hexadecimal string";
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type union {
                type string {
                  tailf:info "LINE;;Hexadecimal string";
                }
                type enumeration {
                  enum none {
                    tailf:info "No data";
                  }
                }
              }
            }
            leaf-list ip {
              tailf:info "Data is one or more IP addresses";
              tailf:cli-suppress-no;
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              tailf:cli-flat-list-syntax;
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
              }
            }
          }
          // ip dhcp pool * / option * / instance *
          list instance {
           tailf:info "Specify the option instance";
           tailf:cli-suppress-mode;
           tailf:cli-delete-when-empty;
           tailf:cli-incomplete-command;
            key option-instance;
            leaf option-instance {
              tailf:info "Specify the option instance";
              type uint8 {
                tailf:info "<0-255>;;DHCP option instance";
              }
            }
            choice option-config {
              leaf ascii {
                tailf:info "Data is an NVT ASCII string";
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type string {
                  tailf:info "LINE;;NVT ASCII string";
                }
              }
              leaf hex {
                tailf:info "Data is a hexadecimal string";
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                type union {
                  type string {
                    tailf:info "LINE;;Hexadecimal string";
                  }
                  type enumeration {
                    enum none {
                      tailf:info "No data";
                    }
                  }
                }
              }
              leaf-list ip {
                tailf:info "Data is one or more IP addresses";
                tailf:cli-suppress-no;
                tailf:cli-no-name-on-delete;
                tailf:cli-no-value-on-delete;
                tailf:cli-flat-list-syntax;
                type inet:host {
                  tailf:info "Hostname or A.B.C.D;;Server's name or IP address";
                }
              }
            }
          }
        }

        // ip dhcp pool * / lease
        container lease {
          tailf:info "Address lease time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          choice lease-choice {
            case a {
              leaf infinite {
                tailf:info "Infinite lease";
                type empty;
              }
            }
            case b {
              leaf days {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-365>;;Days";
                  range "0..365";
                }
              }
              leaf hours {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-23>;;Hours";
                  range "0..23";
                }
              }
              leaf minutes {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-59>;;Minutes";
                  range "0..59";
                }
              }
            }
          }
        }

        // ip dhcp pool * / update arp
        container update {
          tailf:info "Dynamic updates";
          leaf arp {
            tailf:info "Add secure ARP entries";
            type empty;
          }
        }

        // ip dhcp pool * / class *
        list class {
          tailf:info "Specify a DHCP class";
          tailf:cli-mode-name "config-dhcp-pool-class";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;DHCP class name";
            }
          }

          // ip dhcp pool * / class * / address range
          container address {
            tailf:info "Specify an address range for this class";
            container "range" {
              tailf:info "Specify an address range for this class";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf start-ip {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Start IP address";
                }
              }
              leaf end-ip {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;End IP address";
                }
              }
            }
          }
        }
        // ip dhcp pool * / netbios-node-type
        leaf netbios-node-type {
          tailf:info "NetBIOS node type";
          type union {
            type enumeration {
              enum "b-node" {
                tailf:info "Broadcast node";
              }
              enum "h-node" {
                tailf:info "Hybrid node";
              }
              enum "m-node" {
                tailf:info "Mixed node";
              }
              enum "p-node" {
                tailf:info "Peer-to-peer node";
              }
            }
            type string {
              tailf:info "<0-FF>;;Hexadecimal number";
            }
          }
        }
      }

      // ip dhcp class *
      list class {
        tailf:info "Configure DHCP classes";
        tailf:cli-mode-name "config-dhcp-class";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Class name";
          }
        }

        // ip dhcp class * / remark
        leaf remark {
          tailf:info "Specify a remark for this class";
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;Up to 240 characters describing this class";
            length "1..240";
          }
        }

        // ip dhcp class * / relay agent information /
        container relay {
          tailf:info "Enter relay agent information option configuration "
            +"submode";
          container agent {
            tailf:info "Enter relay agent information option configuration "
              +"submode";
            container information {
              tailf:info "Enter relay agent information option configuration "
                +"submode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-dhcp-class-relayinfo";
              presence true;
            }
          }
        }
      }

      // ip dhcp snooping
      container snooping {
        tailf:info "DHCP Snooping";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // ip dhcp snooping bridge-domain
        leaf-list bridge-domain {
          tailf:info "DHCP Snooping bridge-domain";
          tailf:cli-range-list-syntax;
          tailf:cli-suppress-list-no;
          tailf:cli-full-command;
          tailf:cli-diff-dependency "../../snooping";
          type uint16 {
            tailf:info "WORD;;bridge-domain range, example: 1,3-5,7,9-11";
            range "1..4094";
          }
        }

        // ip dhcp snooping information
        container information {
          tailf:info "DHCP Snooping information";
          container option {
            tailf:info "DHCP Snooping information option";
            presence true;
            leaf allow-untrusted {
              tailf:info "DHCP Snooping information option allow-untrusted";
              type empty;
            }
            container format {
              tailf:info "Option 82 information format";
              container remote-id {
                tailf:info "Remote id option 82 format";
                choice remote-id-choice {
                  leaf hostname {
                    tailf:info "Use configured hostname for remote id";
                    type empty;
                  }
                  leaf string {
                    tailf:info "User defined string for remote id";
                    type string {
                      tailf:info "WORD;;Use string for remote id (max length "
                        +"63)";
                    }
                  }
                }
              }
            }
          }
        }

        // ip dhcp snooping database
        container database {
          tailf:info "DHCP snooping database agent";
          leaf url {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Database agent URL";
            }
          }
        }

        // ip dhcp snooping track
        container track {
          tailf:info "DHCP snooping track";
          leaf host {
            tailf:info "DHCP snooping track host";
            type empty;
          }
        }

        // ip dhcp snooping verify
        container verify {
          tailf:info "DHCP snooping verify";
          leaf mac-address {
            tailf:info "DHCP snooping verify mac-address";
            type empty;
          }
          leaf no-relay-agent-address {
            tailf:info "DHCP snooping verify giaddr";
            type empty;
          }
        }

        // ip dhcp snooping vlan
        leaf-list vlan {
          tailf:info "DHCP Snooping vlan";
          tailf:cli-range-list-syntax;
          type uint16 {
            tailf:info "WORD;;DHCP Snooping vlan fist number or vlan range, "
              +"example: 1,3-5,7,9-11";
          }
        }
      }

      // ip dhcp snooping
      container snooping-conf {
        tailf:cli-drop-node-name;
        leaf snooping {
          tailf:info "DHCP Snooping ";
          type empty;
        }
      }

      // ip dhcp relay
      container relay {
        tailf:info "DHCP relay agent parameters";

        // ip dhcp relay information
        container information {
          tailf:info "Relay agent information option";

          // ip dhcp relay information option
          container option {
            tailf:info "Insert relay information in BOOTREQUEST";
            presence true;
          }

          // no ip dhcp relay information check
          leaf check {
            tailf:info "Validate relay information in BOOTREPLY";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }

          // ip dhcp relay information trust-all
          leaf trust-all {
            tailf:info "Received DHCP packets may contain relay info "+
              "option with zero giaddr";
            type empty;
          }
        }

        // ip dhcp relay prefer known-good-server
        container prefer {
          tailf:info "Relay agent server selection approach";
          leaf known-good-server {
            tailf:info "For unnumbered interfaces, prefer to send client requests to the server which handled the last one";
            type empty;
          }
        }
      }

      // ip dhcp bootp ignore
      container bootp {
        tailf:info "BOOTP specific configuration";
        leaf ignore {
          tailf:info "Configure this DHCP server to ignore to BOOTP requests.";
          type empty;
        }
      }
    }

    // no ip bootp server
    container bootp {
      tailf:info "Config BOOTP services";
      leaf server {
        tailf:info "Enable BOOTP server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // ip domain
    container domain {
      tailf:info "IP DNS Resolver";

      // ip domain round-robin
      leaf round-robin {
        tailf:info "Round-robin multiple IP addresses in cache";
        tailf:cli-full-command;
        type empty;
      }

      // ip domain list vrf *
      container list-vrf {
        tailf:cli-drop-node-name;
        container "list" {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;A domain name";
              }
            }
          }
        }
      }

      // ip domain list *
      // ip domain-list *
      list "list" {
        tailf:info "Domain name to complete unqualified host names";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;A domain name";
          }
        }
      }

      // ip domain retry
      leaf retry {
        tailf:info "Specify times to retry sending a DNS query";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-100>;;Number of retries";
          range "0..100";
        }
      }

      // ip domain timeout
      leaf timeout {
        tailf:info "Specify timeout waiting for response to a DNS query";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-3600>;;Timeout value in seconds";
          range "1..3600";
        }
      }

      // no ip domain lookup
      container lookup-conf {
        tailf:cli-drop-node-name;
        leaf lookup {
          tailf:info "Enable IP Domain Name System hostname translation";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // ip domain lookup
      container lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;

        // no ip domain lookup nsap
        leaf nsap {
          tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip domain lookup recursive
        leaf recursive {
          tailf:info "Enable IP DNS recursive lookup";
          tailf:cli-full-command;
          type empty;
        }

        // ip domain lookup source-interface
        container source-interface {
          tailf:info "Specify source interface for DNS resolver";
          uses interface-name-grouping;
        }

        // ip domain lookup vrf
        leaf vrf {
          tailf:info "Specify VRF";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
      }

      // ip domain name vrf *
      container name-vrf {
        tailf:cli-drop-node-name;
        container name {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list vrf {
            tailf:info "Specify VRF";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VRF name";
              }
            }
            leaf domain-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Default domain name";
              }
            }
          }
        }
      }

      // ip domain name
      // (ip domain-name)
      leaf name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }

      // ip domain multicast
      leaf multicast {
        tailf:info "Define the domain name for multicast address lookups";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Multicast domain name";
        }
      }

      // ip domain recursive
      container recursive {
        tailf:info "Configure recursive DNS lookup";
        leaf retry {
          tailf:info "Configure maximum no. referrals to be allowed";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-100>;;Maximum no. of referrals allowed "+
              "- default 10";
            range "0..100";
          }
        }
        leaf allow-soa {
          tailf:info "Treat response containing SOA RR in AUTHORITY as a "+
            "referral";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // ip host *
    container host {
      tailf:info "Add an entry to the ip hostname table";
      uses ip-host-grouping;
      // ip host vrf *
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip host vrf * *
        uses ip-host-grouping;
      }
    }

    // ip name-server *
    container name-server {
      tailf:info "Specify address of name server to use";
      uses ip-name-server-grouping;
      list vrf {
        tailf:info "Specify VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        // ip name-server vrf * *
        uses ip-name-server-grouping;
      }
    }

    // ip multicast-routing
    container mcr-conf {
      tailf:cli-drop-node-name;
      leaf multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        type empty;
      }
    }

    // ip multicast-routing vrf *
    container multicast-routing {
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-incomplete-no;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../mcr-conf/multicast-routing";
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-list-no;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-diff-dependency "../../mcr-conf/multicast-routing";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf distributed {
          tailf:info "Distributed multicast switching";
          type empty;
        }
      }
      // ip multicast-routing distributed
      leaf distributed {
        tailf:info "Distributed multicast switching";
        tailf:cli-full-command;
        type empty;
      }
    }

    // ip multicast
    container multicast {
      tailf:info "Global IP Multicast Commands";

      // ip multicast route-limit
      leaf route-limit {
        tailf:info "Maximum number of multicast routes";
        type uint32 {
          tailf:info "<1-2147483647>;;number of routes";
          range "1..2147483647";
        }
      }

      // ip multicast multipath
      container multipath {
        tailf:info "RPF across equal-cost paths";
        presence true;
        leaf s-g-hash {
          tailf:info "Per-(source, group) load sharing algorithm selection";
          type enumeration {
            enum basic {
              tailf:info "Basic hash on (source, group)";
            }
            enum next-hop-based {
              tailf:info "Advanced hash on (source, group) and next-hop";
            }
          }
        }
      }

      // ip multicast vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }

        // ip multicast vrf * route-limit
        container route-limit {
          tailf:info "Maximum number of multicast routes";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf limit {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;number of routes";
              range "1..2147483647";
            }
          }
          leaf threshold {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
              range "1..2147483647";
            }
          }
        }

        // ip multicast vrf * multipath
        container multipath {
          tailf:info "RPF across equal-cost paths";
          presence true;
        }
      }
    }

    // ip icmp
    container icmp {
      tailf:info "ICMP options";

      // ip icmp rate-limit unreachable
      container rate-limit {
        tailf:info "rate limit ICMP messages generated";
        container unreachable {
          tailf:info "ICMP type 3, Destination Unreachable";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf DF {
            tailf:info "code 4, fragmentation needed and DF set";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf ms {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;Once per milliseconds";
            }
          }
          leaf log {
            tailf:info "log message if rate limiting is excessive";
            type empty;
          }
          leaf packets {
            when "../log" {
              tailf:dependency "../log";
            }
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-4294967295>;;number of unreachables within "+
                "interval to trigger a message";
              range "1..4294967295";
            }
          }
          leaf interval-ms {
            when "../log" {
              tailf:dependency "../log";
            }
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10000-4294967295>;;log message once per "+
                "milliseconds";
              range "10000..4294967295";
            }
          }
        }
      }

      // ip icmp redirect
      leaf redirect {
        tailf:info "Redirect type";
        tailf:cli-full-command;
        type enumeration {
          enum subnet {
            tailf:info "Send ICMP subnet redirects";
          }
          enum host {
            tailf:info "Send ICMP host redirects";
          }
        }
        default subnet;
      }
    }

    // ip igmp
    container igmp {
      tailf:info "IGMP global configuration";

      // ip igmp limit
      // ip igmp ssm-map
      uses ip-igmp-grouping;

      // ip igmp snooping X
      container snooping-conf {
        tailf:cli-drop-node-name;
        container snooping {
          tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // ip igmp snooping l2-entry-limit
          leaf l2-entry-limit {
            tailf:info "limit on the l2 entry that can be installed by IGMP snooping";
            type uint32 {
              tailf:info "<1-100000>;;maximum number of l2 entries";
              range "1..100000";
            }
          }

          // ip igmp snooping last-member-query-interval
          leaf last-member-query-interval {
            tailf:info "Last member query interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<100-32767>;;Interval (milliseconds)";
              range "100..32767";
            }
          }

          // ip igmp snooping source-only-learning age-timer
          container source-only-learning {
            tailf:info "source-only gce entries";
            leaf age-timer {
              tailf:info "configure age-timer for source-only entries";
              type uint32 {
                tailf:info "<0-86400>;;source-only entries age timer in secs";
                range "0..86400";
              }
              default 600;
            }
          }
        }
      }

      // no ip igmp snooping
      leaf snooping {
        tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // no ip igmp snooping vlan *
      // = ip igmp snooping vlan no-list *
      container snooping-vlan {
        tailf:cli-drop-node-name;
        when "not(../snooping = 'false')" {
          tailf:dependency "../snooping";
        }
        container snooping {
          tailf:info "Global IGMP Snooping enable for Catalyst Vlans";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container vlan {
            tailf:info "IGMP Snooping enable for Catalyst VLAN";
            list no-list {
              tailf:info "'no ip igmp snooping vlan' entry";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-4094>;;VLAN ID";
                  range "1..4094";
                }
              }
            }
          }
        }
      }

      // ip igmp vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-igmp-grouping;
      }
    }

    // ip msdp
    container msdp {
      tailf:info "MSDP global commands";
      uses ip-msdp-grouping;

      // ip msdp vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-msdp-grouping;
      }
    }

    // ip device tracking
    container device {
      tailf:info "Device tracking";
      container tracking {
        tailf:info "Device tracking";
        tailf:cli-delete-when-empty;
        presence true;
        container probe {
          tailf:info "Probe";

          // ip device tracking probe auto-source
          container auto-source {
            tailf:info "Probe source selection algorithm";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            container fallback {
              tailf:info "Specify IP and MASK to use as last resort";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf address {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP of fallback source";
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP prefix mask";
                }
              }
            }
            leaf override {
              tailf:info "Do not select source address from device track table";
              type empty;
            }
          }

          // ip device tracking probe delay
          leaf delay {
            tailf:info "Probe delay";
            type uint8 {
              tailf:info "<1-120>;;delay";
              range "1..120";
            }
          }
        }
      }
    }

    // ip finger
    // ip finger rfc-compliant
    container finger {
      tailf:info "finger server";
      presence true;
      leaf rfc-compliant {
        tailf:info "Comply with RFC 1288";
        type empty;
      }
    }

    // ip tcp
    container tcp {
      tailf:info "Global TCP parameters";

      // ip tcp selective-ack
      leaf selective-ack {
        tailf:info "Enable TCP selective-ACK";
        type empty;
      }

      // ip tcp mss
      leaf mss {
        tailf:info "TCP initial maximum segment size ";
        type uint16 {
          tailf:info "<68-10000>;;MSS";
          range "68..10000";
        }
      }

      // ip tcp path-mtu-discovery
      container path-mtu-discovery {
        tailf:info "Enable path-MTU discovery on new TCP connections";
        presence true;
        leaf age-timer {
          tailf:info "Set PMTU aging timer";
          type union {
            type enumeration {
              enum "infinite" {
                tailf:info "Disable pathmtu aging timer";
              }
            }
            type uint8 {
              tailf:info "<10-30>;;Aging time";
              range "10..30";
            }
          }
        }
      }

      // ip tcp window-size
      leaf window-size {
        tailf:info "TCP window size";
        type uint32 {
          tailf:info "<68-1073741823>;;Window size";
          range "68..1073741823";
        }
      }

      // ip tcp synwait-time
      leaf synwait-time {
        tailf:info "Set time to wait on new TCP connections";
        type uint16 {
          tailf:info "<5-300>;;Wait time";
          range "5..300";
        }
      }
    }

    // ip telnet
    container telnet {
      tailf:info "Specify telnet options";

      // ip telnet tos
      leaf tos {
        tailf:info "Specify type of service";
        type string {
          tailf:info "<0-FF>;;TOS value";
        }
      }

      // ip telnet source-interface
      container source-interface {
        tailf:info "Specify source interface";
        uses interface-name-grouping;
      }
    }

    // ip ftp
    container ftp {
      tailf:info "FTP configuration commands";

      // no ip ftp passive
      leaf passive {
        tailf:info "Connect using passive mode";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip ftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in"+
          " FTP connections";
        uses interface-name-grouping;
      }

      // ip ftp username
      leaf username {
        tailf:info "Specify username for FTP connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Username";
        }
      }

      // ip ftp password
      container password {
        tailf:info "Specify password for FTP connections;";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }
    }

    // ip tftp
    container tftp {
      tailf:info "tftp configuration commands";

      // ip tftp source-interface
      container source-interface {
        tailf:info "Specify interface for source address in TFTP connections";
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }

      // ip tftp boot-interface
      container boot-interface {
        tailf:info "Force interface to use for TFTP booting";
        uses interface-name-grouping;
      }

      // ip tftp blocksize
      leaf blocksize {
        tailf:info "Specify TFTP client blocksize";
        type uint16 {
          tailf:info "<512-8192>;;blocksize value";
          range "512..8192";
        }
      }
    }

    // ip ssh
    container ssh {
      tailf:info "Configure ssh options";

      // ip ssh time-out
      leaf time-out {
        tailf:info "Specify SSH time-out interval";
        type uint8 {
          tailf:info "<1-120>;;SSH time-out interval (secs)";
          range "1..120";
        }
        default 120;
      }

      // ip ssh port *
      list port {
        tailf:info "Starting (or only) Port number to listen on";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key port;
        leaf port {
          type uint16 {
            tailf:info "<2000-10000>;;Starting Port number";
            range "2000..10000";
          }
        }
        leaf rotary {
          tailf:info "Starting (or only) rotary group number";
          type uint8 {
            tailf:info "<1-127>;;Low (or only) Rotary group numbe";
            range "1..127";
          }
        }
        leaf rotary-high {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-127>;;High Rotary group numbe";
            range "1..127";
          }
        }
      }

      // ip ssh break-string
      leaf break-string {
        tailf:info "break-string";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Break string";
        }
      }

      // ip ssh authentication-retries
      leaf authentication-retries {
        tailf:info "Specify number of authentication retries";
        type uint8 {
          tailf:info "<0-5>;;Number of authentication retries";
          range "0..5";
        }
        default 3;
      }

      // ip ssh dscp
      leaf dscp {
        tailf:info "IP DSCP value for SSH traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0)";
          range "0..63";
        }
      }

      // ip ssh logging
      container logging {
        tailf:info "Configure logging for SSH";
        leaf events {
          tailf:info "Log SSH events";
          type empty;
        }
      }

      // ip ssh version
      leaf version {
        tailf:info "Specify protocol version supported";
        type uint8 {
          tailf:info "<1-2>;;Protocol version";
          range "1..2";
        }
      }

      // ip ssh precedence
      leaf precedence {
        tailf:info "IP Precedence value for SSH traffic";
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }

      // ip ssh stricthostkeycheck
      leaf stricthostkeycheck {
        tailf:info "Enable SSH Server Authentication";
        type empty;
      }

      // ip ssh source-interface
      container source-interface {
        tailf:info "Specify interface for source address in SSH connections";
        uses interface-name-grouping;
      }

      // ip ssh dh min size
      container dh {
        tailf:info "Diffie-Hellman";
        container min {
          tailf:info "minimum";
          leaf size {
            tailf:info "key size";
            type enumeration {
              enum 1024 {
                tailf:info "Diffie Group 1 1024-bit key";
              }
              enum 2048 {
                tailf:info "Diffie Group 14 2048-bit key";
              }
              enum 4096 {
                tailf:info "Diffie Group 16 4096-bit key";
              }
            }
            default 1024;
          }
        }
      }

      // ip ssh server
      container server {
        tailf:info "Configuration for server";

        // no ip ssh server authenticate user publickey
        // no ip ssh server authenticate user keyboard
        // no ip ssh server authenticate user password
        container authenticate {
          tailf:info "Authentication configuration parameter";
          container user {
            tailf:info "User configuration";
            leaf publickey {
              tailf:info "Public key based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            leaf keyboard {
              tailf:info "keyboard-interactive based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            leaf password {
              tailf:info "Password based authentication";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
        }

        // ip ssh server algorithm
        uses ip-ssh-algorithm-grouping;
      }

      // ip ssh client algorithm
      container client {
        tailf:info "Configuration for client";
        uses ip-ssh-algorithm-grouping;
      }

      // ip ssh rsa keypair-name
      container rsa {
        tailf:info "Configure RSA keypair name for SSH";
        leaf keypair-name {
          tailf:info "keypair-name";
          type string {
            tailf:info "WORD;;keypair name";
          }
        }
      }

      // ip ssh pubkey-chain
      container pubkey-chain {
        tailf:info "pubkey-chain";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-ssh-pubkey";
        tailf:cli-full-command;

        // ip ssh pubkey-chain / username *
        list username {
          tailf:cli-mode-name "conf-ssh-pubkey-user";
          tailf:cli-exit-command "quit";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the user";
            }
          }

          // ip ssh pubkey-chain / username * / key-hash *
          list key-hash {
            tailf:info "Key hash data";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key key-type;
            leaf key-type {
              type enumeration {
                enum ssh-rsa {
                  tailf:info "WORD;;key type ssh-rsa";
                }
              }
            }
            leaf key-name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;key hash data";
              }
            }
          }
        }
      }
    }

    // ip scp server enable
    container scp {
      tailf:info "Scp commands";
      container server {
        tailf:info "Configure SCP server-side functionality";
        leaf enable {
          tailf:info "Enable server side of SCP";
          type empty;
        }
      }
    }

    // ip local pool *
    container local {
      tailf:info "Specify local options";

      // ip local policy route-map
      container policy {
        tailf:info "Enable policy routing";
        leaf route-map {
          tailf:info "Policy route map";
          type string {
            tailf:info "WORD;;Route map name";
          }
        }
      }

      // ip local pool *
      list pool {
        tailf:info "IP Local address pool lists";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type union {
            type string {
              tailf:info "WORD;;Create named local address pool";
            }
            type enumeration {
              enum "default" {
                tailf:info "Create default local address pool";
              }
            }
          }
        }
        leaf start {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;First IP address of range";
          }
        }
        leaf last {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Last IP address of range";
          }
        }
        leaf group {
          tailf:info "Create ip local pool group";
          type string {
            tailf:info "WORD;;Group name for this named local address pool";
          }
        }
      }
    }

    // ip default-gateway
    leaf default-gateway {
      tailf:info "Specify default gateway (if not routing IP)";
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default gateway";
      }
    }

    // ip default-network *
    leaf-list default-network {
      tailf:info "Flags networks as candidates for default routes";
      tailf:cli-list-syntax;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;IP address of default network";
      }
    }

    // no ip classless
    leaf classless {
      tailf:info "Follow classless routing forwarding rules";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // ip forward-protocol
    container forward-protocol {
      tailf:info "Controls forwarding of physical and directed IP broadcasts";

      // ip forward-protocol nd
      // no ip forward-protocol nd
      leaf nd {
        tailf:info "Sun's Network Disk protocol";
        tailf:cli-show-no;
        type empty;
      }

      // ip forward-protocol sdns
      leaf sdns {
        tailf:info "Network Security Protocol";
        tailf:cli-boolean-no;
        type boolean;
      }

      // ip forward-protocol turbo-flood
      leaf turbo-flood {
        tailf:info "Fast flooding of UDP broadcasts";
        tailf:cli-boolean-no;
        type boolean;
      }

      // ip forward-protocol spanning-tree
      container spanning-tree {
        tailf:info "Use transparent bridging to flood UDP broadcasts";
        presence true;
        leaf any-local-broadcast {
          tailf:info "Accept any local broadcast when flooding";
          type empty;
        }
      }

      // ip forward-protocol udp
      choice udp-choice {

        // no ip forward-protocol udp
        leaf udp {
          tailf:info "Packets to a specific UDP port";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // OR:
        // ip forward-protocol udp X    = ip forward-protocol udp X
        // no ip forward-protocol udp Y = ip forward-protocol udp Y disabled
        container udp-conf {
          tailf:cli-drop-node-name;
          container udp {
            tailf:info "Packets to a specific UDP port";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            list service {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-suppress-list-no;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Port or UDP service name";
                }
              }
              leaf disabled {
                tailf:info "service disabled";
                type empty;
              }
            }
          }
        }
      }
    }

    // ip rcmd
    container rcmd {
      tailf:info "Rcmd commands";

      // no ip rcmd domain-lookup
      leaf domain-lookup {
        tailf:info "Enable IP DNS queries for Rcmd";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip rcmd rcp-enable
      leaf rcp-enable {
        tailf:info "Enable server side of RCP";
        type empty;
      }

      // ip rcmd rsh-enable
      leaf rsh-enable {
        tailf:info "Enable server side of RSH";
        type empty;
      }

      // ip rcmd remote-host *
      list remote-host {
        tailf:info "Set host+user equivalence";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "local-username host remote-username";
        leaf local-username {
          type string {
            tailf:info "WORD;;Local username";
          }
        }
        leaf host {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Remote hostname or IP address";
          }
        }
        leaf remote-username {
          type string {
            tailf:info "WORD;;Remote username";
          }
        }
        leaf enable {
          tailf:info "Allow enable-mode commands";
          type empty;
        }
      }

      // ip rcmd source-interface
      container source-interface {
        tailf:info "Specify interface for source address in rcmd connections";
        uses interface-name-grouping;
      }
    }

    // ip http
    container http {
      tailf:info "HTTP server configuration";

      // ip http server
      leaf server {
        tailf:info "Enable http server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // ip http access-class
      leaf access-class {
        tailf:info "Restrict http server access by access-class";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-99>;;Access list number";
          range "1..99";
        }
      }

      // ip http authentication
      container authentication {
        tailf:info "Set http server authentication method";
        choice authentication-choice {

          // ip http authentication aaa
          container aaa {
            tailf:info "Use AAA access control methods";
            presence true;

            // ip http authentication aaa exec-authorization
            leaf exec-authorization {
              tailf:info "Set method list for exec authorization";
              tailf:cli-diff-dependency "../../../../../aaa/authorization/exec";
              type string {
                tailf:info "WORD;;Use an authorization list with this name.";
              }
            }
          }

          // ip http authentication local
          leaf local {
            tailf:info "Use local username and passwords";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // ip http secure-server
      leaf secure-server {
        tailf:info "Enable HTTP secure server";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
      }

      // ip http secure-active-session-modules
      container secure-active-session-modules {
        tailf:info "Set up active http secure server session modules";
        choice modules-choice {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "all|none";
            type string {
              tailf:info "WORD;;Session module list name to activate";
            }
          }
          leaf all {
            tailf:info "Activate all session modules";
            type empty;
          }
          leaf none {
            tailf:info "Deactivate all session modules";
            type empty;
          }
          default all;
        }
      }

      // ip http active-session-modules
      container active-session-modules {
        tailf:info "Set up active http server session modules";
        choice modules-choice {
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "all|none";
            type string {
              tailf:info "WORD;;Session module list name to activate";
            }
          }
          leaf all {
            tailf:info "Activate all session modules";
            type empty;
          }
          leaf none {
            tailf:info "Deactivate all session modules";
            type empty;
          }
          default all;
        }
      }

      // ip http timeout-policy
      container timeout-policy {
        tailf:info "Set http server time-out policy parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf idle {
          tailf:info "Idle time-out of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-600>;;Connection idle time-out value in seconds";
            range "1..600";
          }
        }
        leaf life {
          tailf:info "Life time of a http server connection in seconds";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-86400>;;Connection life time value in seconds";
            range "1..86400";
          }
        }
        leaf requests {
          tailf:info "Maximum number of requests allowed on a http server "+
            "connection";
          type uint32 {
            tailf:info "<1-86400>;;Maximum number of requests allowed on a "+
              "http server connection";
            range "1..86400";
          }
        }
      }

      // ip http client
      container client {
        tailf:info "Set http client parameters";

        // ip http client source-interface
        container source-interface {
          tailf:info "Specify interface for source address in all HTTP(S) client connections";
          uses interface-name-grouping;
        }

        // ip http client proxy-server
        container proxy-server {
          tailf:info "Specify proxy server name for HTTP file system client connections";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:host {
              tailf:info "WORD;;Proxy server name";
            }
          }
          leaf proxy-port {
            tailf:info "Specify proxy port number for HTTP file system client connections";
            type uint16 {
              tailf:info "<1-65535>;;Proxy port number";
              range "1..65535";
            }
          }
        }
      }

      // ip http help-path
      leaf help-path {
        tailf:info "HTTP help root URL";
        type string {
          tailf:info "WORD;;root URL for help pages";
        }
      }
    }

    // ip ospf name-lookup
    container ospf {
      tailf:info "OSPF";
      leaf name-lookup {
        tailf:info "Display OSPF router ids as DNS names";
        type empty;
      }
    }

    // ip bgp-community new-format
    container bgp-community {
      tailf:info "format for BGP community";
      leaf new-format {
        tailf:info "select aa:nn format for BGP community";
        type empty;
      }
    }

    // ip community-list
    container community-list {
      tailf:info "Add a community list entry";

      // ip community-list *
      list number {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key no;
        leaf no {
          type union {
            type uint16 {
              tailf:info "<1-99>;;Community list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Community list number (expanded)";
              range "100..500";
            }
          }
        }
        uses ip-community-list-grouping;
      }

      // ip community-list standard *
      list standard {
        tailf:info "Add a standard community-list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:meta-data "replace-list" {
          tailf:meta-value "ip community-list standard :: entry :: expr :: C3550";
        }
        tailf:ned-data "." {
          tailf:transaction to;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-grouping;
      }

      // ip community-list expanded *
      list expanded {
        tailf:info "Add an expanded community-list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:meta-data "replace-list" {
          tailf:meta-value "ip community-list expanded :: entry :: expr :: C3550";
        }
        tailf:ned-data "." {
          tailf:transaction to;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Community list name";
          }
        }
        uses ip-community-list-grouping;
      }
    }

    // ip extcommunity-list
    container extcommunity-list {
      tailf:info "Add a extended community list entry";

      // ip extcommunity-list *
      list number {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key no;
        leaf no {
          type union {
            type uint16 {
              tailf:info "<1-99>;;Extended Community list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Extended Community list number (expanded)";
              range "100..500";
            }
          }
        }
        uses ip-extcommunity-list-grouping;
      }

      // ip extcommunity-list standard
      container standard {
        tailf:info "Add a standard community-list entry";

        // ip extcommunity-list standard *
        list no-mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          uses ip-extcommunity-list-grouping;
        }

        // ip extcommunity-list standard * /
        list mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-extcomm-list";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483647>;;Sequence Number";
                range "1..2147483647";
              }
            }
            leaf expr {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
                pattern "(permit.*)|(deny.*)";
              }
            }
          }
        }
      }

      // ip extcommunity-list expanded
      container expanded {
        tailf:info "Add an expanded community-list entry";

        // ip extcommunity-list expanded *
        list no-mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          uses ip-extcommunity-list-grouping;
        }

        // ip extcommunity-list expanded * /
        list mode-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-extcomm-list";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Extended community-list name";
            }
          }
          list entry {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483647>;;Sequence Number";
                range "1..2147483647";
              }
            }
            leaf expr {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "<RULE>;;deny <LINE> | permit <LINE>";
                pattern "(permit.*)|(deny.*)";
              }
            }
          }
        }
      }
    }

    // ip as-path
    container as-path {
      tailf:info "BGP autonomous system path filter";

      // ip as-path access-list *
      list access-list {
        tailf:info "Specify an access list number";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Access-list number or name";
          }
        }
        list as-path-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key "operation rule";
          leaf operation {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum deny {
                tailf:code-name "operation_deny";
                tailf:info "Specify packets to reject";
              }
              enum permit {
                tailf:code-name "operation_permit";
                tailf:info "Specify packets to forward";
              }
            }
          }
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;A regular-expression to match"+
                " BGP AS paths.";
            }
          }
        }
      }
    }

    // ip flow-cache
    container flow-cache {
      tailf:info "Configure netflow cache parameters";
      // ip flow-cache entries
      leaf entries {
        tailf:info "Specify the number of entries in the flow cache";
        type uint32 {
          tailf:info "<1024-524288>;;Entries";
          range "1024..524288";
        }
      }
      // ip flow-cache timeout
      container timeout {
        tailf:info "Specify flow cache timeout parameters";
        leaf inactive {
          tailf:info "Specify the inactive flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<10-600>;;Timeout in seconds";
            range "10..600";
          }
        }
        leaf active {
          tailf:info "Specify the active flow timeout";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-60>;;Timeout in minutes";
            range "1..60";
          }
        }
      }
    }

    // ip flow-export
    container flow-export {
      tailf:info "Specify host/port to send flow statistics";

      // ip flow-export source
      container source {
        tailf:info "Specify the interface for source address";
        uses interface-name-grouping;
      }

      // ip flow-export version
      leaf version {
        tailf:info "Specify the version number";
        type enumeration {
          enum "1";
          enum "5";
          enum "9";
        }
      }

      // ip flow-export template
      container template {
        tailf:info "Specify the template specific configurations";
        tailf:cli-diff-dependency "../version";
        container options {
          tailf:info "Specify the template option";
          leaf export-stats {
            tailf:info "Specify the template option export statistics";
            tailf:cli-full-command;
            type empty;
          }
        }
        // ip flow-export template timeout-rate
        leaf timeout-rate {
          tailf:info "Specify the time before template is resent";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-3600>;;Timeout in minutes (default 30 minutes)";
            range "1..3600";
          }
          default 30;
        }
        leaf refresh-rate {
          tailf:info "Specify the number of export packets before "+
            "template is resent";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-600>;;refresh rate in export packets "+
              "(default 20 packets)";
            range "1..600";
          }
          default 20;
        }
      }

      // ip flow-export destination
      container destination  {
        tailf:info "Specify the Destination IP address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf ip {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Destination IP address";
          }
        }
        leaf port {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;UDP port number";
            range "1..65535";
          }
        }
      }

    }

    // ip flow-aggregation
    container flow-aggregation {
      tailf:info "Configure flow aggregation";

      // ip flow-aggregation cache *
      list cache {
        tailf:info "Create flow aggregation cache or "+
          "enter flow-cache command mode";
        tailf:cli-mode-name "config-flow-cache";
        key name;
        leaf name {
          type string;
        }
        // ip flow-aggregation cache * / cache
        container cache {
          tailf:info "Configure netflow cache parameters";
          container timeout {
            tailf:info "Specify flow cache timeout parameters";
            leaf active {
              tailf:info "Specify the active flow timeout";
              type uint8 {
                tailf:info "<1-60>;;Timeout in minutes";
                range "1..60";
              }
            }
          }
        }
        // ip flow-aggregation cache * / export
        container export {
          tailf:info "Specify host/port to send flow statistics";
          list destination {
            tailf:info "Specify the Destination IP address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key address;
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;Destination IP addres";
              }
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;UDP/SCTP port number";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // ip dns
    container dns {
      tailf:info "Configure DNS server for a zone";

      // ip dns view *
      list view {
        tailf:info "Configure a DNS view";
        tailf:cli-mode-name "cfg-dns-view";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;View name";
          }
        }
        uses ip-dns-view-grouping;
      }

      // ip dns view vrf * *
      container view-vrf {
        tailf:cli-drop-node-name;
        list view {
          tailf:info "Configure a DNS view";
          tailf:cli-mode-name "cfg-dns-view";
          key "vrf name";
          leaf vrf {
            tailf:info "Specify a VRF";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf name {
            type string {
              tailf:info "WORD;;View name";
            }
          }
          uses ip-dns-view-grouping;
        }
      }

      // ip dns view-list *
      list view-list {
        tailf:info "Configure a DNS view-list";
        tailf:cli-mode-name "cfg-dns-view-list";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;View-list name";
          }
        }

        // ip dns view-list * / view *
        list view {
          tailf:cli-mode-name "cfg-dns-view-list-member";
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;View name";
            }
          }
          leaf order {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type uint32 {
              tailf:info "<1-2147483647>;;Evaluation order";
              range "1..2147483647";
            }
          }

          // ip dns view-list * / view * / restrict
          container restrict {
            tailf:info "Configure view usage restrictions";

            // ip dns view-list * / view * / restrict name-group
            leaf name-group {
              tailf:info "Restrict to users matching an ip dns name-list";
              type uint32 {
                tailf:info "<1-2147483647>;;IP DNS access-list number";
                range "1..2147483647";
              }
            }

            // ip dns view-list * / view * / restrict authenticate
            leaf authenticate {
              tailf:info "Restrict to authenticated users";
              type empty;
            }
          }
        }

        // ip dns view-list * / view vrf * *
        container view-vrf {
          tailf:cli-drop-node-name;
          list view {
            tailf:cli-mode-name "cfg-dns-view-list-member";
            tailf:cli-incomplete-command;
            key "vrf name";
            leaf vrf {
              tailf:info "Specify vrf";
              tailf:cli-expose-key-name;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;vrf name";
              }
            }
            leaf name {
              type string {
                tailf:info "WORD;;View name";
              }
            }
            leaf order {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type uint32 {
                tailf:info "<1-2147483647>;;Evaluation order";
                range "1..2147483647";
              }
            }

            // ip dns view-list * / view vrf * * / restrict
            container restrict {
              tailf:info "Configure view usage restrictions";

              // ip dns view-list * / view vrf * * / restrict name-group
              leaf name-group {
                tailf:info "Restrict to users matching an ip dns name-list";
                type uint32 {
                  tailf:info "<1-2147483647>;;IP DNS access-list number";
                  range "1..2147483647";
                }
              }

              // ip dns view-list * / view vrf * * / restrict authenticate
              leaf authenticate {
                tailf:info "Restrict to authenticated users";
                type empty;
              }
            }
          }
        }
      }

      // ip dns name-list *
      list name-list {
        tailf:info "Regular expression name-list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "id operation";
        leaf id {
          type uint16 {
            tailf:info "<1-500>;;Regular expression name-list number";
            range "1..500";
          }
        }
        leaf operation {
          type enumeration {
            enum permit {
              tailf:info "Specify packets to forward";
            }
            enum deny {
              tailf:info "Specify packets to reject";
            }
          }
        }
        leaf regexp {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;A regular-expression to match hostnames";
          }
        }
      }

      // ip dns server
      container server {
        tailf:info "Enable DNS server";
        tailf:cli-display-separated;
        presence true;

        // ip dns server view-group
        leaf view-group {
          tailf:info "Configure a DNS view-list for global use on this system";
          tailf:non-strict-leafref {
            path "../../../../ip/dns/view-list/name";
          }
          type string {
            tailf:info "WORD;;View-list name";
          }
        }
      }

      // ip dns spoofing
      container spoofing {
        tailf:info "Configure DNS spoofing";
        presence true;
      }
    }

    // ip mobile
    container mobile {
      tailf:info "Enable Mobile IP services";

      // ip mobile secure
      container secure {
        tailf:info "Security association";

        // ip mobile secure home-agent *
        list home-agent {
          tailf:info "Home agent security association";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key lower-address;
          leaf lower-address {
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address (lower range)";
            }
          }
          leaf upper-address {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Upper range IP address for security";
            }
          }
          choice spi-choice {
            // ip mobile secure home-agent * spi
            case single-spi {
              container spi {
                tailf:info "Security parameter index - bidirectional";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
            // ip mobile secure home-agent * lower-spi
            case range-spi {
              container inbound-spi {
                tailf:info "Security parameter index - inbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
              container outbound-spi {
                tailf:info "Security parameter index - outbound";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses mobile-ip-spi-grouping;
              }
            }
          }
          // ip mobile secure home-agent * key
          container "key" {
            tailf:info "Security key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice key-choice {
              leaf ascii {
                tailf:info "Key entered in ASCII string";
                type string {
                  tailf:info "WORD;;Key entered in ASCII";
                }
              }
              leaf hex {
                tailf:info "Key entered in hex string";
                type string {
                  tailf:info "Hex-string;;Hex string";
                }
              }
            }
          }
          // ip mobile secure home-agent * algorithm
          container algorithm {
            tailf:cli-break-sequence-commands;
            tailf:info "Authentication algorithm";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice algorithm-choice {
              leaf hmac-md5 {
                tailf:info "HMAC MD5 authentication";
                type empty;
              }
              container md5 {
                tailf:info "Keyed MD5 authentication";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                container mode {
                  tailf:info "Authentication mode";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  leaf prefix-suffix {
                    tailf:info "Prefix-suffix mode";
                    type empty;
                  }
                }
              }
            }
          }
          // ip mobile secure home-agent * ignore-spi
          leaf ignore-spi {
            tailf:info "Ignore SPI for Authentication";
            type empty;
          }
        }
      }

      // ip mobile router
      container router {
        tailf:info "Mobile Router commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name "mobile-router";
        tailf:cli-diff-dependency "../../../router/mobile";
        //when "../../../router/mobile";
        presence true;

        // ip mobile router / address
        container address {
          tailf:info "Mobile router's home address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf ipv4-address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          leaf ipv4-mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Home network mask";
            }
          }
        }

        // ip mobile router / collocated single-tunnel
        container collocated {
          tailf:info "Collocated CoA parameters";
          leaf single-tunnel {
            tailf:info "Optimized tunneling between MR and HA";
            tailf:cli-diff-dependency "../../../../../router/mobile";
            type empty;
          }
        }

        // ip mobile router / home-agent *
        list home-agent {
          tailf:info "Mobile router's home agent";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../../../router/mobile";
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address";
            }
          }
          // ip mobile router / home-agent * priority
          leaf priority {
            tailf:info "Priority level";
            type uint8 {
              tailf:info "<0-255>;;Priority value (default is 100)";
            }
            default 100;
          }
        }

        // ip mobile router / mobile-network *
        list mobile-network {
          tailf:info "Mobile router's mobile network";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../../interface";
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          // ip mobile router / mobile-network * policy mobile-map
          container policy {
            tailf:info "Enable MIP policy routing";
            leaf mobile-map {
              tailf:info "Apply mobile-map dyn route-map";
              type string {
                tailf:info "WORD;;mobile-map tag";
              }
            }
          }
        }

        // ip mobile router / register
        container register {
          tailf:info "Registration settings";

          // ip mobile router / register extend
          container extend {
            tailf:info "Extend registration lifetime";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf expire {
              tailf:info "Reregister before expiration";
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../../../../router/mobile";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds before expiration";
                range "1..3600";
              }
            }
            leaf retry {
              tailf:info "Number of attempts to extend registration";
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-10>;;Stop after number of retries attempted";
                range "0..10";
              }
            }
            leaf interval {
              tailf:info "Interval between retries";
              type uint16 {
                tailf:info "<1-3600>;;Number of seconds between attempts";
                range "1..3600";
              }
            }
            leaf reverse-tunnel {
              type empty;
            }
          }
        }

        // ip mobile router / reverse-tunnel
        leaf reverse-tunnel {
          tailf:info "Reverse Tunnel requested";
          type empty;
        }

        // ip mobile router / tunnel mode gre
        container tunnel {
          tailf:info "Tunnel parameters";
          container mode {
            tailf:info "Tunnel mode";
            leaf gre {
              tailf:info "GRE encapsulation";
              type empty;
            }
          }
        }

        // ip mobile router / template tunnel
        container template {
          tailf:info "Configure a tunnel template for tunnels to the "+
            "Home Agent";
          leaf Tunnel {
            tailf:info "Tunnel interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Tunnel interface number";
            }
          }
        }
      }
    }

    // ip pim
    container pim {
      tailf:info "PIM global commands";
      tailf:cli-diff-dependency "../../interface";

      uses ip-pim-grouping;

      // ip pim vrf *
      list vrf {
        tailf:info "Select VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-pim-grouping;
      }
    }

    // ip rsvp
    container rsvp {
      tailf:info "Configure static RSVP information";
      container signalling {
        tailf:info "RSVP Signalling";

        // ip rsvp signalling refresh
        container refresh {
          tailf:info "Configure RSVP refresh behavior";

          // ip rsvp signalling refresh reduction ack-delay
          container reduction-conf {
            tailf:cli-drop-node-name;
            container reduction {
              tailf:info "Configure refresh reduction";
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              leaf ack-delay {
                tailf:info "Time to wait to accumulate ACKs (msecs)";
                type uint16 {
                  tailf:info "<100-10000>;;ACK delay (msecs)";
                  range "100..10000";
                }
              }
            }
          }

          // ip rsvp signalling refresh reduction
          leaf reduction {
            tailf:info "Configure refresh reduction";
            tailf:cli-full-command;
            type empty;
          }
        }

        // ip rsvp signalling hello
        container hello {
          tailf:info "Enable neighbor-down detection";
          tailf:cli-delete-when-empty;
          presence true;

          // ip rsvp signalling hello graceful-restart
          container graceful-restart {
            tailf:info "Configure RSVP Graceful Restart";
            leaf mode {
              tailf:info "Select Graceful Restart capabilities";
              type enumeration {
                enum full {
                  tailf:info "Capable of recovering self, and helping "+
                  "neighbor recover";
                }
                enum help-neighbor {
                  tailf:info "Capable of helping neighbor recover";
                }
              }
            }
          }
        }
      }
    }

    // ip nat
    container nat {
      tailf:info "NAT configuration commands";

      // ip nat settings
      container settings {
        tailf:info "NAT general settings";

        // ip nat settings mode
        leaf mode {
          tailf:info "NAT operating mode";
          type enumeration {
            enum cgn {
              tailf:info "The carrier grade NAT (CGN) operating mode";
            }
            enum "default" {
              tailf:info "The default NAT operating mode";
            }
          }
          default "default";
        }
      }

      // ip nat translation
      container translation {
        tailf:info "NAT translation entry configuration";

        // ip nat translation finrst-timeout
        leaf finrst-timeout {
          tailf:info "Specify timeout for NAT TCP flows after a FIN or RST";
          type union {
            type uint32 {
              tailf:info "<0-536870>;;Timeout in seconds";
              range "0..536870";
            }
            type enumeration {
              enum never {
                tailf:info "Never timeout";
              }
            }
          }
        }

        // ip nat translation icmp-timeout
        leaf icmp-timeout {
          tailf:info "Specify timeout for NAT ICMP flows";
          type union {
            type uint32 {
              tailf:info "<0-536870>;;Timeout in seconds";
              range "0..536870";
            }
            type enumeration {
              enum never {
                tailf:info "Never timeout";
              }
            }
          }
        }

        // ip nat translation tcp-timeout
        leaf tcp-timeout {
          tailf:info "Specify timeout for NAT TCP flows";
          type union {
            type uint32 {
              tailf:info "<0-536870>;;Timeout in seconds";
              range "0..536870";
            }
            type enumeration {
              enum never {
                tailf:info "Never timeout";
              }
            }
          }
        }

        // ip nat translation max-entries
        container max-entries {
          tailf:info "Specify maximum number of NAT entries";

          // ip nat translation max-entries all-host
          leaf all-host {
            tailf:info "Specify maximum number of NAT entries for each host";
            type uint32 {
              tailf:info "<1-2147483647>;;Number of entries";
              range "1..2147483647";
            }
          }

          // ip nat translation max-entries vrf *
          list vrf {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            key name;
            leaf name {
              type string {
                tailf:info "Specify per-VRF NAT entry limit";
              }
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Number of entries";
                range "1..2147483647";
              }
            }
          }

          // ip nat translation max-entries list
          container "list" {
            tailf:info "Specify access list based NAT entry limit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf access-list {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type exp-ip-acl-type;
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Number of entries";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat service
      container service {
        tailf:info "Special translation for application using non-standard port";
        container list-ftp-tcp {
          tailf:cli-drop-node-name;
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "access-list port";
            leaf access-list {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global addresses";
                }
                type string {
                  tailf:info "WORD;;Access list name for server local address";
                }
              }
            }
            leaf ftp {
              tailf:info "ftp protocol";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type empty;
            }
            leaf tcp {
              tailf:info "TCP protocol";
              tailf:cli-prefix-key {
                tailf:cli-before-key 2;
              }
              type empty;
            }
            leaf port {
              tailf:info "Special non-standard port";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-65535>;;Port number";
                range "1..65535";
              }
            }
          }
        }
      }

      // ip nat pool *
      list pool {
        tailf:info "Define pool of addresses";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;Pool name";
          }
        }
        leaf start-address {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Start IP address";
          }
        }
        leaf end-address {
          tailf:cli-drop-node-name;
          when "../start-address" {
            tailf:dependency "../start-address";
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;End IP address";
          }
        }
        choice prefix-choice {
          leaf netmask {
            tailf:info "Specify the network mask";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Network mask";
            }
          }
          leaf prefix-length {
            tailf:info "Specify the prefix length";
            type uint8 {
              tailf:info "<1-32>;;Prefix length";
              range "1..32";
            }
          }
        }
        leaf accounting {
          tailf:cli-optional-in-sequence;
          tailf:info "Specify the accounting";
          type string {
            tailf:info "WORD;;Accounting method-list name";
          }
        }
        choice nat-choice {
          leaf arp-ping {
            tailf:info "WLAN ARP Ping";
            type empty;
          }
          leaf "type" {
            tailf:info "Specify the pool type";
            type enumeration {
              enum match-host {
                tailf:info "Keep host numbers the same after translation";
              }
              enum rotary {
                tailf:info "Rotary address pool";
              }
            }
          }
          leaf add-route {
            tailf:info "Add special route to Virtual Interface";
            type empty;
          }
        }
      }

      // ip nat inside
      container inside {
        tailf:info "Inside address translation";

        // ip nat inside source
        container source {
          tailf:info "Source address translation";

          // ip nat inside source list *
          list "list" {
            tailf:info "Specify access list describing local addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            uses ip-nat-inside-grouping;
            uses ip-nat-inside-options-grouping;
          }

          // ip nat inside source list * vrf *
          container list-vrf {
            tailf:cli-drop-node-name;
            list "list" {
              tailf:info "Specify access list describing local addresses";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              key "id vrf";
              leaf id {
                type union {
                  type uint16 {
                    tailf:info "<1-2699>;;Access list number for global "
                      +"addresses";
                    range "1..2699";
                  }
                  type string {
                    tailf:info "WORD;;Access list name for global addresses";
                  }
                }
              }
              uses ip-nat-inside-vrf-grouping;
              uses ip-nat-inside-options-grouping;
            }
          }

          // ip nat inside source static
          container static {
            tailf:info "Specify static local->global mapping";

            // ip nat inside source static a.b.c.d a.b.c.d
            list nat-static-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "local-ip global-ip";
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static a.b.c.d a.b.c.d vrf z
            list nat-static-address-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "local-ip global-ip vrf";
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x a.b.c.d y
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto local-ip local-port global-ip global-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x a.b.c.d y vrf z
            list nat-static-transport-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto local-ip local-port global-ip global-port vrf";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat inside source static tcp|udp a.b.c.d x
            list nat-static-transport-interface-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "proto local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Inside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              container interface {
                tailf:info "Specify interface for global address";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
              leaf global-port {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
            }
          }

          // ip nat inside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            uses ip-nat-inside-grouping;
            uses ip-nat-inside-options-grouping;
          }

          // ip nat inside source route-map * vrf *
          container route-map-vrf {
            tailf:cli-drop-node-name;
            list route-map {
              tailf:info "Specify route-map";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              key "id vrf";
              leaf id {
                type string {
                  tailf:info "WORD;;Route-map name";
                }
              }
              uses ip-nat-inside-vrf-grouping;
              uses ip-nat-inside-options-grouping;
            }
          }
        }

        // ip nat inside destination
        container destination {
          tailf:info "Destination address translation";

          // ip nat inside destination list *
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            // ip nat inside destination list * pool *
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../../../ip/nat/pool/id";
              }
              type string {
                tailf:info "WORD;;Pool name for local addresses ";
              }
            }
            // [ redundancy redundancy-id ]
            leaf redundancy {
              tailf:info "NAT redundancy operation";
              tailf:cli-optional-in-sequence;
              type uint8 {
                tailf:info "<1-2>;;IP redundancy ID";
                range "1..2";
              }
            }
            // [ mapping-id map-id ]
            leaf mapping-id {
              tailf:info "Associate a mapping id to this mapping";
              type uint32 {
                tailf:info "<1-2147483647>;;Stateful NAT mapping id";
                range "1..2147483647";
              }
            }
          }
        }
      }

      // ip nat outside
      container outside {
        tailf:info "Outside address translation";

        // ip nat outside source
        container source {
          tailf:info "Source address translation";

          // ip nat outside source list *
          list "list" {
            tailf:info "Specify access list describing global addresses";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type union {
                type uint16 {
                  tailf:info "<1-2699>;;Access list number for global "
                    +"addresses";
                  range "1..2699";
                }
                type string {
                  tailf:info "WORD;;Access list name for global addresses";
                }
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../../../ip/nat/pool/id";
              }
              type string {
                tailf:info "WORD;;Pool name for local addresses ";
              }
            }
            uses ip-nat-outside-source-grouping;
          }

          // ip nat outside source list * pool * vrf *
          container list-vrf {
            tailf:cli-drop-node-name;
            list "list" {
              tailf:info "Specify access list describing local addresses";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              key "id vrf";
              leaf id {
                type union {
                  type uint16 {
                    tailf:info "<1-2699>;;Access list number for global "
                      +"addresses";
                    range "1..2699";
                  }
                  type string {
                    tailf:info "WORD;;Access list name for global addresses";
                  }
                }
              }
              leaf pool {
                tailf:info "Name pool of local addresses";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                tailf:non-strict-leafref {
                  path "../../../../../../../ip/nat/pool/id";
                }
                type string {
                  tailf:info "WORD;;Pool name for local addresses ";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-outside-source-grouping;
            }
          }

          // ip nat outside source route-map *
          list route-map {
            tailf:info "Specify route-map";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key id;
            leaf id {
              type string {
                tailf:info "WORD;;Route-map name";
              }
            }
            leaf pool {
              tailf:info "Name pool of local addresses";
              tailf:non-strict-leafref {
                path "../../../../pool/id";
              }
              type string {
                tailf:info "WORD;;Pool Name";
              }
            }
            uses ip-nat-outside-source-grouping;
          }

          // ip nat outside source route-map * pool * vrf *
          container route-map-vrf {
            tailf:cli-drop-node-name;
            list route-map {
              tailf:info "Specify route-map";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "id vrf";
              leaf id {
                type string {
                  tailf:info "WORD;;Route-map name";
                }
              }
              leaf pool {
                tailf:info "Name pool of local addresses";
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                tailf:non-strict-leafref {
                  path "../../../../../pool/id";
                }
                type string {
                  tailf:info "WORD;;Pool Name";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-outside-source-grouping;
            }
          }

          // ip nat outside source static
          container static {
            tailf:info "Specify static global->local mapping";

            // ip nat outside source static a.b.c.d a.b.c.d
            list nat-static-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "global-ip local-ip";
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static a.b.c.d a.b.c.d vrf z
            list nat-static-address-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "global-ip local-ip";
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static tcp|udp a.b.c.d x a.b.c.d y
            list nat-static-transport-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto global-ip global-port local-ip local-port";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              uses ip-nat-source-static-grouping;
            }

            // ip nat outside source static tcp|udp a.b.c.d x a.b.c.d y vrf z
            list nat-static-transport-list-vrf {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key "proto global-ip global-port local-ip local-port vrf";
              leaf proto {
                type enumeration {
                  enum tcp {
                    tailf:info "Transmission Control Protocol";
                  }
                  enum udp {
                    tailf:info "User Datagram Protocol";
                  }
                }
              }
              leaf global-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside global IP address";
                }
              }
              leaf global-port {
                type uint16 {
                  tailf:info "<1-65535>;;Global UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf local-ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Outside local IP address";
                }
              }
              leaf local-port {
                type uint16 {
                  tailf:info "<1-65535>;;Local UDP/TCP port";
                  range "1..65535";
                }
              }
              leaf vrf {
                tailf:info "Specify vrf";
                tailf:cli-expose-key-name;
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;vrf name";
                }
              }
              uses ip-nat-source-static-grouping;
            }
          }
        }
      }
    }

    // ip route
    container route {
      tailf:info "Establish static routes";

      // ip route static
      container static {
        tailf:info "Allow static routes";

        // ip route static adjust-time
        leaf adjust-time {
          tailf:info "Time period for adjusting static routes";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-60>;;Adjustment time in seconds";
            range "1..60";
          }
        }

        // no ip route static inter-vrf
        leaf inter-vrf {
          tailf:info "Across VRF interfaces";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // ip route static bfd *
        container bfd {
          tailf:info "BFD tracked";
          list ip-route-bfd-forwarding-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "interface ip-address";
            leaf interface {
              tailf:cli-diff-dependency "../../../../../../interface";
              type string {
                tailf:info "WORD;;Interface name";
              }
            }
            leaf ip-address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Gateway IP address";
                }
                type enumeration {
                  enum multicast {
                    tailf:info "multicast route";
                  }
                }
              }
            }
            leaf group {
              tailf:info "assign a bfd group";
              type string {
                tailf:info "WORD;;bfd group name";
              }
            }
          }
        }

        // ip route static install-routes-recurse-via-nexthop
        leaf install-routes-recurse-via-nexthop {
          tailf:info "installing recursive route next hop";
          type empty;
        }

        // ip route static install-routes-recurse-via-nexthop vrf *
        container install-routes-recurse-via-nexthop-vrf {
          tailf:cli-drop-node-name;
          container install-routes-recurse-via-nexthop {
            tailf:info "installing recursive route next hop";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;
            list vrf {
              tailf:info "Configure static route for a VPN Routing/Forwarding instance";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
            }
          }
        }
      }

      // ip route profile
      leaf profile {
        tailf:info "Enable IP routing table profile";
        tailf:cli-full-command;
        type empty;
      }

      // ip route *
      uses ip-route-grouping {
        refine "ip-route-interface-forwarding-list/interface" {
          tailf:cli-diff-dependency "../../../../interface";
        }
        refine "ip-route-interface-list/interface" {
          tailf:cli-diff-dependency "../../../../interface";
        }
      }

      // ip route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "/ios:interface";
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ip-route-grouping {
          refine "ip-route-interface-forwarding-list/interface" {
            tailf:cli-diff-dependency "../../../../../interface";
          }
          refine "ip-route-interface-list/interface" {
            tailf:cli-diff-dependency "../../../../../interface";
          }
        }
      }
    }

    // ip explicit-path
    container explicit-path {
      tailf:info "Configure explicit-path";

      // ip explicit-path identifier *
      list identifier {
        tailf:info "Specify explicit path by number";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key number;
        leaf number {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Enter number";
            range "1..65535";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        uses ip-explicit-path-grouping;
      }

      // ip explicit-path name *
      list name {
        tailf:info "Specify explicit path by name";
        tailf:cli-mode-name "cfg-ip-expl-path";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Enter name";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum enable {
              tailf:info "enable the explicit path";
            }
            enum disable {
              tailf:info "disable the explicit path";
            }
          }
        }
        uses ip-explicit-path-grouping;
      }
    }

    // ip tacacs
    container tacacs {
      tailf:info "TACACS configuration commands";
      container source-interface {
        tailf:info "Specify interface for source address in "+
          "TACACS packets";
        uses interface-name-grouping;
      }
    }

    // ip access-list
    container access-list {
      tailf:info "Named access list";
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-diff-dependency "../../object-group";

      // ip access-list logging
      container logging {
        tailf:info "Control access list logging";

        // ip access-list logging interval
        leaf interval {
          tailf:info "Set access list logging interval";
          type uint32 {
            tailf:info "<0-2147483647>;;Access list logging interval "+
              "(milliseconds)";
            range "0..2147483647";
          }
        }

        // ip access-list logging hash-generation
        leaf hash-generation {
          tailf:info "Enable syslog hash code generation";
          type empty;
        }
      }

      // ip access-list persistent
      leaf persistent {
        tailf:info "enable persistency across reload";
        tailf:cli-full-command;
        type empty;
      }

      // ip access-list standard *
      container standard {
        when "not(../../../tailfned/api/new-ip-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
        }
        tailf:info "Standard Access List";
        tailf:cli-incomplete-command;
        list std-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name "config-std-nacl";
          key name;
          leaf name {
            type std-ip-acl-type;
          }
          list std-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-multi-word-key;
              tailf:cli-diff-dependency "../../../../../../object-group";
              type string {
                tailf:info "deny;;Specify packets to reject\n"+
                  "permit;;Specify packets to forwards\n"+
                  "remark;;Access list entry comment";
                pattern "(permit .*)|(deny .*)|(remark .*)|([0-9]+.*)"+
                  "|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }

      // ip access-list extended *
      container extended {
        when "not(../../../tailfned/api/new-ip-access-list)" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
        }
        tailf:info "Extended Access List";
        tailf:cli-incomplete-command;
        list ext-named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-ext-nacl";
          tailf:cli-full-command;
          tailf:cli-explicit-exit;
          key name;
          leaf name {
            type ext-acl-type;
          }
          list ext-access-list-rule {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-drop-node-name;
            tailf:cli-compact-syntax;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key rule;
            leaf rule {
              tailf:cli-multi-word-key;
              tailf:cli-diff-dependency "../../../../../../object-group";
              type string {
                tailf:info "deny;;Specify packets to reject\n"+
                  "permit;;Specify packets to forwards\n"+
                  "remark;;Access list entry comment";
                pattern "(permit .*)|(deny .*)|(remark .*)|([0-9]+.*)"+
                  "|(dynamic .*)|(evaluate .*)";
              }
            }
          }
        }
      }

      // ip access-list *
      list filter-list {
        when "../../../tailfned/api/new-ip-access-list" {
          tailf:dependency "../../../tailfned/api/new-ip-access-list";
        }
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-nacl";
        tailf:cli-no-key-completion;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../persistent";
        key name;
        leaf name {
          tailf:cli-suppress-range;
          type string {
            tailf:info "WORD;;Access-list name or number";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum standard {
              tailf:info "Standard Access List";
            }
            enum extended {
              tailf:info "Extended Access List";
            }
          }
        }
        list entry-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-remove-before-change;
          tailf:cli-incomplete-command;
          key seq;
          leaf seq {
            tailf:cli-suppress-range;
            type uint32 {
              tailf:info "<1-2147483647>;;Sequence Number";
              range "1..2147483647";
            }
          }
          leaf entry {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            tailf:cli-diff-dependency "../../../../../object-group";
            type string {
              tailf:info "WORD;;deny | permit | remark | dynamic | evaluate ACL entry";
              pattern "(permit .*)|(deny .*)|(remark .*)|(dynamic .*)|(evaluate .*)";
            }
          }
        }
      }
    }

    // ip prefix-list
    container prefix-list {
      tailf:info "Build a prefix list";

      // no ip prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ip prefix-list * seq *
      list prefixes {
        when "not(../sequence-number) or (../sequence-number = 'true')" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-dependency "../sequence-number";
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ip prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }

          // ip prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                tailf:info "<1-32>;;Minimum prefix length";
                range "1..32";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-32>;;Maximum prefix length";
                range "1..32";
              }
            }
          }

          // ip prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv4-prefix {
                tailf:info "A.B.C.D;;IP prefix <network>/<length>, e.g., 35.0.0.0/8";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint8 {
                tailf:info "<1-32>;;Minimum prefix length";
                range "1..32";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-32>;;Maximum prefix length";
                range "1..32";
              }
            }
          }
        }
      }

      // ip prefix-list *
      list prefixes-no-seq {
        when "../sequence-number = 'false'" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-dependency "../sequence-number";
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ip prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ip prefix-list *
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;permit <entry> | deny <entry>";
              pattern "(deny .*)|(permit .*)";
            }
          }
        }
      }
    }

    // ip radius
    container radius {
      tailf:info "RADIUS configuration commands";

      // ip radius source-interface
      container source-interface {
        tailf:info "Specify interface for source address in RADIUS packets";
        uses interface-name-grouping;
      }

      // ip radius source-interface * vrf *
      container source-interface-vrf {
        tailf:cli-drop-node-name;
        list source-interface {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-diff-dependency "../../../../interface";
          key vrf;
          leaf name {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf vrf {
            tailf:info "VPN Routing/Forwarding parameters";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;Table name";
            }
          }
        }
      }
    }

    // ip sla
    container sla {
      tailf:info "IP Service Level Agreement";
      tailf:cli-diff-dependency "../../ethernet/evc";
      tailf:cli-diff-dependency "../../ethernet/cfm/domain";

      // ip sla auto discovery
      container auto {
        tailf:info "IP SLAs Auto Configuration";
        leaf discovery {
          tailf:info "Enable auto-discovery";
          type empty;
        }
      }

      // ip sla responder twamp
      container responder-twamp {
        tailf:cli-drop-node-name;
        container responder {
          tailf:info "Enable IP SLAs Responder";
          container twamp {
            tailf:info "Setup TWAMP responder";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-twamp-ref";
            presence true;

            // ip sla responder twamp / timeout
            leaf timeout {
              tailf:info "Inactivity timeout period";
              type uint32 {
                tailf:info "<1-604800>;;Inactivity timeout value in seconds";
                range "1..604800";
              }
            }
          }
        }
      }

      // ip sla responder
      container responder {
        tailf:info "Enable IP SLAs Responder";
        presence true;
      }

      // ip sla responder udp-echo
      container responder-udp-echo {
        tailf:cli-drop-node-name;
        container responder {
          tailf:info "Enable IP SLAs Responder";
          container udp-echo {
            tailf:info "Setup udp-echo responder";
            tailf:cli-compact-syntax;
            leaf ipaddress {
              tailf:info "Permanent address";
              type inet:host {
                tailf:info "WORD;;IP Address or IP HostName";
              }
            }
            leaf port {
              tailf:info "Permanent port";
              type uint16 {
                tailf:info "<1-65535>;;Port Number (Recommended ports greater than 1023)";
                range "1..65535";
              }
            }
          }
        }
      }

      // ip sla server twamp
      container server {
        tailf:info "IPPM server configuration";
        container twamp {
          tailf:info "IPPM TWAMP server configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-twamp-srvr";
          presence true;

          // ip sla server twamp / port
          leaf port {
            tailf:info "Port on which to listen";
            type uint16 {
              tailf:info "<1-65535>;;Max port value";
              range "1..65535";
            }
            default 862;
          }

          // ip sla server twamp / timer inactivity
          container timer {
            tailf:info "Timer configurations";
            leaf inactivity {
              tailf:info "Inactivity timer";
              type uint16 {
                tailf:info "<1-6000>;;Max number of inactive seconds";
                range "1..6000";
              }
            }
          }
        }
      }

      // ip sla logging traps
      container logging {
        tailf:info "Enable Syslog";
        leaf traps {
          tailf:info "Enable syslog traps";
          type empty;
        }
      }

      // ip sla key-chain
      leaf key-chain {
        tailf:info "Use MD5 Authentication for IP SLAs Control Messages";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of key-chain";
        }
      }

      // ip sla *
      list ip-sla-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-ip-sla";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry Number";
            range "1..2147483647";
          }
        }

        // ip sla * / tcp-connect
        list tcp-connect {
          tailf:info "TCP Connect Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "destination destination-port";
          leaf destination {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address or hostname, broadcast disallowed";
            }
          }
          leaf destination-port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number (Recommended ports greater than 1023)";
            }
          }

          // ip sla * / tcp-connect * source-ip
          leaf source-ip {
            tailf:info "Source address";
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }

          // ip sla * / tcp-connect * source-port
          leaf source-port {
            tailf:info "Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }

          // ip sla * / tcp-connect * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
            default enable;
          }
        }

        // ip sla * / udp-jitter *
        list udp-jitter {
          tailf:info "UDP Jitter Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "destination destination-port";
          leaf destination {
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }
          leaf destination-port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number.";
            }
          }

          // ip sla * / udp-jitter * source-ip
          leaf source-ip {
            tailf:info "Source address";
            type inet:host {
              tailf:info "WORD;;Hostname or X:X:X:X::X or A.B.C.D address";
            }
          }

          // ip sla * / udp-jitter * source-port
          leaf source-port {
            tailf:info "Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }

          // ip sla * / udp-jitter * num-packets
          leaf num-packets {
            tailf:info "Number of Packets to be transmitted";
            type uint16 {
              tailf:info "<1-60000>;;Number of Packets (default 10)";
              range "1..60000";
            }
            default 10;
          }

          // ip sla * / udp-jitter * codec
          leaf codec {
            tailf:info "codec type to be configured";
            type enumeration {
              enum g711alaw {
                tailf:info "G.711 A Law 64000 bps";
              }
              enum g711ulaw {
                tailf:info "G.711 U Law 64000 bps";
              }
              enum g729a {
                tailf:info "G.729 8000 bps";
              }
            }
          }

          // ip sla * / udp-jitter * codec-numpackets
          leaf codec-numpackets {
            tailf:info "Number of Packets to be transmitted";
            when "../codec" {
              tailf:dependency "../codec";
            }
            type uint32 {
              tailf:info "<1-60000>;;Number of Packets";
              range "1..60000";
            }
          }

          // ip sla * / udp-jitter * interval
          leaf interval {
            tailf:info "Inter Packet Interval";
            type uint32 {
              tailf:info "<4-60000>;;Delay (default 20)";
            }
            default 20;
          }

          // ip sla * / udp-jitter * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
            default enable;
          }
        }

        // ip sla * / icmp-echo *
        list icmp-echo {
          tailf:info "ICMP Echo Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key host;
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D  Destination IP address "+
                "or hostname, broadcast disallowed";
            }
          }
          choice source-choice {
            // ip sla * / icmp-echo * source-interface
            container source-interface {
              tailf:info "Source Interface (ingress icmp packet interface)";
              tailf:cli-flatten-container;
              uses interface-name-grouping;
            }
            // ip sla * / icmp-echo * source-ip
            leaf source-ip {
              tailf:info "Source Address";
              type inet:host {
                tailf:info "Hostname or A.B.C.D;;"+
                  "IP address or hostname, broadcast disallowed";
              }
            }
          }
        }

        // ip sla * / udp-echo *
        list udp-echo {
          tailf:info "UDP Echo Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "host port";
          leaf host {
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;Destination IP address "+
                "or hostname, broadcast disallowed";
            }
          }
          leaf port {
            type uint16 {
              tailf:info "<0-65535>;;Port Number";
            }
          }
          // ip sla * / udp-echo * control
          leaf control {
            tailf:info "Enable or disable control packets";
            type enumeration {
              enum disable {
                tailf:info "Disable control packets exchange";
              }
              enum enable {
                tailf:info "Enable control packets exchange (default)";
              }
            }
          }
          // ip sla * / udp-echo * source-ip
          leaf source-ip {
            tailf:info "Source Address";
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;"+
                "IP address or hostname, broadcast disallowed";
            }
          }
          // ip sla * / udp-echo * source-port
          leaf source-port {
            tailf:info "source-port;;Source Port";
            type uint16 {
              tailf:info "<1-65535>;;Port Number";
              range "1..65535";
            }
          }
        }

        // ip sla * / ethernet
        container ethernet {
          tailf:info "Ethernet Operations";

          // ip sla * / ethernet echo * mpid * domain *
          // ip sla * / ethernet jitter * mpid * domain *
          list ethernet-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key "type mpid domain";
            leaf "type" {
              type enumeration {
                enum jitter {
                  tailf:info "Ethernet Jitter Operation";
                }
                enum echo {
                  tailf:info "Ethernet Echo Operation (802.1ag Loopback)";
                }
              }
            }
            leaf mpid {
              tailf:info "Maintenance Point ID";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-8191>;;MPID Value";
                range "1..8191";
              }
            }
            leaf domain {
              tailf:info "Domain Name";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Domain Name Value";
              }
            }
            choice vlan-or-port {
              leaf port {
                tailf:info "DOWN service direction with no vlan association";
                type empty;
              }
              leaf vlan {
                tailf:info "VLAN ID";
                type uint16 {
                  tailf:info "<1-65535>;;VLAN ID";
                  range "1..65535";
                }
              }
            }
          }

          // ip sla * / ethernet y1731
          container y1731 {
            tailf:info "Y1731 Ethernet OAM Performance Measurement Operations";

            // ip sla * / ethernet y1731 delay *
            list delay {
              tailf:info "Y1731 Delay and Delay Variation Operation";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key name;
              leaf name {
                type enumeration {
                  enum "1DM" {
                    tailf:info "1DM frames";
                  }
                  enum DMM {
                    tailf:info "DMM/DMR frames";
                  }
                  enum DMMv1 {
                    tailf:info "DMMv1 frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * burst
              leaf burst {
                tailf:info "enable bursting of delay frames";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 delay * domain
              leaf domain {
                tailf:info "Specify Domain name";
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              choice evc-or-vlan {
                // ip sla * / ethernet y1731 delay * evc
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  type string {
                    tailf:info "WORD;;Specify the EVC Identifier value";
                  }
                }
                // ip sla * / ethernet y1731 delay * vlan
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * mac-address
              // ip sla * / ethernet y1731 delay * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 delay * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 delay * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 delay * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 delay * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 delay receive *
            container delay-receive {
              tailf:cli-drop-node-name;
              container delay {
                tailf:info "Y1731 Delay and Delay Variation Operation";
                list receive {
                  tailf:info "Receive only operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key name;
                  leaf name {
                    type enumeration {
                      enum "1DM" {
                        tailf:info "1DM frames";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * domain
                  leaf domain {
                    tailf:info "Specify Domain name";
                    type string {
                      tailf:info "WORD;;Specify the Ethernet OAM domain";
                    }
                  }
                  choice evc-or-vlan {
                    // ip sla * / ethernet y1731 delay receive * evc
                    leaf evc {
                      tailf:info "Specify the Ethernet Virtual Circuit "+
                        "Identifier";
                      type string {
                        tailf:info "WORD;;Specify the EVC Identifier value";
                      }
                    }
                    // ip sla * / ethernet y1731 delay receive * vlan
                    leaf vlan {
                      tailf:info "Specify the VLAN";
                      type uint16 {
                        tailf:info "<1-4096>;;Specify Vlan value";
                        range "1..4096";
                      }
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * cos
                  leaf cos {
                    tailf:info "Specify the Class of Service";
                    type uint8 {
                      tailf:info "<0-7>;;Specify CoS value";
                      range "0..7";
                    }
                  }
                  // ip sla * / ethernet y1731 delay receive * mac-address
                  // ip sla * / ethernet y1731 delay receive * mpid
                  choice mpid-or-mac {
                    leaf mac-address {
                      tailf:info "Specify the remote mac-address";
                      type string {
                        tailf:info "H.H.H;;Destination mac-address value";
                      }
                    }
                    leaf mpid {
                      tailf:info "Specify the remote MPID";
                      type uint16 {
                        tailf:info "<1-8191>;;Specify MPID value";
                        range "1..8191";
                      }
                    }
                  }
                }
              }
            }

            // ip sla * / ethernet y1731 loss *
            list loss {
              tailf:info "Y1731 Loss Operation";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key name;
              leaf name {
                type enumeration {
                  enum LMM {
                    tailf:info "LMM/LMR frames";
                  }
                  enum SLM {
                    tailf:info "SLM/SLR frames";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * burst
              leaf burst {
                tailf:info "enable bursting of SLM frames";
                tailf:cli-optional-in-sequence;
                type empty;
              }
              // ip sla * / ethernet y1731 loss * domain
              leaf domain {
                tailf:info "Specify Domain name";
                type string {
                  tailf:info "WORD;;Specify the Ethernet OAM domain";
                }
              }
              // ip sla * / ethernet y1731 loss * evc
              // ip sla * / ethernet y1731 loss * vlan
              choice evc-or-vlan {
                leaf evc {
                  tailf:info "Specify the Ethernet Virtual Circuit Identifier";
                  type string {
                    tailf:info "WORD;;Specify the EVC Identifier value";
                  }
                }
                leaf vlan {
                  tailf:info "Specify the VLAN";
                  type uint16 {
                    tailf:info "<1-4096>;;Specify Vlan value";
                    range "1..4096";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * mac-address
              // ip sla * / ethernet y1731 loss * mpid
              choice mpid-or-mac {
                leaf mac-address {
                  tailf:info "Specify the remote mac-address";
                  type string {
                    tailf:info "H.H.H;;Destination mac-address value";
                  }
                }
                leaf mpid {
                  tailf:info "Specify the remote MPID";
                  type uint16 {
                    tailf:info "<1-8191>;;Specify MPID value";
                    range "1..8191";
                  }
                }
              }
              // ip sla * / ethernet y1731 loss * cos
              leaf cos {
                tailf:info "Specify the Class of Service";
                type uint8 {
                  tailf:info "<0-7>;;Specify CoS value";
                  range "0..7";
                }
              }
              // ip sla * / ethernet y1731 loss * source
              container source {
                tailf:info "Specify the local MPID or MAC-Address";
                tailf:cli-flatten-container;
                choice mpid-or-mac {
                  // ip sla * / ethernet y1731 loss * source mac-address
                  leaf mac-address {
                    tailf:info "Specify the remote mac-address";
                    type string {
                      tailf:info "H.H.H;;Destination mac-address value";
                    }
                  }
                  // ip sla * / ethernet y1731 loss * source mpid
                  leaf mpid {
                    tailf:info "Specify the remote MPID";
                    type uint16 {
                      tailf:info "<1-8191>;;Specify MPID value";
                      range "1..8191";
                    }
                  }
                }
              }
            }
          }
        }

        // ip sla * / http get
        container http {
          tailf:info "HTTP Operation";
          leaf get {
            tailf:info "HTTP get operation";
            type string {
              tailf:info "WORD;;URL";
            }
          }
        }

        // ip sla * / service-performance * type ethernet
        // ip sla * / service-performance * type ip
        list service-performance {
          tailf:info "Service Performance Operation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key "type";
          leaf "type" {
            tailf:info "Server Performance identifer";
            tailf:cli-expose-key-name;
            type enumeration {
              enum ethernet {
                tailf:info "Service Performance Ethernet";
              }
              enum ip {
                tailf:info "Service Performance IP";
              }
            }
          }
          leaf dest-mac-addr {
            when "../type = 'ethernet'" {
              tailf:dependency "../type";
            }
            tailf:info "Specify the remote mac-address";
            type string {
              tailf:info "H.H.H;;Remote mac-address value";
            }
          }
          leaf dest-ip-addr {
            when "../type = 'ip'" {
              tailf:dependency "../type";
            }
            tailf:info "Specify the target ip";
            type inet:host {
              tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Destination IPv6/IP address or hostname";
            }
          }
          leaf vrf {
            when "../type = 'ip'" {
              tailf:dependency "../type";
            }
            tailf:info "Configure an VRF";
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-4096>;;VRF Id";
              range "1..4096";
            }
          }
          container interface {
            tailf:info "Interface Name";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
          container service {
            tailf:info "Specify the Service Instance";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf instance {
              tailf:info "Specify the Service Instance";
              type uint16 {
                tailf:info "<1-4096>;;Service-Instance value";
                range "1..4096";
              }
            }
          }
          leaf ethernet {
            tailf:info "Configure an Ethernet Instance";
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
        }


        // ip sla * / description
        uses description-grouping;

        // ip sla * / tos
        leaf tos {
          tailf:info "Type Of Service";
          type uint8 {
            tailf:info "<0-255>;;Type of Service Value";
          }
        }

        // ip sla * / verify-data
        leaf verify-data {
          tailf:info "Verify data";
          type empty;
        }

        // ip sla * / data-pattern
        leaf data-pattern {
          tailf:info "Data Pattern";
          type string {
            tailf:info "WORD;;Data Pattern in Hex";
            pattern "[a-fA-F0-9].*";
          }
        }

        // ip sla * / vrf
        leaf vrf {
          tailf:info "Configure IP SLAs for a VPN Routing/Forwarding instance";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ip sla * / owner
        leaf owner {
          tailf:info "Owner of Entry";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Owner String";
          }
        }

        // ip sla * / tag
        leaf tag {
          tailf:info "User defined tag";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Tag string";
          }
        }

        // ip sla * / frequency
        container frequency {
          tailf:info "Frequency of an operation";
          leaf seconds {
            tailf:cli-drop-node-name;
            // dep: before this created, must change timeout
            tailf:cli-diff-dependency "../../timeout" {
              tailf:cli-trigger-on-set;
            }
            // dep: before this created, must change threshold
            tailf:cli-diff-dependency "../../threshold" {
              tailf:cli-trigger-on-set;
            }
            type uint32 {
              tailf:info "<1-604800>;;Frequency in seconds (default 60)";
              range "1..604800";
            }
            default 60;
          }
          // ip sla * / frequency time
          leaf time {
            tailf:info "Frequency period";
            type uint32 {
              tailf:info "<20-604800>;;Specify time duration (seconds)";
              range "20..604800";
            }
          }
        }

        // ip sla * / timeout
        leaf timeout {
          tailf:info "Timeout of an operation";
          type uint32 {
            tailf:info "<0-604800000>;;Timeout in milliseconds";
            range "0..604800000";
          }
        }

        // ip sla * / threshold
        leaf threshold {
          tailf:info "Operation threshold in milliseconds";
          type uint16 {
            tailf:info "<0-60000>;;Millisecond threshold value";
            range "0..60000";
          }
        }

        // ip sla * / history
        container history {
          tailf:info "History and Distribution Data";

          // ip sla * / history hours-of-statistics-kept
          leaf hours-of-statistics-kept {
            tailf:info "Maximum number of statistics hour groups to capture";
            type uint8 {
              tailf:info "<0-25>;;Hour groups size value (default 2)";
              range "0..25";
            }
            default 2;
          }

          // ip sla * / history distributions-of-statistics-kept
          leaf distributions-of-statistics-kept {
            tailf:info "Maximum number of statistics distribution buckets "+
              "to capture";
            type uint8 {
              tailf:info "<1-20>;;Distribution bucket size value (default 1)";
              range "1..20";
            }
            default 1;
          }

          // ip sla * / history statistics-distribution-interval
          leaf statistics-distribution-interval {
            tailf:info "Statistics distribution interval size";
            type uint8 {
              tailf:info "<1-100>;;Distribution interval value (default 20)";
              range "1..100";
            }
            default 20;
          }

          // ip sla * / history lives-kept
          leaf lives-kept {
            tailf:info "Maximum number of history lives to collect";
            type uint8 {
              tailf:info "<0-2>;;Life size value (default 0)";
              range "0..2";
            }
            default 0;
          }

          // ip sla * / history buckets-kept
          leaf buckets-kept {
            tailf:info "Maximum number of history buckets to collect";
            type uint8 {
              tailf:info "<1-60>;;Bucket size value (default 15)";
              range "1..60";
            }
            default 15;
          }

          // ip sla * / history filter
          leaf filter {
            tailf:info "Add operation to History when...";
            type enumeration {
              enum all {
                tailf:info "Collect every operation in History";
              }
              enum failures {
                tailf:info "Collect operations that fail in History";
              }
              enum none {
                tailf:info "Shutoff History collection";
              }
              enum overThreshold {
                tailf:info "Collect operations that are over threshold in History";
              }
            }
          }

          // ip sla * / history enhanced
          container enhanced {
            tailf:info "Enable enhanced history collection";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf interval {
              tailf:info "Aggregation interval";
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-3600>;;Interval in seconds";
                range "1..3600";
              }
            }
            leaf buckets {
              tailf:info "Number of buckets to collect data";
              type uint8 {
                tailf:info "<1-100>;;Number of buckets";
                range "1..100";
              }
            }
          }

          // ip sla * / history interval
          leaf interval {
            tailf:info "Specify number of intervals";
            type uint8 {
              tailf:info "<1-10>;;Number of intervals to store";
              range "1..10";
            }
          }
        }

        // ip sla * / duration
        container duration {
          tailf:info "Service Performance duration configuration";
          leaf time {
            tailf:info "Time based duration";
            type uint32 {
              tailf:info "<1-86400>;;Specify time duration in seconds";
              range "1..86400";
            }
          }
        }

        // ip sla * / measurement-type
        list measurement-type {
          tailf:info "Measurement";
          tailf:cli-mode-name "config-sla-service-performance-measurement";
          key direction;
          leaf direction {
            tailf:cli-expose-key-name;
            tailf:info "Measurement direction";
            type enumeration {
              enum internal {
                tailf:info "internal direction";
              }
              enum external {
                tailf:info "external direction";
              }
            }
          }

          // ip sla * / service-performance * type ethernet / measurement-type / delay
          leaf delay {
            tailf:info "Delay measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / jitter
          leaf jitter {
            tailf:info "Jitter measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / loss
          leaf loss {
            tailf:info "loss measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / receive
          leaf receive {
            tailf:info "Received bytes/packets measurement";
            type empty;
          }

          // ip sla * / service-performance * type ethernet / measurement-type / throughput
          leaf throughput {
            tailf:info "Througput measurement";
            type empty;
          }
        }

        // ip sla * / profile
        container profile {
          tailf:info "Service Performance Profile";

          // ip sla * / profile packet
          container packet {
            tailf:info "Packet Profiles";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-sla-service-performance-packet";

            // ip sla * / profile packet / inner-cos
            leaf inner-cos {
              tailf:info "Inner COS";
              type uint8 {
                tailf:info "<0-7>;;COS value";
                range "0..7";
              }
            }

            // ip sla * / profile packet / outer-cos
            leaf outer-cos {
              tailf:info "Outer COS";
              type uint8 {
                tailf:info "<0-7>;;COS value";
                range "0..7";
              }
            }

            // ip sla * / profile packet / inner-vlan
            leaf inner-vlan {
              tailf:info "Specify the Inner VLAN";
              type uint16 {
                tailf:info "<1-4094>;;Specify Vlan value";
                range "1..4094";
              }
            }

            // ip sla * / profile packet / outer-vlan
            leaf outer-vlan {
              tailf:info "Specify the Outer VLAN";
              type uint16 {
                tailf:info "<1-4094>;;Specify Vlan value";
                range "1..4094";
              }
            }

            // ip sla * / profile packet / source-ip-addr
            leaf source-ip-addr {
              tailf:info "ip address";
              tailf:cli-full-command;
              type inet:host {
                tailf:info "Hostname or A.B.C.D/X:X:X:X::X;;Source IPv6/IP address or hostname";
              }
            }

            // ip sla * / profile packet / packet-size
            leaf packet-size {
              tailf:info "Packet Size";
              type enumeration {
                enum 1024 {
                  tailf:info "1024 byte";
                }
                enum 128 {
                  tailf:info "128 byte";
                }
                enum 1280 {
                  tailf:info "1280 byte";
                }
                enum 1518 {
                  tailf:info "1518 byte";
                }
                enum 256 {
                  tailf:info "256 byte";
                }
                enum 512 {
                  tailf:info "512 byte";
                }
                enum 64 {
                  tailf:info "64 byte";
                }
                enum 9216 {
                  tailf:info "9216 byte";
                }
                enum imix {
                  tailf:info "Imix packet size";
                }
              }
            }

            // ip sla * / profile packet / src-mac-addr
            leaf src-mac-addr {
              tailf:info "The source mac-address";
              type string {
                tailf:info "H.H.H;;Source mac-address value";
              }
            }
          }

          // ip sla * / profile traffic *
          list traffic {
            tailf:info "Service Performance traffic profile";
            tailf:cli-mode-name "config-sla-service-performance-traffic";
            key direction;
            leaf direction {
              tailf:info "Traffic direction";
              tailf:cli-expose-key-name;
              type enumeration {
                enum internal {
                  tailf:info "internal direction";
                }
                enum external {
                  tailf:info "external direction";
                }
              }
            }

            // ip sla * / profile traffic / rate-step
            container rate-step {
              tailf:info "Rate Step";
              container kbps {
                tailf:info "Kilobits per second rate";
                tailf:cli-compact-syntax;
                leaf-list step {
                  tailf:cli-drop-node-name;
                  tailf:cli-replace-all;
                  tailf:cli-flat-list-syntax;
                  ordered-by user;
                  type uint32 {
                    tailf:info "<1-1000000>;;Step X (1-10) (Kbps/pps)";
                    range "1..1000000";
                  }
                }
              }
            }
          }
        }

        // ip sla * / cos
        leaf cos {
          tailf:info "Class Of Service";
          type uint8 {
            tailf:info "<0-7>;;Class of Service Value";
            range "0..7";
          }
        }

        // ip sla * / request-data-size
        leaf request-data-size {
          tailf:info "Request data size";
          type uint16 {
            tailf:info "<0-1500>;;Padding size (bytes) in payload";
            range "0..1500";
          }
        }

        // ip sla * / aggregate interval
        container aggregate {
          tailf:info "Aggregate parameters";
          leaf interval {
            tailf:info "Specify interval period";
            type uint16 {
              tailf:info "<1-65535>;;Aggregation period in seconds";
              range "1..65535";
            }
          }
        }

        // ip sla * / availability algorithm
        container availability {
          tailf:info "Specify the availability parameters";
          leaf algorithm {
            tailf:info "Specify the algorithm to use";
            type enumeration {
              enum sliding-window {
                tailf:info "Use a sliding window";
              }
              enum static-window {
                tailf:info "Use a static window";
              }
            }
          }
        }
      }

      // ip sla schedule *
      list schedule {
        tailf:info "IP SLAs Entry Scheduling";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key operation-number;
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }

        // ip sla schedule * life
        leaf life {
          tailf:info "Length of time to execute in seconds";
          type union {
            type enumeration {
              enum forever {
                tailf:info "continue running forever";
              }
            }
            type uint32 {
              tailf:info "<0-2147483647>;;Life seconds";
            }
          }
        }

        // ip sla schedule * start-time
        container start-time {
          tailf:info "When to start this entry";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice start-time-choice {
            leaf after {
              tailf:info "Start after a certain amount of time from now";
              type string {
                tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
              }
            }
            leaf now {
              tailf:info "Start now";
              type empty;
            }
            leaf pending {
              tailf:info "Start pending";
              type empty;
            }
            leaf time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
              }
            }
          }
        }

        // ip sla schedule * ageout
        leaf ageout {
          tailf:info "How long to keep this Entry when inactive";
          type uint32 {
            tailf:info "<0-2073600>;;Ageout Seconds";
          }
        }

        // ip sla schedule * recurring
        leaf recurring {
          tailf:info "Probe to be scheduled automatically every day";
          type empty;
        }
      }

      // ip sla ethernet-monitor
      container ethernet-monitor {
        tailf:info "IP SLAs Auto Ethernet configuration";

        // ip sla ethernet-monitor *
        list ip-sla-ethernet-monitor-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-ip-sla-ethernet-monitor";
          tailf:cli-full-command;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
          }

          // ip sla ethernet-monitor * / type echo *
          // ip sla ethernet-monitor * / type jitter *
          list "type" {
            tailf:info "Type of entry";
            tailf:cli-mode-name "config-ip-sla-ethernet-params";
            key "type domain vlan";
            leaf "type" {
              type enumeration {
                enum echo {
                  tailf:info "Perform Ethernet Echo operation";
                }
                enum jitter {
                  tailf:info "Perform Ethernet Jitter operation";
                }
              }
            }
            leaf domain {
              tailf:info "Domain Name";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Domain Name Value";
              }
            }
            leaf vlan {
              tailf:info "VLAN ID";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<1-4095>;;VLAN ID";
                range "1..4095";
              }
            }

            // ip sla ethernet-monitor * / type echo * / cos
            leaf cos {
              tailf:info "Class of Service";
              type uint8 {
                tailf:info "<0-7>;;Class of Service Value";
                range "0..7";
              }
            }

            // ip sla ethernet-monitor * / type echo * / request-data-size
            leaf request-data-size {
              tailf:info "Request data size";
              type uint16 {
                tailf:info "<0-1400>;;Padding size (bytes) in payload";
                range "0..1400";
              }
            }
          }
        }

        // ip sla ethernet-monitor schedule * schedule-period
        list schedule {
          tailf:info "IP SLAs Auto ethernet Scheduling";
          tailf:cli-delete-when-empty;
          tailf:cli-suppress-mode;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key operation-number;
          leaf operation-number {
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
            tailf:non-strict-leafref {
              path "../../ip-sla-ethernet-monitor-list/id";
            }
          }
          leaf schedule-period {
            tailf:info "Group schedule period range";
            type uint32 {
              tailf:info "<1-604800>;;seconds";
            }
          }
          container start-time {
            tailf:info "When to start this entry";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice start-time-choice {
              leaf after {
                tailf:info "Start after a certain amount of time from now";
                type string {
                  tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
                }
              }
              leaf now {
                tailf:info "Start now";
                type empty;
              }
              leaf pending {
                tailf:info "Start pending";
                type empty;
              }
              leaf time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
                }
              }
            }
          }
        }

        // ip sla ethernet-monitor reaction-configuration *
        list reaction-configuration {
          tailf:info "IP SLAs Ethernet CFM Reaction Configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-incomplete-command;
          key operation-number;
          leaf operation-number {
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
            }
            tailf:non-strict-leafref {
              path "../../ip-sla-ethernet-monitor-list/id";
            }
          }

          // ip sla ethernet-monitor reaction-configuration * react
          container react {
            tailf:info "Reaction variable to be configured";

            // ip sla ethernet-monitor reaction-configuration * react rtt
            container rtt {
              tailf:info "Round Trip Time";
              presence true;
            }

            // ip sla ethernet-monitor reaction-configuration * react timeout
            container timeout {
              tailf:info "timeout";
              presence true;
            }
          }
        }
      }

      // ip sla reaction-configuration *
      list reaction-configuration {
        tailf:info "IP SLAs Reaction-Configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key "operation-number react";
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }
        leaf react {
          tailf:info "Reaction variable to be configured";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "monitored-element";
          }
        }

        // ip sla reaction-configuration * threshold-value
        container threshold-value {
          tailf:cli-break-sequence-commands;
          tailf:info "Threshold value";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf upper-threshold {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-60000>;;Upper limit for Threshold";
            }
          }
          leaf lower-threshold {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-60000>;;Lower limit for Threshold";
            }
          }
        }

        // ip sla reaction-configuration * threshold-type
        container threshold-type {
          tailf:info "Threshold Type";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice threshold-type-choice {
            // ip sla reaction-configuration * threshold-type average
            case average {
              leaf average {
                tailf:info "Average over N attempts";
                type empty;
              }
              leaf n {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-16>;;N Value";
                  range "1..16";
                }
              }
            }

            // ip sla reaction-configuration * threshold-type consecutive
            case consecutive {
              leaf consecutive {
                tailf:info "Consecutive occurrences";
                type empty;
              }
              leaf number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-16>;;Number of occurrences";
                  range "1..16";
                }
              }
            }

            // ip sla reaction-configuration * threshold-type immediate
            leaf immediate {
              tailf:info "React immediately";
              type empty;
            }

            // ip sla reaction-configuration * threshold-type never
            leaf never {
              tailf:info "Never react";
              type empty;
            }

            // ip sla reaction-configuration * threshold-type xOfy
            container xOfy {
              tailf:info "X out of Y occurrences";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-16>;;X Value";
                  range "1..16";
                }
              }
              leaf y {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-16>;;Y Value";
                  range "1..16";
                }
              }
            }
          }
        }

        // ip sla reaction-configuration * action-type
        leaf action-type {
          tailf:info "IP SLAs Reaction Action Type";
          type enumeration {
            enum none {
              tailf:info "No action";
            }
            enum trapAndTrigger {
              tailf:info "Trap and Trigger action";
            }
            enum trapOnly {
              tailf:info "Trap Only action";
            }
            enum triggerOnly {
              tailf:info "Trigger Only action";
            }
          }
        }
      }

      // ip sla reaction-trigger *
      list reaction-trigger {
        tailf:info "IP SLAs Trigger Assignment";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key operation-number;
        leaf operation-number {
          type uint32 {
            tailf:info "<1-2147483647>;;Entry number";
          }
          tailf:non-strict-leafref {
            path "../../ip-sla-list/id";
          }
        }
        leaf target-operation {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2147483647>;;Target entry num";
          }
        }
      }

      // ip sla enable
      container enable {
        tailf:info "Enable Event Notifications";

        // ip sla enable timestamp
        leaf timestamp {
          tailf:info "Enable timestamping";
          type empty;
        }

        // ip sla enable reaction-alerts
        leaf reaction-alerts {
          tailf:info "Enable Reaction Alert Notifications";
          type empty;
        }
      }
    }

    // ip wccp
    container wccp {
      tailf:info "Web-Cache Coordination Protocol Commands";
      uses ip-wccp-grouping;

      // ip wccp vrf *
      list vrf {
        tailf:info "Configure WCCP for a VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../vrf/definition";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ip-wccp-grouping;
      }
    }

    // ip nbar
    container nbar {
      tailf:info "NBAR - Network Based Application Recognition";

      // ip nbar attribute-map *
      list attribute-map {
        tailf:cli-mode-name "config-attribute-map";
        key name;
        leaf name {
          type string {
            tailf:info "WORD: Attribute Profile Name";
          }
        }

        // ip nbar attribute-map * / attribute
        container attribute {
          tailf:info "Attribute Name";

          // ip nbar attribute-map * / attribute business-relevance
          leaf business-relevance {
            tailf:info "Application business-relevance";
            type enumeration {
              enum business-relevant {
                tailf:info "Business critical applications";
              }
              enum business-irrelevant {
                tailf:info "Undesirable business traffic";
              }
              enum "default" {
                tailf:info "Related business applications";
              }
            }
          }

          // ip nbar attribute-map * / attribute traffic-class
          leaf traffic-class {
            tailf:info "SRND class";
            type enumeration {
              enum transactional-data {
                tailf:info "Interactive data applications";
              }
              enum voip-telephony {
                tailf:info "VoIP telephony (bearer-only) traffic";
              }
              enum signaling {
                tailf:info "Signaling traffic that supports IP voice and video telephony";
              }
              enum real-time-interactive {
                tailf:info "High-definition interactive video applications";
              }
              enum ops-admin-mgmt {
                tailf:info "Network operations, administration, and management traffic";
              }
              enum network-control {
                tailf:info "Network control plane traffic";
              }
              enum multimedia-streaming {
                tailf:info "Video-on-Demand (VoD) streaming video";
              }
              enum multimedia-conferencing {
                tailf:info "Desktop software multimedia collaboration applications";
              }
              enum bulk-data {
                tailf:info "Non-interactive data applications";
              }
              enum broadcast-video {
                tailf:info "Broadcast TV, live events, video surveillance";
              }
            }
          }

          // ip nbar attribute-map * / attribute application-group
          leaf application-group {
            tailf:info "Application-group attribute";
            type string {
              tailf:info "WORD;;Related applications group";
            }
          }
        }
      }

      // ip nbar custom *
      list custom {
        tailf:info "Custom PDL (protocol description language) Module";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the User defined Protocol";
          }
        }

        // ip nbar custom * composite
        container composite {
          tailf:info "Custom protocols based on multiple underlying protocols";
          tailf:cli-compact-syntax;
          leaf server-name {
            tailf:info "Match the server name based on various protocols";
            type string {
              tailf:info "WORD  Enter String Format - cannot exceed 30 characters";
            }
          }
          leaf id {
            tailf:info "Selector ID";
            type uint16 {
              tailf:info "<1-65535>;;Enter Selector ID";
              range "1..65535";
            }
          }
        }
      }

      // ip nbar attribute-set *
      list attribute-set {
        tailf:info "Set attribute-set";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key protocol-name;
        leaf protocol-name {
          type string {
            tailf:info "WORD;;Name of protocol";
          }
        }
        leaf profile-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "Attribute Profile Name";
          }
          tailf:non-strict-leafref {
            path "../../attribute-map/name";
          }
        }
      }

      // ip nbar protocol-discovery
      container protocol-discovery {
        tailf:info "Enable protocol discovery for both ipv4 and ipv6";
        presence true;
      }
    }

    // ip inspect
    container inspect {
      tailf:info "Context-based Access Control Engine";

      // ip inspect name *
      list name {
        tailf:info "Specify an inspection rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of inspection defined (16 characters max)";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Rule";
            }
          }
        }
      }
    }

    // no ip spd enable
    container spd {
      leaf enable  {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // ip source binding *
    container source {
      tailf:info "static IP binding";
      list binding {
        tailf:info "static IP binding";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key mac-address;
        leaf mac-address {
          tailf:cli-diff-dependency "../../../../interface/Ethernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/FastEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/GigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/TenGigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/FortyGigabitEthernet/switchport";
          tailf:cli-diff-dependency "../../../../interface/HundredGigE/switchport";
          tailf:cli-diff-dependency "../../../../interface/Port-channel/switchport";
          type string {
            tailf:info "H.H.H;;binding MAC address";
          }
        }
        leaf vlan {
          tailf:info "binding VLAN learned";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<1-4094>;;binding VLAN number";
            range "1..4094";
          }
        }
        leaf ip-address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;binding IP address";
          }
        }
        container interface {
          tailf:info "binding interface";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// isdn
  /// ========================================================================

  container isdn {
    tailf:info "ISDN configuration commands";

    // isdn switch-type
    leaf switch-type {
      tailf:info "Select the ISDN switch type";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;switch type";
      }
    }

    // isdn leased-line
    container leased-line {
      tailf:info "Sets a BRI interface to support leased lines on B & D channels";
      leaf BRI {
        tailf:info "ISDN Basic Rate Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "../../../interface/BRI/name";
        }
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }
    }
  }


  /// ========================================================================
  /// vmps
  /// ========================================================================

  container vmps {
    tailf:info "VMPS settings";

    // vmps reconfirm
    leaf reconfirm {
      tailf:info "Set VMPS reconfirm interval";
      type uint8 {
        tailf:info "Number of minutes between reconfirmations";
        range "0..120";
      }
    }

    // vmps retry
    leaf retry {
      tailf:info "Set VMPS retry count";
      type uint8 {
        tailf:info "<1-10>;;Retry count per server";
        range "1..10";
      }
    }

    // vmps server *
    list server {
      tailf:info "Configure server IP address";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address";
        }
      }
      // vmps server * primary
      leaf primary {
        tailf:info "Specify primary server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// ipv6
  /// ========================================================================

  container ipv6 {
    tailf:info "Global IPv6 configuration commands";

    // ipv6 unicast-routing
    leaf unicast-routing {
      tailf:info "Enable unicast routing";
      type empty;
    }

    // ipv6 source-route
    // no ipv6 source-route
    leaf source-route {
      tailf:info "Process packets with source routing header options";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // ipv6 cef
    // no ipv6 cef
    leaf cef {
      tailf:info "Cisco Express Forwarding";
      tailf:cli-show-no;
      type empty;
    }

    // ipv6 cef X
    container cef-conf {
      tailf:cli-drop-node-name;
      container cef {
        tailf:info "Cisco Express Forwarding";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../../cef";

        // ipv6 cef accounting
        container accounting {
          tailf:info "Enable CEF accounting";
          tailf:cli-compact-syntax;
          leaf per-prefix {
            tailf:info "Enable per prefix accounting";
            type empty;
          }
          leaf prefix-length {
            tailf:info "Enable prefix length accounting";
            type empty;
          }
        }

        // ipv6 cef distributed
        leaf distributed {
          tailf:info "Distributed Cisco Express Forwarding";
          tailf:cli-full-command;
          type empty;
        }

        // ipv6 cef load-sharing algorithm original
        container load-sharing {
          tailf:info "Load sharing";
          container algorithm {
            tailf:info "Per-destination load sharing algorithm selection";
            choice algorithm-choice {
              leaf original {
                tailf:info "Original algorithm";
                type empty;
              }
              container universal {
                tailf:info "Algorithm for use in most environments";
                //NSO BUG: tailf:cli-reset-container;
                //presence true;
                leaf id {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "<1-FFFFFFFF>;;Fixed ID";
                  }
                }
              }
              //default universal;
            }
          }
        }
      }
    }

    // ipv6 flowset
    leaf flowset {
      tailf:info "Set flow label random for originated packets";
      tailf:cli-full-command;
      type empty;
    }

    // ipv6 icmp error-interval
    container icmp {
      tailf:info "Configure ICMP parameters";
      container error-interval {
        tailf:info "Interval between ICMP error messages";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-2147483647>;;Interval between tokens in milliseconds";
            range "0..2147483647";
          }
        }
        leaf bucketsize {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-200>;;Bucket size";
            range "1..200";
          }
        }
      }
    }

    // ipv6 wccp
    container wccp {
      tailf:info "Web-Cache Coordination Protocol IPv6 Commands";
      uses ip-wccp-grouping;

      // ipv6 wccp vrf *
      list vrf {
        tailf:info "Configure WCCP for a VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ip-wccp-grouping;
      }
    }

    // ipv6 multicast-routing
    leaf multicast-routing {
      tailf:info "Enable IPv6 multicast";
      type empty;
    }

    // ipv6 multicast rpf backoff
    container multicast {
      tailf:info "Configure multicast related commands";
      container rpf {
        tailf:info "Configure multicast RPF related commands";
        container backoff {
          tailf:info "Backoff delay after unicast routing change";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf initial-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Initial RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
          leaf max-delay {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<200-65535>;;Maximum RPF backoff delay in "
                +"milliseconds";
              range "200..65535";
            }
          }
        }
        leaf use-bgp {
          tailf:info "Use BGP routes for multicast RPF lookup";
          type empty;
        }
      }
    }

    // ipv6 spd queue
    container spd {
      tailf:info "Selective Packet Discard (SPD)";
      container queue {
        tailf:info "SPD queue";

        // ipv6 spd queue min-threshold
        leaf min-threshold {
          tailf:info "SPD minimum threshold";
          type uint16 {
            tailf:info "<1-65535>;;spd value";
            range "1..65535";
          }
        }

        // ipv6 spd queue max-threshold
        leaf max-threshold {
          tailf:info "SPD maximum threshold";
          tailf:cli-diff-dependency "../min-threshold";
          type uint16 {
            tailf:info "<1-65535>;;spd value";
            range "1..65535";
          }
        }
      }
    }

    // ipv6 route
    container route {
      tailf:info "Configure static routes";
      tailf:cli-diff-dependency "../../interface";

      // ipv6 route static
      container static {
        tailf:info "Configure static route attributes";

        // ipv6 route static bfd *
        list bfd {
          tailf:info "Configure a Static Route BFD neighbor";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "interface ipv6-address";
          leaf interface {
            tailf:cli-diff-dependency "../../../../../interface";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf ipv6-address {
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of BFD neighbor";
            }
          }
          leaf unassociated {
            tailf:info "Unassociated Neighbor";
            type empty;
          }
        }
      }

      // ipv6 route vrf *
      list vrf {
        tailf:info "Configure static route for a VPN Routing/Forwarding "+
          "instance";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses ipv6-route-grouping;
      }

      // ipv6 route *
      container no-vrf {
        tailf:cli-drop-node-name;
        uses ipv6-route-grouping;
      }
    }

    // ipv6 prefix-list *
    container prefix-list {
      tailf:info "Build a prefix list";

      // no ipv6 prefix-list sequence-number
      leaf sequence-number {
        tailf:info "Include/exclude sequence numbers in NVGEN";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // ipv6 prefix-list * seq *
      list prefixes {
        when "not(../sequence-number) or (../sequence-number = 'true')" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-dependency "../sequence-number";
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ipv6 prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ipv6 prefix-list * seq *
        list seq {
          tailf:info "sequence number of an entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key no;
          leaf no {
            type uint32 {
              tailf:info "<1-4294967294>;;Sequence number";
              range "1..4294967294";
            }
          }

          // ipv6 prefix-list * seq * deny
          container deny {
            tailf:info "Specify packets to reject";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }

          // ipv6 prefix-list * seq * permit
          container permit {
            tailf:info "Specify packets to forward";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              type ios:ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            leaf ge {
              tailf:info "Minimum prefix length to be matched";
              tailf:cli-break-sequence-commands;
              type uint16 {
                tailf:info "<1-128>;;Minimum prefix length";
                range "1..128";
              }
            }
            leaf le {
              tailf:info "Maximum prefix length to be matched";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-128>;;Maximum prefix length";
                range "1..128";
              }
            }
          }
        }
      }

      // ipv6 prefix-list *
      list prefixes-no-seq {
        when "../sequence-number = 'false'" {
          tailf:dependency "../sequence-number";
        }
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-diff-dependency "../sequence-number";
        key name;
        leaf name {
          tailf:cli-disallow-value "sequence-number";
          type string {
            tailf:info "WORD;;Name of a prefix list";
          }
        }

        // ipv6 prefix-list * description
        leaf "description" {
          tailf:info "Prefix-list specific description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Up to 80 characters describing this prefix-list";
            length "1..80";
          }
        }

        // ipv6 prefix-list *
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;permit <entry> | deny <entry>";
              pattern "(deny .*)|(permit .*)";
            }
          }
        }
      }
    }

    // ipv6 access-list *
    container access-list {
      tailf:info "Configure access lists";
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      list named-acl {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-no-key-completion;
        tailf:cli-mode-name "config-ipv6-acl";
        key name;
        leaf name {
          type string {
            tailf:info "User selected string identifying this access list";
          }
        }
        list access-list-rule {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-case-sensitive;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forwards\n"+
                "remark;;Access list entry comment\n"+
                "sequence;;Sequence number for this entry";
              pattern "(deny .*)|(permit .*)|(remark .*)|(sequence .*)"+
                "|(evaluate .*)";
            }
          }
        }
      }
    }

    // ipv6 router
    container router {
      tailf:info "Enable an IPV6 routing process";

      // ipv6 router rip *
      list rip {
        tailf:info "IPv6 Routing Information Protocol (RIPv6)";
        tailf:cli-mode-name "config-rtr";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;User selected string identifying this process";
          }
        }

        // ipv6 router rip * / address-family ipv6 vrf *
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv6 {
            tailf:info "Address family";
            list vrf {
              tailf:cli-mode-name "config-ipv6-rtr-af";
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit Address Family command mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../ipv6/rip/vrf-mode/enable";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
            }
          }
        }

        // ipv6 router rip * / distribute-list prefix-list * in
        // ipv6 router rip * / distribute-list prefix-list * out
        container distribute-list {
          tailf:info "Filter networks in routing updates";
          list prefix-list {
            tailf:info "Filter connections based on an IPv6 prefix-list";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key direction;
            leaf direction {
              type enumeration {
                enum "in" {
                  tailf:info "Filter incoming routing updates";
                }
                enum "out" {
                  tailf:info "Filter outgoing routing updates";
                }
              }
            }
            leaf prefix-list-name {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              tailf:non-strict-leafref {
                path "/ios:ip/prefix-list/prefixes/name";
              }
              type string {
                tailf:info "WORD;;Prefix-list name";
              }
            }
          }
        }
      }

      // ipv6 router eigrp *
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-mode-name "config-rtr";
        key as-no;
        leaf as-no {
          type uint16 {
            tailf:info "<1-65535>;;Autonomous System";
            range "1..65535";
          }
        }

        // ipv6 router eigrp * / eigrp router-id
        container eigrp {
          tailf:info "EIGRP specific commands";
          leaf router-id {
            tailf:info "router id for this EIGRP process";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;EIGRP Router-ID in IP address format";
            }
          }
        }

        // ipv6 router eigrp * / shutdown
        leaf shutdown {
          tailf:info "Shutdown this instance of EIGRP";
          type empty;
        }
      }

      // ipv6 router ospf *
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-mode-name "config-rtr";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Process ID";
            range "1..65535";
          }
        }
        uses router-ospf-common-grouping;
        uses router-ospf-common-af-grouping;
        uses router-ospf-grouping;
      }
    }

    // ipv6 neighbor
    container neighbor {
      tailf:info "Neighbor";

      // ipv6 neighbor *
      list neighbor-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key "address interface";
        leaf address {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 address";
          }
        }
        leaf interface {
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;Interface name";
          }
        }
        leaf hardware-address {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "H.H.H;;48-bit hardware address";
          }
        }
      }
    }

    // ipv6 dhcp
    container dhcp {
      tailf:info "Configure IPv6 DHCP";

      // ipv6 dhcp pool *
      list pool {
        tailf:info "Configure IPv6 DHCP pool";
        tailf:cli-mode-name "config-dhcpv6";
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;DHCP pool name";
          }
        }

        // ipv6 dhcp pool * / vrf
        leaf vrf {
          tailf:info "Associate pool with a VRF";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        // ipv6 dhcp pool * / dns-server
        leaf dns-server {
          tailf:info "DNS servers";
          tailf:cli-full-command;
          type inet:host {
            tailf:info "Hostname or X:X:X:X::X;;Server's name or IPv6 address";
          }
        }

        // ipv6 dhcp pool * / domain-name
        leaf domain-name {
          tailf:info "Domain name to complete unqualified host names";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;A domain name";
          }
        }
      }
    }

    // ipv6 rip vrf-mode enable
    container rip {
      tailf:info "Configure ipv6 RIP settings";
      container vrf-mode {
        tailf:info "Enable RIPng VRF support";
        leaf enable {
          tailf:info "Enable RIPng VRF support";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// subscriber
  /// ========================================================================

  container subscriber {
    tailf:info "Subscriber configuration";

    // subscriber templating
    leaf templating {
      tailf:info "Configure subscriber templating";
      type empty;
    }
  }


  /// ========================================================================
  /// multilink
  /// ========================================================================

  container multilink {
    tailf:info "PPP multilink global configuration";

    // multilink virtual-template
    leaf virtual-template {
      tailf:info "virtual-template interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-4095>;;virtual template number";
        range "1..4095";
      }
    }

    // multilink bundle-name
    leaf bundle-name {
      tailf:info "Select method for naming multilink bundles";
      tailf:cli-full-command;
      type enumeration {
        enum authenticated {
          tailf:info "Use peer's authenticated name";
        }
        enum both {
          tailf:info "Use peer's authenticated name and endpoint "+
          "discriminator";
        }
        enum endpoint {
          tailf:info "Use peer's endpoint discriminator";
        }
        enum rfc {
          tailf:info "Use peer and local authenticated name and endpoint "+
          "discriminator";
        }
      }
    }

  }


  /// ========================================================================
  /// flow
  /// ========================================================================

  container flow {
    tailf:info "Global Flow configuration subcommands";

    // flow exporter *
    list exporter {
      tailf:info "Define a Flow Exporter";
      tailf:cli-mode-name "config-flow-exporter";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Exporter name";
        }
      }

      // flow exporter * / description
      leaf "description" {
        tailf:info "Provide a description for this Flow Exporter";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Exporter description";
        }
      }

      // flow exporter * / destination
      container destination {
        tailf:info "Export destination configuration";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-case-insensitive;
        leaf address {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Destination "
              + "IPv4 address or hostname";
          }
        }
        leaf vrf {
          tailf:info "Optional VRF label";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF Label";
          }
        }
      }

      // flow exporter * / source
      container source {
        tailf:info "Originating interface";
        uses interface-name-grouping;
      }

      // flow exporter * / dscp
      leaf dscp {
        tailf:info "Optional DSCP";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;Differentiated services codepoint value";
          range "0..63";
        }
      }

      // flow exporter * / transport udp
      container transport {
        tailf:info "Transport protocol";
        leaf udp {
          tailf:info "UDP transport protocol";
          type uint16 {
            tailf:info "<1-65535>;;Port value";
            range "1..65535";
          }
        }
      }

      // flow exporter * / export-protocol
      leaf export-protocol {
        tailf:info "Export protocol version";
        tailf:cli-full-command;
        type enumeration {
          enum ipfix {
            tailf:info "IPFIX (Version 10)";
          }
          enum netflow-v5 {
            tailf:info "NetFlow Version 5";
          }
          enum netflow-v9 {
            tailf:info "NetFlow Version 9";
          }
        }
      }

      // flow exporter * / template data timeout
      container template {
        tailf:info "Flow Exporter template configuration";
        container data {
          tailf:info "Flow Exporter data configuration";
          leaf timeout {
            tailf:info "Resend data based on a timeout";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
          }
        }
      }

      // flow exporter * / option
      container option {
        tailf:info "Select an option for exporting";

        // flow exporter * / option interface-table
        container interface-table {
          tailf:info "Interface SNMP-index-to-name Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
             type uint32 {
               tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
          }
        }

        // flow exporter * / option exporter-stats
        container exporter-stats {
          tailf:info "Exporter Statistics Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
             type uint32 {
               tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
          }
        }


        // flow exporter * / option sampler-table
        container sampler-table {
          tailf:info "Export Sampler Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
             type uint32 {
               tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
          }
        }

        // flow exporter * / option c3pl-class-table
        container c3pl-class-table {
          tailf:info "C3PL class cce-id table";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
          }
        }

        // flow exporter * / option c3pl-policy-table
        container c3pl-policy-table {
          tailf:info "C3PL policy cce-id table";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Value given in seconds";
              range "1..86400";
            }
          }
        }

        // flow exporter * / option application-attributes
        container application-attributes {
          tailf:info "Application Attributes Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
          }
        }

        // flow exporter * / option application-table
        container application-table {
          tailf:info "Application Table Option";
          tailf:cli-reset-container;
          presence true;
          leaf timeout {
            tailf:info "Option resend time";
            type uint32 {
              tailf:info "<1-86400>;;Time in seconds";
              range "1..86400";
            }
          }
        }
      }
    }

    // flow record *
    list record {
      tailf:cli-mode-name "config-flow-record";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Record name";
        }
      }
      leaf "type" {
        tailf:info "Type of the Flow Record";
        tailf:cli-prefix-key;
        type enumeration {
          enum mace {
            tailf:info "Measurements Aggregation and Correlation "
            + "Engine Metrics";
          }
          enum performance-monitor {
            tailf:info "Config media monitor flow record type";
          }
        }
      }

      // flow record * / description
      leaf "description" {
        tailf:info "Provide a description for this Flow Record";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Record description";
        }
      }

      // flow record * / match
      container match {
        tailf:info "Specify a key field";

        // flow record * / match ipv4
        container ipv4 {
          tailf:info "IPv4 fields";

          // flow record * / match ipv4 tos
          leaf tos {
            tailf:info "IPv4 type of service";
            type empty;
          }

          // flow record * / match ipv4 ttl
          leaf ttl {
            tailf:info "IPv4 TTL";
            type empty;
          }

          // flow record * / match ipv4 protocol
          leaf protocol {
            tailf:info "IPv4 protocol";
            type empty;
          }

          // flow record * / match ipv4 source
          container source {
            tailf:info "IPv4 source address based fields";

            // flow record * / match ipv4 source address
            leaf address {
              tailf:info "IPv4 source address";
              type empty;
            }

            // flow record * / match ipv4 source prefix
            container "prefix" {
              tailf:info "IPv4 address prefix for the IPv4 source address";
              tailf:cli-reset-container;
              presence true;
              // flow record * / match ipv4 source prefix minimum-mask
              leaf minimum-mask {
                tailf:info "Provide a minimum mask for this field";
                type uint8 {
                  tailf:info "<1-32>;;Specify optional minimum mask";
                  range "1..32";
                }
              }
            }

            // flow record * / match ipv4 source mask
            container mask {
              tailf:info "IPv4 address mask for the IPv4 source address";
              tailf:cli-reset-container;
              presence true;
              // flow record * / match ipv4 source prefix minimum-mask
              leaf minimum-mask {
                tailf:info "Provide a minimum mask for this field";
                type uint8 {
                  tailf:info "<1-32>;;Specify optional minimum mask";
                  range "1..32";
                }
              }
            }
          }

          // flow record * / match ipv4 destination address
          container destination {
            tailf:info "IPv4 destination address based fields";
            leaf address {
              tailf:info "IPv4 destination address";
              type empty;
            }
          }
        }

        // flow record * / match ipv6
        container ipv6 {
          tailf:info "IPv6 fields";

          // flow record * / match ipv6 traffic-class
          leaf traffic-class {
            tailf:info "IPv6 traffic class";
            type empty;
          }

          // flow record * / match ipv6 protocol
          leaf protocol {
            tailf:info "IPv6 payload protocol";
            type empty;
          }

          // flow record * / match ipv6 source
          container source {
            tailf:info "IPv6 source address based fields";
            // flow record * / match ipv6 source address
            leaf address {
              tailf:info "IPv6 source address";
              type empty;
            }
          }

          // flow record * / match ipv6 destination address
          container destination {
            tailf:info "IPv6 destination address based fields";
            // flow record * / match ipv6 destination address
            leaf address {
              tailf:info "IPv6 destination address";
              type empty;
            }
          }
        }

        // flow record * / match connection
        container connection {
          tailf:info "Connection fields";

          // flow record * / match connection transaction-id
          leaf transaction-id {
            tailf:info "An identifier for a transaction between client and server";
            type empty;
          }

          // flow record * / match connection client
          container client {
            tailf:info "Client side (flow initiator) related metrics";

            // flow record * / match connection client ipv4 address
            container ipv4 {
              tailf:info "Client side IPv4 metrics";
              leaf address {
                tailf:info "IPv4 address of the flow initiator";
                type empty;
              }
            }

            // flow record * / match connection client ipv6 address
            container ipv6 {
              tailf:info "Client side IPv6 metrics";
              leaf address {
                tailf:info "IPv6 address of the flow initiator";
                type empty;
              }
            }
          }

          // flow record * / match connection server
          container server {
            tailf:info "Server side (flow responder) related metrics";

            // flow record * / match connection server ipv4 address
            container ipv4 {
              tailf:info "Server side IPv4 metrics";
              leaf address {
                tailf:info "IPv4 address of the flow responder";
                type empty;
              }
            }

            // flow record * / match connection server ipv6 address
            container ipv6 {
              tailf:info "Server side IPv6 metrics";
              leaf address {
                tailf:info "IPv6 address of the flow responder";
                type empty;
              }
            }

            // flow record * / match connection server transport port
            container transport {
              tailf:info "Server side transport metrics";
              leaf port {
                tailf:info "Transport port of the flow responder";
                type empty;
              }
            }
          }
        }

        // flow record * / match policy
        container policy {
          tailf:info "policy fields";

          // flow record * / match policy qos
          container qos {
            tailf:info "QoS policy related metrics";

            // flow record * / match policy qos classification hierarchy
            container classification {
              tailf:info "Classification metrics";
              leaf hierarchy {
                tailf:info "QoS class hierarchy";
                type empty;
              }
            }

            // flow record * / match policy qos queue
            container queue {
              tailf:info "Queue metrics";

              // flow record * / match policy qos queue drops
              leaf drops {
                tailf:info "QoS queue drops";
                type empty;
              }

              // flow record * / match policy qos queue index
              leaf index {
                tailf:info "QoS queue index";
                type empty;
              }
            }
          }
        }

        // flow record * / match transport
        container transport {
          tailf:info "Transport layer fields";
          // flow record * / match transport source-port
          leaf source-port {
            tailf:info "Transport source port";
            type empty;
          }
          // flow record * / match transport destination-port
          leaf destination-port {
            tailf:info "Transport destination port";
            type empty;
          }
        }

        // flow record * / match interface
        container interface {
          tailf:info "Interface fields";

          // flow record * / match interface input
          container "input" {
            tailf:info "The input interface";
            presence true;
            // flow record * / match interface input snmp
            leaf snmp {
              tailf:info "SNMP Index of the input interface";
              type empty;
            }
          }

          // flow record * / match interface output
          container "output" {
            tailf:info "The output interface";
            presence true;
            // flow record * / match interface output snmp
            leaf snmp {
              tailf:info "SNMP Index of the output interface";
              type empty;
            }
          }
        }

        // flow record * / match flow
        container flow {
          tailf:info "Flow identifying fields";

          // flow record * / match flow direction
          leaf direction {
            tailf:info "Direction the flow was monitored in";
            type empty;
          }

          // flow record * / match flow sampler
          container sampler {
            tailf:info "ID of the sampler";
            presence true;
            // flow record * / match flow sampler hash digest-value
            container hash {
              tailf:info "Flow sampler hash related fields";
              leaf digest-value {
                tailf:info "Result of the hash for hash-based sampling algorithm";
                type empty;
              }
            }
          }
        }

        // flow record * / match application name
        container application {
          tailf:info "Application fields";
          container name {
            tailf:info "Application name";
            tailf:cli-delete-when-empty;
            presence true;
            // flow record * / match application name account-on-resolution
            leaf account-on-resolution {
              tailf:info "Account on resolution";
              type empty;
            }
          }
        }
      }

      // flow record * / collect
      container collect {
        tailf:info "Specify a non-key field";

        // flow record * / collect routing
        container routing {
          tailf:info "Routing attributes";

          // flow record * / collect routing source as
          container source {
            tailf:info "Source routing attributes";
            container as {
              tailf:info "AS number of the origin network";
              presence true;
            }
          }

          // flow record * / collect routing destination as
          container destination {
            tailf:info "Destination routing attributes";
            container as {
              tailf:info "AS number of the destination network";
              presence true;
            }
          }

          // flow record * / collect routing vrf
          container vrf {
            tailf:info "VRF routing attributes";

            // flow record * / collect routing vrf input
            leaf "input" {
              tailf:info "VRF ID for incoming packet";
              type empty;
            }

            // flow record * / collect routing vrf output
            leaf "output" {
              tailf:info "VRF ID for outgoing packet";
              type empty;
            }
          }

          // flow record * / collect routing next-hop address
          container next-hop {
            tailf:info "Information regarding the next hop";
            container address {
              tailf:info "IP address of the next hop";

              // flow record * / collect routing next-hop address ipv4
              container ipv4 {
                tailf:info "IPv4 address of the next hop";
                presence true;
                leaf bgp {
                  tailf:info "IPv4 address of the BGP next hop";
                  type empty;
                }
              }

              // flow record * / collect routing next-hop address ipv6
              container ipv6 {
                tailf:info "Ipv6 address of the next hop";
                presence true;
                leaf bgp {
                  tailf:info "Ipv6 address of the BGP next hop";
                  type empty;
                }
              }
            }
          }
        }

        // flow record * / collect ipv4
        container ipv4 {
          tailf:info "IPv4 fields";

          // flow record * / collect ipv4 dscp
          leaf dscp {
            tailf:info "IPv4 DSCP (part of TOS)";
            type empty;
          }

          // flow record * / collect ipv4 id
          leaf id {
            tailf:info "IPv4 ID";
            type empty;
          }

          // flow record * / collect ipv4 source
          container source {
            tailf:info "IPv4 source address based fields";

            // flow record * / collect ipv4 source mask
            container mask {
              tailf:info "IPv4 address mask for the IPv4 source address";
              presence true;
            }

            // flow record * / collect ipv4 source prefix
            container "prefix" {
              tailf:info "IPv4 address prefix for the IPv4 source address";
              presence true;
            }
          }

          // flow record * / collect ipv4 destination mask
          container destination {
            tailf:info "IPv4 destination address based fields";
            container mask {
              tailf:info "IPv4 address mask for the IPv4 destination address";
              presence true;
            }
          }
        }

        // flow record * / collect ipv6
        container ipv6 {
          tailf:info "IPv6 fields";

          // flow record * / collect ipv6 dscp
          leaf dscp {
            tailf:info "IPv6 DSCP (part of Traffic Class)";
            type empty;
          }

          // flow record * / collect ipv6 source mask
          container source {
            tailf:info "IPv6 source address based fields";
            container mask {
              tailf:info "IPv6 address mask for the IPv6 source address";
              presence true;
            }
          }

          // flow record * / collect ipv6 destination mask
          container destination {
            tailf:info "Ipv6 destination address based fields";
            container mask {
              tailf:info "Ipv6 address mask for the Ipv6 destination address";
              presence true;
            }
          }
        }

        // flow record * / collect transport
        container transport {
          tailf:info "Transport layer fields";

          // flow record * / collect transport tcp flags
          container tcp {
            tailf:info "TCP fields";
            container flags {
              tailf:info "TCP flags";
              presence true;
            }
          }
        }

        // flow record * / collect interface
        container interface {
          tailf:info "Interface fields";

          // flow record * / collect interface input
          leaf "input" {
            tailf:info "The input interface";
            type empty;
          }

          // flow record * / collect interface output
          leaf "output" {
            tailf:info "The output interface";
            type empty;
          }
        }

        // flow record * / collect flow
        container flow {
          tailf:info "Flow identifying fields";

          // flow record * / collect flow sampler
          leaf sampler {
            tailf:info "ID of the sampler";
            type empty;
          }

          // flow record * / collect flow direction
          leaf direction {
            tailf:info "Direction the flow was monitored in";
            type empty;
          }
        }

        // flow record * / collect counter
        container counter {
          tailf:info "Counter fields";

          // flow record * / collect counter bytes
          container bytes {
            tailf:info "Total number of bytes";
            tailf:cli-delete-when-empty;
            presence true;
            leaf long {
              tailf:info "Total number of bytes (64 bit counter)";
              type empty;
            }
          }

          // flow record * / collect counter packets
          container packets {
            tailf:info "Total number of packets";
            tailf:cli-delete-when-empty;
            presence true;
            // flow record * / collect counter packets long
            leaf long {
              tailf:info "Total number of packets (64 bit counter)";
              type empty;
            }
          }

          // flow record * / collect counter flows
          leaf flows {
            tailf:info "Total number of flows";
            type empty;
          }
        }

        // flow record * / collect timestamp
        container timestamp {
          tailf:info "Timestamp fields";

          // flow record * / collect timestamp sys-uptime
          container sys-uptime {
            tailf:info "Timestamps based on the sys-uptime";
            // flow record * / collect timestamp sys-uptime first
            leaf first {
              tailf:info "Time the first packet was seen";
              type empty;
            }
            // flow record * / collect timestamp sys-uptime last
            leaf last {
              tailf:info "Time the most recent packet was seen";
              type empty;
            }
          }

          // flow record * / collect timestamp absolute
          container absolute {
            tailf:info "Timestamps based on the epoch of 00:00 UTC 1st Jan 1970";

            // flow record * / collect timestamp absolute first
            leaf first {
              tailf:info "Absolute time the first packet was seen (milliseconds)";
              type empty;
            }

            // flow record * / collect timestamp absolute last
            leaf last {
              tailf:info "Absolute time the most recent packet was seen (milliseconds)";
              type empty;
            }
          }
        }

        // flow record * / collect application
        container application {
          tailf:info "Application fields";

          // flow record * / collect application name
          container name {
            tailf:info "Application name";
            presence true;
          }

          // flow record * / collect application http
          container http {
            tailf:info "World Wide Web traffic";
            // flow record * / collect application http host
            leaf host {
              tailf:info "Host name of Origin Server containing resource";
              type empty;
            }
          }
        }

        // flow record * / collect connection
        container connection {
          tailf:info "Connection fields";

          // flow record * / collect connection initiator
          leaf initiator {
            tailf:info "The direction of the flow";
            type empty;
          }

          // flow record * / collect connection new-connections
          leaf new-connections {
            tailf:info "The number of connection initiations observed";
            type empty;
          }

          // flow record * / collect connection server
          container server {
            tailf:info "Server side (flow responder) related metrics";

            // flow record * / collect / connection server counter
            container counter {
              tailf:info "Server side counter metrics";

              // flow record * / collect connection server counter responses
              leaf responses {
                tailf:info "Number of responses sent by the server";
                type empty;
              }

              // flow record * / collect connection server counter packets
              container packets {
                tailf:info "Number of packets sent by the server";
                // flow record * / collect connection server counter packets long
                leaf long {
                  tailf:info "64 bits counter";
                  type empty;
                }
              }

              // flow record * / collect connection server counter bytes
              container bytes {
                tailf:info "Number of bytes sent by the server";
                // flow record * / collect connection server counter bytes network
                container network {
                  tailf:info "Number of bytes sent by the server";
                  // flow record * / collect connection server counter bytes network long
                  leaf long {
                    tailf:info "Total number of bytes transmitted by the server";
                    type empty;
                  }
                }
              }
            }
          }

          // flow record * / collect connection delay
          container delay {
            tailf:info "Connection delay metrics";

            // flow record * / collect connection delay response
            container response {
              tailf:info "Response time metrics";

              // flow record * / collect connection delay response to-server
              container to-server {
                tailf:info "Response time as seen from observation point";

                // flow record * / collect connection delay response to-server histogram
                container histogram {
                  tailf:info "Histogram for response time";

                  // flow record * / collect connection delay
                  // .. response to-server histogram bucket1
                  leaf bucket1 {
                    tailf:info "Histogram bucket1 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // response to-server histogram bucket2
                  leaf bucket2 {
                    tailf:info "Histogram bucket2 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // ..response to-server histogram bucket3
                  leaf bucket3 {
                    tailf:info "Histogram bucket3 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // .. response to-server histogram bucket4
                  leaf bucket4 {
                    tailf:info "Histogram bucket4 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // .. response to-server histogram bucket5
                  leaf bucket5 {
                    tailf:info "Histogram bucket5 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // .. response to-server histogram bucket6
                  leaf bucket6 {
                    tailf:info "Histogram bucket6 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // .. response to-server histogram bucket7
                  leaf bucket7 {
                    tailf:info "Histogram bucket8 for response time";
                    type empty;
                  }

                  // flow record * / collect connection delay
                  // .. response to-server histogram late
                  leaf late {
                    tailf:info "Number of late responses";
                    type empty;
                  }
                }
              }

              // flow record * / collect connection delay
              // .. response client-to-server
              container client-to-server {
                tailf:info "Response time as seen by the client";
                // flow record * / collect connection delay
                // .. response client-to-server sum
                leaf sum {
                  tailf:info "Total response time";
                  type empty;
                }
              }
            }

            // flow record * / collect connection delay network
            container network {
              tailf:info "Network time metrics";

              // flow record * / collect connection delay network to-server
              container to-server {
                tailf:info "RTT from observation point to the server";
                // flow record * /
                // .. collect connection delay network to-server sum
                leaf sum {
                  tailf:info "Total application response time";
                  type empty;
                }
              }

              // flow record * / collect connection delay network to-client
              container to-client {
                tailf:info "RTT from observation point to the client";
                // flow record * /
                // .. collect connection delay network to-client sum
                leaf sum {
                  tailf:info "Total network time";
                  type empty;
                }
              }
            }

            // flow record * / collect connection delay application
            container application {
              tailf:info "Application time metrics";
              // flow record * / collect connection delay application sum
              leaf sum {
                tailf:info "Total application response time";
                type empty;
              }
            }
          }

          // flow record * / collect connection transaction
          container transaction {
            tailf:info "Transaction related metrics";
            // flow record * / collect connection transaction counter complete
            container counter {
              tailf:info "Transaction counter metrics";
              leaf complete {
                tailf:info "Number of completed transactions";
                type empty;
              }
            }
          }

          // flow record * / collect connection client
          container client {
            tailf:info "Client side (flow initiator) related metrics";

            // flow record * / collect connection client counter
            container counter {
              tailf:info "Client side counter metrics";

              // flow record * / collect connection client counter packets
              container packets {
                tailf:info "Number of packets sent by the client";

                // flow record * / collect connection client counter packets retransmitted
                leaf retransmitted {
                  tailf:info "Number of packets retransmitted by the client";
                  type empty;
                }

                // flow record * / collect connection client counter packets long
                leaf long {
                  tailf:info "64 bits counter";
                  type empty;
                }
              }

              // flow record * / collect connection client counter bytes network long
              container bytes {
                tailf:info "Number of bytes sent by the client";
                container network {
                  tailf:info "Number of bytes sent by the client";
                  leaf long {
                    tailf:info "Total number of bytes transmitted by the client";
                    type empty;
                  }
                }
              }
            }
          }
        }

        // flow record * / collect policy
        container policy {
          tailf:info "policy fields";

          // flow record * / collect policy qos
          container qos {
            tailf:info "QoS policy related metrics";

            // flow record * / collect policy qos queue
            container queue {
              tailf:info "Queue metrics";

              // flow record * / collect policy qos queue drops
              leaf drops {
                tailf:info "QoS queue drops";
                type empty;
              }

              // flow record * / collect policy qos queue index
              leaf index {
                tailf:info "QoS queue index";
                type empty;
              }
            }

            // flow record * / collect policy qos classification hierarchy
            container classification {
              tailf:info "Classification metrics";
              leaf hierarchy {
                tailf:info "QoS class hierarchy";
                type empty;
              }
            }
          }
        }
      }
    }

    // flow monitor *
    list monitor {
      tailf:info "Define a Flow Monitor";
      tailf:cli-mode-name "config-flow-monitor";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Flow Monitor name";
        }
      }
      leaf "type" {
        tailf:info "Type of the Flow Monitor";
        tailf:cli-prefix-key;
        type enumeration {
          enum mace {
            tailf:info "Config mace flow monitor type";
          }
          enum performance-monitor {
            tailf:info "Config media monitor flow monitor type";
          }
        }
      }

      // flow monitor * / description
      leaf "description" {
        tailf:info "Provide a description for this Flow Monitor";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Flow Monitor description";
        }
      }

      // flow monitor * / record
      leaf record {
        tailf:info "Specify Flow Record";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../../flow/record/name";
        }
        type string {
          tailf:info "WORD;;record name";
        }
      }

      // flow monitor * / exporter *
      list exporter {
        tailf:info "Add an Exporter to use to export records";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:non-strict-leafref {
            path "../../../../flow/exporter/name";
          }
          type string {
            tailf:info "WORD;;Flow exporter name";
          }
        }
      }

      // flow monitor * / cache
      container cache {
        tailf:info "Configure MACE Flow Cache parameters";

        // flow monitor * / cache timeout
        container timeout {
          tailf:info "Cache timeout";

          // flow monitor * / cache timeout inactive
          leaf inactive {
            tailf:info "Specify the active flow timeout";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-604800>;;Active timeout in seconds";
              range "1..604800";
            }
          }

          // flow monitor * / cache timeout active
          leaf active {
            tailf:info "Specify the active flow timeout";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<1-604800>;;Active timeout in seconds";
              range "1..604800";
            }
          }

          // flow monitor * / cache timeout update
          leaf update {
            tailf:info "Specify the update timeout for a MACE Flow Cache";
            type enumeration {
              enum "1" {
                tailf:info "timeout interval of 1 minute";
              }
              enum "10" {
                tailf:info "timeout interval of 10 minutes";
              }
              enum "15" {
                tailf:info "timeout interval of 15 minutes";
              }
              enum "2" {
                tailf:info "timeout interval of 2 minutes";
              }
              enum "5" {
                tailf:info "timeout interval of 5 minutes (default)";
              }
            }
          }

          // flow monitor * / cache timeout synchronized
          leaf "synchronized" {
            tailf:info "Synchronized timeout";
            type uint16 {
              tailf:info "Synchronized timeout value";
              range "1..300";
            }
          }
        }

        // flow monitor * / cache type
        leaf "type" {
          tailf:info "Cache type";
          type enumeration {
            enum immediate {
              tailf:info "Immediate cache type";
            }
            enum normal {
              tailf:info "Normal cache type";
            }
            enum permanent {
              tailf:info "Permanent cache type";
            }
            enum "synchronized" {
              tailf:info "synchronized cache type";
            }
          }
        }

        // flow monitor * / cache entries
        leaf entries {
          tailf:info "Number of cache entries";
          type uint32 {
            tailf:info "<16-2000000>;;Number of cache entries";
            range "16..2000000";
          }
        }
      }

      // flow monitor * / history size
      container history {
        tailf:info "Monitor history intervals";
        leaf size {
          tailf:info "History size";
          type uint8 {
            tailf:info "<0-60>;;Number of intervals monitored";
            range "0..60";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// domain
  /// ========================================================================

  // domain *
  list domain {
    tailf:info "Domain Configuration Commands";
    tailf:cli-mode-name "config-domain";
    //max-elements 1;
    tailf:cli-explicit-exit;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Domain Name";
      }
    }

    // domain * / vrf *
    list vrf {
      tailf:info "Specify vrf for domain";
      tailf:cli-mode-name "config-domain-vrf";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VRF name";
        }
      }

      // domain * / vrf * / master branch
      // domain * / vrf * / master hub
      // domain * / vrf * / master regional-hub
      // domain * / vrf * / master transit
      uses domain-master-grouping;

      // domain * / vrf * / border
      uses domain-border-grouping;
    }

    // domain * / master branch
    // domain * / master hub
    // domain * / master regional-hub
    // domain * / master transit
    uses domain-master-grouping {
      refine master {
        tailf:cli-diff-dependency "../vrf";
        tailf:meta-data "suppress-delete-error-invalid";
      }
    }

    // domain * / border
    uses domain-border-grouping {
      refine border {
        tailf:cli-diff-dependency "../vrf";
        tailf:meta-data "suppress-delete-error-invalid";
      }
      // domain * / border / advanced
      augment border {
        container advanced {
          tailf:info "Advanced configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-domain-br-advanced";
          presence true;
          uses domain-advanced-smart-probes-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// archive
  /// ========================================================================

  container archive {
    tailf:info "Archive the configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-archive";

    // archive / log config
    container log {
      tailf:info "Logging commands";
      container "config" {
        tailf:info "Logging changes to the running configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-archive-log-cfg";
        tailf:cli-full-command;

        // archive / log config / logging
        container logging {
          tailf:info "Modify config logging parameters";

          // archive / log config / logging enable
          leaf enable {
            tailf:info "Enable the config logger";
            tailf:cli-full-command;
            type empty;
          }

          // archive / log config / logging size
          leaf size {
            tailf:info "Maximum number of logged commands that will be kept "+
              "by the config log";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-1000>;;Queue length (default 100)";
              range "1..1000";
            }
            default 100;
          }
        }

        // archive / log config / hidekeys
        leaf hidekeys {
          tailf:info "suppress output (e.g. passwords) when "+
            "displaying logged commands";
          tailf:cli-full-command;
          type empty;
        }

        // archive / log config / notify
        container notify {
          tailf:info "Send logged commands to target applications";
          container syslog {
            tailf:info "Send logged commands as syslog messages";
            tailf:cli-delete-when-empty;
            presence "true";
            leaf contenttype {
              tailf:info "Type of the syslog message content";
              type enumeration {
                enum plaintext {
                  tailf:info "Plain text content";
                }
                enum xml {
                  tailf:info "XML content";
                }
              }
            }
          }
        }
        // archive / log config / record rc
        container record {
          tailf:info "What to record in the config logger";
          leaf rc {
            tailf:info "Record the PRC result";
            type empty;
          }
        }
      }
    }

    // archive / path
    leaf "path" {
      tailf:info "path for backups";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Write archive path";
      }
    }

    // archive / maximum
    leaf maximum {
      tailf:info "maximum number of backup copies";
      type uint8 {
        tailf:info "<1-14>;;maximum number of backup copies";
        range "1..14";
      }
    }

    // archive / write-memory
    leaf write-memory {
      tailf:info "Enable automatic backup generation during write memory";
      type empty;
    }
  }


  /// ========================================================================
  /// file
  /// ========================================================================

  container file {
    tailf:info "Adjust file system parameters";

    // file prompt
    leaf prompt {
      tailf:info "Prompt level for file operations";
      type enumeration {
        enum alert {
          tailf:info "Prompt only for destructive file operations";
        }
        enum noisy {
          tailf:info "Confirm all file operation parameters";
        }
        enum quiet {
          tailf:info "Seldom prompt for file operations";
        }
      }
      default alert;
    }

    // file verify
    leaf verify {
      tailf:info "Verify compressed IOS image checksum";
      type enumeration {
        enum "auto" {
          tailf:info "Enable automatic checksum verification";
        }
      }
    }
  }


  /// ========================================================================
  /// object-group
  /// ========================================================================

  container object-group {
    tailf:info "Configure ACL Object Group";

    // object-group network *
    list network {
      tailf:info "network group";
      tailf:cli-mode-name "config-network-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group network * / description
      leaf "description" {
        tailf:info "Network object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }

      // object-group network * / host *
      list host {
        tailf:info "Host address of the object-group member";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;Host address";
          }
        }
      }

      // object-group network * / subnet *
      list subnet {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "network-address network-mask";
        leaf network-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network address of the group members";
          }
        }
        leaf network-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Network mask";
          }
        }
      }
    }

    // object-group service *
    list service {
      tailf:info "service group";
      tailf:cli-mode-name "config-service-group";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group service * / description
      leaf "description" {
        tailf:info "Service object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }

      // object-group service * / icmp
      // object-group service * / tcp
      // object-group service * / udp
      leaf-list protocol {
        tailf:cli-drop-node-name;
        tailf:cli-list-syntax;
        type union {
          type uint8 {
            tailf:info "<0-255>;;An IP protocol number";
          }
          type enumeration {
            enum icmp {
              tailf:info "Internet Control Message Protocol";
              value 1;
            }
            enum tcp {
              tailf:info "Transmission Control Protocol";
              value 6;
            }
            enum udp {
              tailf:info "User Datagram Protocol";
              value 17;
            }
          }
        }
      }

      // object-group service * / icmp *
      container icmp-options {
        tailf:cli-drop-node-name;
        container icmp {
          tailf:info "Internet Control Message Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-icmp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / icmp range *
          list "range" {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-icmp-type;
            }
            leaf end {
              type object-group-service-icmp-type;
            }
          }
        }
      }

      // object-group service * / udp *
      container udp-options {
        tailf:cli-drop-node-name;
        container udp {
          tailf:info "User Datagram Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-udp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / udp range *
          list "range" {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-udp-type;
            }
            leaf end {
              type object-group-service-udp-type;
            }
          }
        }
      }

      // object-group service * / tcp *
      container tcp-options {
        tailf:cli-drop-node-name;
        container tcp {
          tailf:info "Transmission Control Protocol";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          list match {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type object-group-service-tcp-type;
            }
            uses object-group-service-protocol-match;
          }

          // object-group service * / tcp range *
          list "range" {
            tailf:info "Match only packets in the range of port numbers";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "begin end";
            leaf begin {
              type object-group-service-tcp-type;
            }
            leaf end {
              type object-group-service-tcp-type;
            }
          }
        }
      }

      // object-group service * / tcp-udp *
      container tcp-udp {
        tailf:info "TCP or UDP protocol";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        list match {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key port;
          leaf port {
            type object-group-service-tcp-udp-type;
          }
          uses object-group-service-protocol-match;
        }

        // object-group service * / tcp-udp range *
        list "range" {
          tailf:info "Match only packets in the range of port numbers";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "begin end";
          leaf begin {
            type object-group-service-tcp-udp-type;
          }
          leaf end {
            type object-group-service-tcp-udp-type;
          }
        }
      }
    }

    // object-group security *
    list security {
      tailf:info "security group";
      tailf:cli-mode-name "config-security-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;object-group name";
        }
      }

      // object-group security * / description
      leaf "description" {
        tailf:info "Security object group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this Object group";
        }
      }
    }
  }


  /// ========================================================================
  /// key
  /// ========================================================================

  container "key" {
    tailf:info "Key management";

    // key config-key password-encrypt
    container config-key {
      tailf:info "Set a private configuration key for general use";
      leaf password-encrypt {
        tailf:info "Set a private configuration key for password encryption";
        tailf:cli-no-value-on-delete;
        tailf:meta-data "support-encrypted-password";
        type tailf:aes-cfb-128-encrypted-string {
          tailf:info "LINE;;The config-key, minimum 8 characters not beginning with IOS special character(! # ;)";
        }
      }
    }

    // key chain *
    list chain {
      tailf:info "Key-chain management";
      tailf:cli-mode-name "config-keychain";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Key-chain name";
        }
      }

      // key chain * / key *
      list "key" {
        tailf:info "Configure a key";
        tailf:cli-mode-name "config-keychain-key";
        tailf:cli-full-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<0-2147483647>;;Key identifier";
            range "0..2147483647";
          }
        }

        // key chain * / key * / key-string
        container key-string {
          tailf:info "Set key string";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            // Note: required to not send 'no key-string..', which leaves sub-mode on device
            tailf:cli-reset-siblings;
          }
          uses password-grouping;
        }

        // key chain * / key * / cryptographic-algorithm
        leaf cryptographic-algorithm {
          tailf:info "Set cryptographic authentication algorithm";
          type enumeration {
            enum hmac-sha-1 {
              tailf:info "HMAC-SHA-1 authentication algorithm";
            }
            enum hmac-sha-256 {
              tailf:info "HMAC-SHA-256 authentication algorithm";
            }
            enum hmac-sha-384 {
              tailf:info "HMAC-SHA-384 authentication algorithm";
            }
            enum hmac-sha-512 {
              tailf:info "HMAC-SHA-512 authentication algorithm";
            }
            enum md5 {
              tailf:info "MD5 authentication algorithm";
            }
          }
        }

        // key chain * / key * / accept-lifetime
        container accept-lifetime {
          tailf:info "Set accept lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice accept-lifetime-choice {
            case global {
              uses lifetime-grouping;
            }
            // key chain * / key * / accept-lifetime local
            container local {
              tailf:info "Specify time in local timezone";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses lifetime-grouping;
            }
          }
        }

        // key chain * / key * / send-lifetime
        container send-lifetime {
          tailf:info "Set send lifetime of key";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice send-lifetime-choice {
            case global {
              uses lifetime-grouping;
            }
            // key chain * / key * / send-lifetime local
            container local {
              tailf:info "Specify time in local timezone";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              uses lifetime-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// flowspec
  /// ========================================================================

  container flowspec {
    tailf:info "FlowSpec configuration";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-flowspec";
    presence true;

    // flowspec / local-install interface-all
    container local-install {
      tailf:info "Local installation of flowspec policy";
      leaf interface-all {
        tailf:info "Install flowspec policy on all interfaces";
        type empty;
      }
    }

    // flowspec / address-family
    container address-family {
      tailf:info "Address Family Identifier Type (IPv4/IPv6)";

      // flowspec / address-family ipv4
      container ipv4 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-afi";

        // flowspec / addres-family ipv4 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }
      }

      // flowspec / address-family ipv6
      container ipv6 {
        tailf:info "IPv4 flow";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-flowspec-afi";

        // flowspec / addres-family ipv6 / local-install interface-all
        container local-install {
          tailf:info "Local installation of flowspec policy";
          leaf interface-all {
            tailf:info "Install flowspec policy on all interfaces";
            type empty;
          }
        }
      }
    }

    // flowspec / vrf *
    list vrf {
      tailf:info "VRF configuration";
      tailf:cli-mode-name "config-flowspec-vrf";
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VRF Name.";
        }
      }

      // flowspec / vrf * / address-family
      container address-family {
        tailf:info "Address Family Identifier Type (IPv4/IPv6)";

        // flowspec / vrf * / address-family ipv4
        container ipv4 {
          tailf:info "IPv4 flow";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-flowspec-vrf-afi";

          // flowspec / vrf * / addres-family ipv4 / local-install interface-all
          container local-install {
            tailf:info "Local installation of flowspec policy";
            leaf interface-all {
              tailf:info "Install flowspec policy on all interfaces";
              type empty;
            }
          }
        }

        // flowspec / vrf * / address-family ipv6
        container ipv6 {
          tailf:info "IPv4 flow";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-flowspec-vrf-afi";

          // flowspec / vrf * / addres-family ipv6 / local-install interface-all
          container local-install {
            tailf:info "Local installation of flowspec policy";
            leaf interface-all {
              tailf:info "Install flowspec policy on all interfaces";
              type empty;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// username
  /// ========================================================================

  list username {
    tailf:info "Establish User Name Authentication";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;User name";
      }
    }

    // username * privilege
    leaf privilege {
      tailf:info "Set user privilege level";
      type uint8 {
        tailf:info "<0-15>;;User privilege level";
        range "0..15";
      }
      default 1;
    }

    // username * secret
    container secret {
      tailf:info "Specify the secret for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf "type" {
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum "0" {
            tailf:info "Specifies an UNENCRYPTED secret will follow";
          }
          enum "4" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
          enum "5" {
            tailf:info "Specifies a HIDDEN secret will follow";
          }
          enum "8" {
            tailf:info "Specifies a PBKDF2 HASHED secret will follow";
          }
          enum "9" {
            tailf:info "Specifies a SCRYPT HASHED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-full-command;
        tailf:cli-disallow-value "0|4|5|8|9|key-chain";
        tailf:meta-data "secret-password";
        type string {
          tailf:info "WORD;;The HIDDEN user secret string";
        }
      }
    }

    // username * password
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }
  }


  /// ========================================================================
  /// table-map
  /// ========================================================================
  // Note: Must come before policer aggregate

  list table-map {
    tailf:info "Configure Table Map";
    tailf:cli-mode-name "config-tablemap";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;table-map name";
      }
    }

    // table-map * / map from * to
    container map {
      tailf:info "map to_value from from_value";
      list from {
        tailf:info "map from value";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-99>;;tablemap from value";
            range "0..99";
          }
        }
        leaf to {
          tailf:info "map to value";
          type uint8 {
            tailf:info "<0-99>;;tablemap to value";
            range "0..99";
          }
        }
      }
    }

    // table-map * / default
    leaf "default" {
      tailf:info "the default behavior for setting value not found in the "+
        "table map";
      type union {
        type uint8 {
          tailf:info "<0-99>;;tablemap default value";
          range "0..99";
        }
        type enumeration {
          enum copy {
            tailf:info "set the default behavior for value not found in "+
              "the table map to copy";
          }
          enum ignore {
            tailf:info "set the default behavior for value not found in "+
              "the table map to ignore";
          }
        }
      }
    }

  }


  /// ========================================================================
  /// sdm
  /// ========================================================================

  container sdm {
    tailf:info "Switch database management";

    // sdm prefer
    container prefer {
      tailf:info "Config TCAM and ASIC RAM size. "+
        "Warning: need to reset switch for configuration to take effect";
      tailf:cli-delete-when-empty;
      presence true;
      choice sdm-prefer-choice {

        // sdm prefer access
        leaf access {
          tailf:info "Access bias";
          type empty;
        }

        // sdm prefer default
        leaf "default" {
          tailf:info "Default bias";
          type empty;
        }

        // sdm prefer dual-ipv4-and-ipv6
        leaf dual-ipv4-and-ipv6 {
          tailf:info "Support both IPv4 and IPv6";
          type enumeration {
            enum "default" {
              tailf:info "Default bias";
            }
            enum routing {
              tailf:info "Unicast bias";
            }
            enum vlan {
              tailf:info "VLAN bias";
            }
          }
        }

        // sdm prefer routing
        leaf routing {
          tailf:info "Unicast bias";
          type empty;
        }

        // sdm prefer qos
        leaf qos {
          type empty;
        }

        // sdm prefer vlan
        leaf vlan {
          tailf:info "VLAN bias";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// mls
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container mls {
    tailf:info "mls global commands";
    tailf:cli-incomplete-no;

    // mls acl
    container acl {
      tailf:info "MLS ACL operation";

      // mls acl tcam
      container tcam {
        tailf:info "ACL TCAM";
        leaf default-result {
          tailf:info "Default result to be used during tcam programming";
          type enumeration {
            enum bridge {
              tailf:info "Bridge result";
            }
            enum deny {
              tailf:info "Deny result";
            }
            enum permit {
              tailf:info "Permit result";
            }
          }
        }

        container log-update {
          tailf:info "Log TCAM updates";
          presence true;
          leaf rate-limit-msg {
            tailf:info "Enable/Disable syslog ratelimiting";
            type enumeration {
              enum disable {
                tailf:info "Disable ratelimiting syslog";
              }
              enum enable {
                tailf:info "Enable syslog ratelimiting at 1 per second";
              }
            }
          }
        }

        // no mls acl tcam share-global
        leaf share-global {
          tailf:info "share global deny or permit any entries";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // mls cef
    container cef {
      tailf:info "cef keyword";
      container error {
        leaf action {
          type enumeration {
            enum reset;
            enum freeze;
          }
        }
      }
    }

    // mls ip
    container ip {
      tailf:info "ip keyword";

      // mls ip multicast
      container multicast {
        tailf:info "multicast keyword";
        tailf:cli-display-separated;
        presence true;

        // mls ip multicast consistency-check
        container consistency-check {
          tailf:info "Set consistency checking characteristics";
          presence true;
          container "type" {
            tailf:info "Set consistency checker type";
            // mls ip multicast consistency-check type rp-sp
            container rp-sp {
              tailf:info "Scan mlsm for Route, Switch Processor consistency";
              presence true;
            }
          }
          leaf settle-time {
            tailf:info "Settle time for entry/oif for consistancy-checker";
            type uint16 {
              tailf:info "<2-3600>;;Settle time for entry/oif in seconds";
              range "2..3600";
            }
          }
        }
        leaf flow-stat-timer {
          tailf:info "timer for flow statistic used by mls-msc and mlsm";
          type uint8 {
            tailf:info "<1-100>;;#seconds between one batch and another";
            range "1..100";
          }
        }
      }
    }

    // mls ipv6
    container ipv6 {
      tailf:info "Enable global ipv6 commands";

      // mls ipv6 vrf
      // NOTE: no mls ipv6 vrf requires device reboot
      leaf vrf {
        tailf:info "Enable IPv6 VRF";
        tailf:cli-full-command;
        type empty;
      }
    }

    // mls aging
    container aging {
      tailf:info "L3 aging";

      // mls aging fast
      container fast {
        tailf:info "L3 fast aging";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        leaf time {
          tailf:info "fast aging timeout value";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging time in seconds";
            range "1..128";
          }
        }
        leaf threshold {
          tailf:info "fast aging threshold";
          type uint8 {
            tailf:info "<1-128>;;L3 fast aging theshold packet count";
            range "1..128";
          }
        }
      }

      // mls aging normal
      container normal {
        tailf:info "normal aging keyword";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<32-4092>;;L3 aging timeout in second";
            range "32..4092";
          }
        }
      }

      // mls aging long
      container long {
        tailf:info "long aging keyword";
        leaf timeout {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<64-1920>;;long aging timeout";
            range "64..1920";
          }
        }
      }
    }

    // mls netflow
    container netflow {
      tailf:info "netflow keyword";
      tailf:cli-delete-when-empty;
      presence true;

      // mls netflow interface
      leaf interface {
        type empty;
      }

      // mls netflow usage notify
      container usage {
        container notify {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<20-100>;;threshold percentage";
              range "20..100";
            }
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<120-1000000>;;time interval in seconds";
              range "120..1000000";
            }
          }
        }
      }
    }

    // mls flow
    container flow {
      tailf:info "flowmask keyword";

      // mls flow ip
      leaf ip {
        tailf:info "flowmask ip keyword";
        type enumeration {
          enum interface-destination {
            tailf:info "interface-destination flow keyword";
          }
          enum interface-destination-source {
            tailf:info "interface-destination-source flow keyword";
          }
          enum interface-full {
            tailf:info "interface-full flow keyword";
          }
          enum interface-source {
            tailf:info "interface-source only flow keyword";
          }
        }
      }

      // mls flow ipv6
      choice ipv6-choice {
        container no-ipv6 {
          tailf:cli-drop-node-name;
          // no mls flow ipv6
          leaf ipv6 {
            tailf:cli-boolean-no;
            tailf:cli-full-no;
            type boolean;
            default true;
          }
        }
        container ipv6 {
          tailf:info "flowmask ipv6 keyword";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          choice ipv6-choice2 {
            leaf interface-destination {
              tailf:info "interface-destination flow keyword";
              type empty;
            }
            leaf interface-destination-source {
              tailf:info "interface-destination-source flow keyword";
              type empty;
            }
            leaf interface-full {
              tailf:info "interface-full flow keyword";
              type empty;
            }
            leaf interface-source {
              tailf:info "interface-source only flow keyword";
              type empty;
            }
          }
        }
      }
    }

    // mls sampling
    container sampling {
      tailf:info "sampling keyword";

      // mls sampling time-based
      leaf time-based {
        type uint16;
      }
    }

    // mls qos
    container mls-qos-conf {
      tailf:cli-drop-node-name;
      leaf qos {
        type empty;
      }
    }

    // mls qos
    container qos {
      tailf:info "QoS parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // mls qos aggregate-policer *
      list aggregate-policer {
        tailf:info "Assign aggregate policer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;aggregate policer name";
          }
        }
        leaf target-bit-rate {
          tailf:cli-drop-node-name;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        leaf burst-normal {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint32 {
            tailf:info "<1000-31250000>;;Normal burst bytes";
            range "1000..31250000";
          }
        }
        leaf burst-max {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          when "../burst-normal" {
            tailf:dependency "../burst-normal";
          }
          type uint32 {
            tailf:info "<1000-31250000>;;Maximum burst bytes";
            range "1000..31250000";
          }
        }
        leaf pir {
          tailf:info "PIR";
          tailf:cli-optional-in-sequence;
          type uint64 {
            tailf:info "<32000-60000000000>;;Target Bit Rate (bits per "
              +"second) (postfix k, m, g optional; decimal point allowed)";
            range "32000..60000000000";
          }
        }
        container conform-action {
          tailf:info "action when rate is not exceeded";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          choice action-choice {
            leaf drop {
              tailf:info "drop packet";
              type empty;
            }
            leaf set-dscp-transmit {
              tailf:info "set dscp and send it";
              type dscp-type;
            }
            leaf set-mpls-exp-imposition-transmit {
              tailf:info "set exp at tag imposition and send it";
              type uint8 {
                tailf:info "<0-7>;;new exp";
                range "0..7";
              }
            }
            leaf set-prec-transmit {
              tailf:info "rewrite packet precedence and send it";
              type uint8 {
                tailf:info "<0-7>;;new precedence";
                range "0..7";
              }
            }
            leaf transmit {
              tailf:info "transmit packet";
              type empty;
            }
          }
        }
        leaf exceed-action {
          tailf:info "action when rate is exceeded";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
        leaf violate-action {
          tailf:info "action when rate violated";
          type enumeration {
            enum drop {
              tailf:info "drop packet";
            }
            enum policed-dscp-transmit {
              tailf:info "change dscp per policed-dscp map and send it";
            }
            enum transmit {
              tailf:info "transmit packet";
            }
          }
        }
      }

      // mls qos cos policy-map
      container cos {
        tailf:info "Configure CoS setting";
        leaf policy-map {
          tailf:info "Set by Policy-Map";
          type empty;
        }
      }

      // mls qos rewrite
      container rewrite {
        tailf:info "packet qos rewrite enable/disable";
        container ip {
          tailf:info "ip packet qos rewrite enable/disable";
          container dscp {
            tailf:info "packet ip dscp rewrite enable/disable";
            presence true;
            leaf slot {
              tailf:info "slot number";
              type string {
                tailf:info "WORD;;Slots seperated by commas. Valid slots: 1,2,"
                  +"3,4,5,6,7,8,9";
              }
            }
          }
        }
      }

      // mls qos map
      container map {
        tailf:info "Define QoS mapping";

        // mls qos map dscp-mutation *
        list dscp-mutation {
          tailf:info "Configure dscp-mutation map";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;DSCP mutation map name";
            }
          }
          leaf mutated-dscp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp2 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp3 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp4 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp5 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp6 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp7 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          leaf mutated-dscp8 {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-63>;;dscp values separated by spaces "+
                "(8 values total)";
              range "0..63";
            }
          }
          // mls qos map dscp-mutation * to
          leaf to {
            tailf:info "Specify egress DSCPs";
            type uint16 {
              tailf:info "<0-63>;;dscp value";
              range "0..63";
            }
          }
        }

        // mls qos map cos-dscp *
        leaf-list cos-dscp {
          tailf:info "cos-dscp map: eight dscp values for cos 0-7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<0-63>;;8 dscp values separated by spaces";
            range "0..63";
          }
        }

        // mls qos map ip-prec-dscp *
        leaf-list ip-prec-dscp {
          tailf:info "dscp values for ip precedences 0 - 7";
          tailf:cli-flat-list-syntax;
          tailf:cli-no-value-on-delete;
          type uint8 {
            tailf:info "<0-63>;;8 dscp values separated by spaces";
            range "0..63";
          }
        }

        // mls qos map exp-mutation *
        list exp-mutation {
          tailf:info "exp-mutation map keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;exp-mutation map name";
            }
          }
          leaf mutated-exp1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp3 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp4 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp5 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp6 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp7 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
          leaf mutated-exp8 {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-7>;;exp values separated by spaces "+
                "(8 values total)";
              range "0..7";
            }
          }
        }
      }

      // mls qos srr-queue
      container srr-queue {
        tailf:info "Configure SRR receive queues";

        // mls qos srr-queue input cos-map *
        // mls qos srr-queue output cos-map *
        // mls qos srr-queue input dscp-map *
        // mls qos srr-queue output dscp-map *
        // mls qos srr-queue *
        list cos-dscp-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:meta-data "replace-mls-qos-srr-queue";
          tailf:ned-data "." {
            tailf:transaction to;
          }
          key "direction maptype";
          leaf direction {
            type enumeration {
              enum "input" {
                tailf:info "input keyword";
              }
              enum "output" {
                tailf:info "output keyword";
              }
            }
          }
          leaf maptype {
            type enumeration {
              enum cos-map {
                tailf:info "Configure cos-map for a queue id";
              }
              enum dscp-map {
                tailf:info "Configure dscp-map for a queue id";
              }
            }
          }
          list queue-threshold-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-incomplete-command;
            key "queue threshold";
            leaf queue {
              tailf:info "Assign COS|DSCP values to a queue";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<num>;;enter <cos|dscp>-map queue id";
              }
            }
            leaf threshold {
              tailf:info "Assign COS|DSCP values to a queue threshold";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<num>;;enter <cos|dscp>-map threshold id";
              }
            }
            leaf-list values {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type uint8 {
                tailf:info "cos|dscp values separated by spaces";
              }
            }
          }
        }

        // mls qos srr-queue input
        container "input" {
          tailf:cli-incomplete-no;

          // mls qos srr-queue input priority-queue *
          list priority-queue {
            tailf:info "Configure priority scheduling";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;enter priority queue number [1-2]";
              }
            }
            leaf bandwidth {
              tailf:info "ingress priority queue bandwidth % of stack ring";
              tailf:cli-no-name-on-delete;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-40>;;enter bandwidth number [0-40]";
              }
            }
          }

          // mls qos srr-queue input bandwidth
          container bandwidth {
            tailf:info "Configure SRR bandwidth";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf weight1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter bandwidth weight for queue id 1";
              }
            }
            leaf weight2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter bandwidth weight for queue id 2";
              }
            }
          }

          // mls qos srr-queue input threshold *
          list threshold {
            tailf:info "Configure queue tail-drop thresholds";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;enter threshold queue id (1-2)";
              }
            }
            leaf threshold-percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter percent of queue size for threshold 1";
              }
            }
            leaf threshold-percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<1-100>;;enter percent of queue size for threshold 2";
              }
            }
          }

          // mls qos srr-queue input buffers
          container buffers {
            tailf:info "Configure buffer allocation";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf percentage1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-100>;;enter percent of buffers for queue 1";
              }
            }
            leaf percentage2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint8 {
                tailf:info "<0-100>;;enter percent of buffers for queue 2";
              }
            }
          }
        }
      }

      // mls qos queue-set output
      container queue-set {
        tailf:info "Choose a queue set for this queue";
        container "output" {
          tailf:info "Direction the command applies for this command";

          // mls qos queue-set output threshold
          list threshold-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "queue threshold";
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;queue-set id";
              }
            }
            leaf threshold {
              tailf:info "Assign threshold values to a queue";
              tailf:cli-expose-key-name;
              type uint8 {
                tailf:info "<1-4>;;enter queue id in this queue set";
              }
            }
            leaf drop-threshold1 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter drop threshold1 1-3200";
              }
            }
            leaf drop-threshold2 {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter drop threshold2 1-3200";
              }
            }
            leaf reserved-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-100>;;enter reserved threshold 1-100";
              }
            }
            leaf maximum-threshold {
              tailf:cli-drop-node-name;
              tailf:cli-no-value-on-delete;
              type uint16 {
                tailf:info "<1-3200>;;enter maximum threshold 1-3200";
              }
            }
          }

          // mls qos queue-set output buffers
          list buffers-list {

            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key queue;
            leaf queue {
              type uint8 {
                tailf:info "<1-2>;;queue-set id";
              }
            }
            container buffers {
              tailf:info "mls qos queue-set output buffers";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf allocation1 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 1 0-";
                }
              }
              leaf allocation2 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<1-100>;;enter buffer percentage for "+
                    "queue 2 1-100 (includes CPU buffer";
                }
              }
              leaf allocation3 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 3 0-99";
                }
              }
              leaf allocation4 {
                tailf:cli-drop-node-name;
                tailf:cli-no-value-on-delete;
                type uint8 {
                  tailf:info "<0-99>;;enter buffer percentage for queue 4 0-99";
                }
              }
            }
          }
        }
      }

      // mls qos min-reserve *
      list min-reserve {
        tailf:info "Configure min-reserve buffers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key level;
        leaf level {
          type uint8 {
            tailf:info "<1-8>;;Configure min-reserve level";
            range "1..8";
          }
        }
        leaf buffersize {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<10-170>;;Configure min-reserve buffers";
            range "10..170";
          }
        }
      }
    }

    // mls rate-limit
    container rate-limit {
      tailf:info "Rate limit different behaviors";

      // mls rate-limit multicast ipv4
      container multicast {
        tailf:info "Rate limiting for Multicast packets";

        // mls rate-limit multicast ipv4 *
        list ipv4 {
          tailf:info "Rate limiters for IPv4 traffic";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type enumeration {
              enum fib-miss {
                tailf:info "Rate limiting of fib-missed multicast packets";
              }
              enum connected {
                tailf:info "Rate limiting of multicast packets from directly "+
                "connected source";
              }
              enum ip-options {
                tailf:info "rate limiting of multicast packets with ip options";
              }
              enum igmp {
                tailf:info "Rate limiting of the IGMP protocol packets";
              }
              enum partial {
                tailf:info "rate limiting of multicast packets during "+
                "partial-SC state";
              }
              enum pim {
                tailf:info "Rate limiting of the PIM protocol packets";
              }
              enum tiny-fragment {
                tailf:info "packets with fragment offset equal to 1";
              }
              enum non-rpf {
                tailf:info "Rate limiting of non-rpf multicast packets";
              }
            }
          }
          leaf pps {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
      }

      // mls rate-limit all
      container all {
        tailf:info "Rate Limiting for both Unicast and Multicast packets";

        // mls rate-limit all mtu-failure
        container mtu-failure {
          tailf:info "MTU failure cases";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf pps {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }

        // mls rate-limit all ttl-failure
        container ttl-failure {
          tailf:info "TTL failure cases";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf pps {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
      }

      // mls rate-limit layer2
      container layer2 {
        tailf:info "layer2 protocol cases";

        // mls rate-limit layer2 l2pt
        container l2pt {
          tailf:info "layer2 protocol tunnelling packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }

        // mls rate-limit layer2 pdu
        container pdu {
          tailf:info "layer2 protocol data unit packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }

          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }

        // mls rate-limit layer2 mac-security
        container mac-security {
          tailf:info "Mac security traffics";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf packets-per-second {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<10-1000000>;;packets per second";
              range "10..1000000";
            }
          }
          leaf packets-in-burst {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-255>;;packets in burst";
              range "1..255";
            }
          }
        }
      }
    }

    // mls verify
    container verify {
      tailf:info "enable hardware packet parsing error checks";
      container ip {
        tailf:info "check on IP packets";

        // no mls verify ip checksum
        leaf checksum {
          tailf:info "check for packet checksum errors";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }

        container "length" {
          tailf:info "check for packet length errors";

          // no mls verify ip length consistent
          leaf consistent {
            tailf:info "check length in header against physical frame length";
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
          // no mls verify ip length minimum
          leaf minimum {
            tailf:info "check for minimum packet length";
            tailf:cli-boolean-no;
            type boolean;
            default true;
          }
        }
        leaf same-address {
          tailf:info "check for packet having equal source and destination IP "
            +"addresses";
          type empty;
        }
        leaf syslog {
          tailf:info "syslog packet parse errors";
          type empty;
        }
      }
    }

    // mls mpls
    container mpls {
      tailf:info "configure global MPLS params";

      // mls mpls tunnel-recir
      leaf tunnel-recir {
        tailf:info "Recirculate Tunnel packets";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// policer
  /// ========================================================================
  // Note: must come before class-map and policy-map.

  container policer {
    tailf:info "Switch policer";

    // policer aggregate *
    list aggregate {
      tailf:info "Named aggregate policer";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;aggregate policer Name";
        }
      }
      // cir <cir-bps>
      leaf cir {
        tailf:info "Committed information rate";
        type uint32 {
          tailf:info "<8000-1000000000>;;Bits per second";
          range "8000..1000000000";
        }
      }
      // bc <burst>
      leaf bc {
        tailf:info "Conform burst";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<8000-1000000000>;;Burst bytes";
          range "8000..1000000000";
        }
      }
      // conform-action
      leaf conform-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf set-qos-transmit {
        tailf:info "set qos-group and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-99>;;new qos-group";
          range "0..99";
        }
      }
      leaf set-dot1ad-dei-transmit {
        tailf:info "set dei and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type uint8 {
          tailf:info "<0-1>;;new dei value";
          range "0..1";
        }
      }
      leaf set-prec-transmit {
        tailf:info "rewrite packet precedence and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type prec_value-type;
      }
      container set-prec-transmit-table {
        when "../set-prec-transmit" {
          tailf:dependency "../set-prec-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf set-dscp-transmit {
        tailf:info "set dscp and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type dscp-type;
      }
      container set-dscp-transmit-table {
        when "../set-dscp-transmit" {
          tailf:dependency "../set-dscp-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf set-cos-transmit {
        tailf:info "set cos and send it";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type cos_value-type;
      }
      container set-cos-transmit-table {
        when "../set-cos-transmit" {
          tailf:dependency "../set-cos-transmit";
        }
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf table {
          tailf:info "Set packet cos from cos based on table map";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../table-map/name";
          }
          type string {
            tailf:info "WORD;;table-map name";
          }
        }
      }
      leaf transmit {
        tailf:info "transmit packet";
        when "../conform-action" {
          tailf:dependency "../conform-action";
        }
        tailf:cli-optional-in-sequence;
        type empty;
      }
      // exceed-action
      leaf exceed-action {
        tailf:info "action when rate is within conform and conform + "+
          "exceed burst";
        type empty;
      }
      leaf drop {
        tailf:info "drop packet";
        when "../exceed-action" {
          tailf:dependency "../exceed-action";
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-full-command;
        type empty;
      }
      container exceed-transmit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-flatten-container;
        leaf transmit {
          tailf:info "transmit packet";
          when "../../exceed-action" {
            tailf:dependency "../../exceed-action";
          }
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// redundancy
  /// ========================================================================

  container redundancy {
    tailf:info "Enter redundancy mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-red";
    presence true;

    // redundancy / maintenance-mode
    leaf maintenance-mode {
      tailf:info "Enable/Disable maintenance mode ";
      //FIXME: conform hook
      type empty;
    }

    // redundancy / mode
    leaf mode {
      tailf:info "redundancy mode for this chassis";
      type enumeration {
        enum rpr {
          tailf:info "Route Processor Redundancy";
        }
        enum rpr-plus {
          tailf:info "Route Processor Redundancy Plus";
        }
        enum sso {
          tailf:info "Stateful Switchover";
        }
        enum none {
          tailf:info "None";
        }
      }
    }

    // redundancy / linecard-group *
    list linecard-group {
      tailf:info "Enter linecard redundancy submode";
      tailf:cli-mode-name "config-red-lc";
      tailf:cli-incomplete-command;
      tailf:cli-recursive-delete;
      key id;
      leaf id {
        type uint32 {
          tailf:info "ID;;linecard-group identifier";
        }
      }
      leaf cable {
        tailf:info "CMTS LC Redundancy type";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      leaf internal-switch {
        tailf:info "Internal Switch Redundancy type";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      // redundancy / linecard-group * / description
      leaf "description" {
        tailf:info "Assign linecard group description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Linecard group description";
        }
      }

      // redundancy / linecard-group * / class
      leaf class {
        tailf:info "assign a class (1:N, 1:1) to this group";
        tailf:cli-full-command;
        type enumeration {
          enum "1:1" {
            tailf:info "One to One Class";
          }
          enum "1:N" {
            tailf:info "One to N Class";
          }
        }
      }

      // redundancy / linecard-group * / reserve cardtype
      container reserve {
        tailf:info "Reserve card type for redundancy group";
        leaf cardtype {
          tailf:info "Reserve card type for redundancy group";
          type string {
            tailf:info "<0-4294967295>;;Enter reserve cardtype in "+
              "Hex or Decimal";
          }
        }
      }

      // redundancy / linecard-group * / rf-switch
      container rf-switch {
        tailf:info "Specify/Change RF-switch parameters (Optional Command)";
        // redundancy / linecard-group * / rf-switch snmp-community
        leaf snmp-community {
          tailf:info "SNMP community name";
          type string {
            tailf:info "WORD;;snmp community name";
          }
        }
      }

      // redundancy / linecard-group * / member
      container member {
        tailf:info "Add or remove a member from this LC redundancy";

        // redundancy / linecard-group * / member slot *
        list slot {
          tailf:info "slot number to be added or removed from this "+
            "linecard group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<3-12>;;primary/secondary slot number";
              range "3..12";
            }
          }
          choice primary-secondary-choice {
            leaf primary {
              tailf:info "primary slot of the linecard group";
              type empty;
            }
            leaf secondary {
              tailf:info "secondary slot of the linecard group";
              type empty;
            }
          }
        }

        // redundancy / linecard-group * / member subslot *
        list subslot {
          tailf:info "subslot number to be added or removed from this "+
            "linecard group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-suppress-list-no;
          key id;
          leaf id {
            type string {
              tailf:info "<5-8>/<0-1>";
            }
          }
          // redundancy / linecard-group * / member subslot * working
          leaf working {
            tailf:info "working slot in this linecard group";
            type empty;
          }

          // redundancy / linecard-group * / member subslot * protect
          container protect {
            tailf:info "protect slot of this linecard group";
            tailf:cli-display-separated;
            presence true;
            choice config-choice {

              // .. member subslot * protect config ?
              leaf "config" {
                tailf:info "Specifiy the subslot for cable upstream config";
                tailf:cli-incomplete-no;
                type string {
                  tailf:info "<5-8>/<0-1>;;Slot/Subslot";
                }
              }

              // .. no member subslot * protect config
              container no-config {
                tailf:cli-drop-node-name;
                leaf "config" {
                  tailf:cli-boolean-no;
                  tailf:cli-full-command;
                  type boolean;
                  default true;
                }
              }
            }
          }
        }
      }

      // redundancy / linecard-group * / no revertive
      container conf {
        tailf:cli-drop-node-name;
        leaf revertive {
          tailf:info "Make redundancy relationship revertive";
          type empty;
        }
      }
    }

    // redundancy / main-cpu
    container main-cpu {
      tailf:info "Enter main-cpu mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-r-mc";

      // redundancy / main-cpu / auto-sync
      container auto-sync {
        tailf:info "Sync elements";
        leaf running-config {
          type empty;
        }
        leaf config-register {
          type empty;
        }
        leaf bootvar {
          type empty;
        }
        leaf startup-config {
          type empty;
        }
        leaf standard {
          type empty;
        }
      }

      // redundancy / main-cpu / switchover
      container switchover {
        tailf:info "Configuration of switchover";

        // redundancy / main-cpu / switchover pxf restart
        container pxf {
          tailf:info "PXF switchover options";
          container restart {
            tailf:info "PXF restarts";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf number-of-crashes {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<1-25>;;Number of PXF restarts before a switchover";
                range "1..25";
              }
            }
            leaf time-period {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-120>;;Interval (in hours) over which restart "+
                  "count is accumulated";
                range "0..120";
              }
            }
          }
        }
      }
    }

    // redundancy / interchassis group *
    container interchassis {
      tailf:info "Enter interchassis mode";
      list group {
        tailf:info "Enter the redundancy group number";
        tailf:cli-mode-name "conppfig-r-ic";
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-4294967295>;;The redundancy group number";
            range "1..4294967295";
          }
        }

        // redundancy / interchassis group * / member ip
        container member {
          tailf:info "specify a redundancy group member";
          leaf ip {
            tailf:info "specify the redundancy group member using an ip "+
              "address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;the ip address of the remote redundancy "+
                "group member";
            }
          }
        }

        // redundancy / interchassis group * / mlacp
        container mlacp {
          tailf:info "mLACP interchassis redundancy group subcommands";
          // redundancy / interchassis group * / mlacp system-mac
          leaf system-mac {
            tailf:info "mLACP redundancy group mac address";
            type string {
              tailf:info "H.H.H;;mLACP redundancy group mac address";
            }
          }
          // redundancy / interchassis group * / mlacp system-priority
          leaf system-priority {
            tailf:info "mLACP system priority";
            type uint16 {
              tailf:info "<0-65535>;;Priority value";
            }
          }
          // redundancy / interchassis group * / mlacp node-id
          leaf node-id {
            tailf:info "mLACP node-id, appended to LACP port ids";
            type uint8 {
              tailf:info "<0-7>;;mLACP node-id";
              range "0..7";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// bfd-template
  /// ========================================================================

  container bfd-template {
    tailf:info "BFD template configuration";

    // bfd-template single-hop *
    list single-hop {
      tailf:info "Single-hop template";
      tailf:cli-mode-name "config-bfd";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;BFD template name";
        }
      }

      // bfd-template single-hop * / interval
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min-tx {
          tailf:info "Minimum transmit interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<4-999>;;Milliseconds";
            range "4..999";
          }
        }
        leaf min-rx {
          tailf:info "Minimum receive interval capability";
          tailf:code-name "bfd-template-min-rx";
          type uint16 {
            tailf:info "<4-999>;;Milliseconds";
            range "4..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// process-max-time
  /// ========================================================================

  leaf process-max-time {
    tailf:info "Maximum time for process to run before voluntarily relinquishing processor";
    type uint8 {
      tailf:info "<20-200>;;The number of millisecs before voluntary suspend";
      range "20..200";
    }
  }

  /// ========================================================================
  /// map-class
  /// ========================================================================

  container map-class {
    tailf:info "Configure static map class";

    // map-class frame-relay *
    list frame-relay {
      tailf:info "Frame Relay";
      tailf:cli-mode-name "config-map-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Static map class name";
        }
      }

      // map-class frame-relay * / frame-relay
      container frame-relay {
        tailf:info "Configure Map parameters";

        // map-class frame-relay * / frame-relay fragment
        leaf fragment {
          tailf:info "Requires Frame Relay traffic-shaping to be configured "+
            "at the interface level";
          type uint16 {
            tailf:info "<16-1600>;;Define fragment size, Bytes";
            range "16..1600";
          }
        }
      }

      // map-class frame-relay * / service-policy
      container service-policy {
        tailf:info "class-based service policy";
        uses service-policy-grouping;
      }
    }
  }


  /// ========================================================================
  /// class
  /// ========================================================================

  container class {
    tailf:info "Configure cem class parameters";

    // class cem *
    list cem {
      tailf:info "Circuit emulation template";
      tailf:cli-mode-name "config-cem-class";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;cem class name";
        }
      }

      // class cem * / payload-size
      leaf payload-size {
        tailf:info "IP payload size in bytes";
        type uint16 {
          tailf:info "<32-1312>;;IP payload size";
          range "32..1312";
        }
      }

      // class cem * / dejitter-buffer
      leaf dejitter-buffer {
        tailf:info "dejitter in ms";
        type uint16 {
          tailf:info "<1-500>;;1-500ms";
          range "1..500";
        }
      }

      // class cem * / idle-pattern
      leaf idle-pattern {
        tailf:info "Set 8 bit idle pattern";
        type string {
          tailf:info "<0x0-0xFF>;;8 bit hex number";
        }
      }
    }
  }


  /// ========================================================================
  /// class-map
  /// ========================================================================

  list class-map {
    tailf:info "Configure QoS Class Map";
    tailf:cli-mode-name "config-cmap";
    tailf:cli-no-key-completion;
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;
    tailf:cli-full-command;
    tailf:cli-diff-dependency "../mls";

    // class-map *
    key name;
    leaf name {
      tailf:cli-disallow-value "type|match-any|match-all";
      type string {
        tailf:info "WORD;;class-map name";
      }
    }

    // class-map type *
    leaf "type" {
      tailf:info "type of the class-map";
      tailf:cli-optional-in-sequence;
      tailf:cli-prefix-key;
      tailf:cli-incomplete-command;
      type enumeration {
        enum access-control {
          tailf:info "access-control specific class-map";
        }
        enum inspect {
          tailf:info "Configure Firewall Class Map";
        }
        enum logging {
          tailf:info "Class map for control-plane packet logging";
        }
        enum port-filter {
          tailf:info "Class map for port filter";
        }
        enum queue-threshold {
          tailf:info "Class map for queue threshold";
        }
        enum stack {
          tailf:info "class-map for protocol header stack specification";
        }
        enum traffic {
          tailf:info "Configure a subscriber policy traffic classmap";
        }
        enum appnav {
          tailf:info "Configure a APPNAV Class Map";
        }
        enum multicast-flows {
          tailf:info "multicast class-maps";
        }
      }
    }

    // class-map <protocol>
    leaf protocol {
      when "(../type) and (../type = 'inspect')" {
        tailf:dependency "../type";
      }
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      tailf:cli-optional-in-sequence;
      tailf:cli-incomplete-command;
      type enumeration {
        enum aol {
          tailf:info "Configure CBAC class-map for IM-AOL protocol";
        }
        enum edonkey {
          tailf:info "eDonkey";
        }
        enum fasttrack {
          tailf:info "FastTrack Traffic - KaZaA, Morpheus, Grokster...";
        }
        enum gnutella {
          tailf:info "Gnutella Version2 Traffic - BearShare, Shareeza, Morpheus ...";
        }
        enum http {
          tailf:info "Configure CBAC class-map for HTTP protocol";
        }
        enum imap {
          tailf:info "Configure CBAC class-map for IMAP protocol";
        }
        enum kazaa2 {
          tailf:info "Kazaa Version 2";
        }
        enum msnmsgr {
          tailf:info "Configure CBAC class-map for IM-MSN protocol";
        }
        enum pop3 {
          tailf:info "Configure CBAC class-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC class-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC class-map for RPC protocol";
        }
        enum ymsgr {
          tailf:info "Configure CBAC class-map for IM-YAHOO protocol";
        }
      }
    }

    // class-map * <match-any|match-all>
    leaf prematch {
      tailf:cli-drop-node-name;
      tailf:cli-no-keyword;
      tailf:cli-prefix-key;
      type enumeration {
        enum match-all {
          tailf:info "Logical-AND all matching statements under this classmap";
        }
        enum match-any {
          tailf:info "Logical-OR all matching statements under this classmap";
        }
      }
    }

    // class-map * / description
    leaf "description" {
      tailf:info "Class-Map description";
      tailf:cli-break-sequence-commands;
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this class-map (up to 200 characters)";
      }
    }

    // class-map * / match
    container match {
      tailf:info "classification criteria";
      uses class-map-match-grouping;
      container not {
        tailf:info "Negate this match result";
        uses class-map-match-grouping;
      }
    }
  }


  /// ========================================================================
  /// class-map type control subscriber
  /// ========================================================================

  // class-map type control subscriber *
  container class-map-filter-control {
    tailf:cli-drop-node-name;
    list class-map {
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name "config-filter-control-classmap";
      tailf:cli-suppress-list-no;
      tailf:cli-no-key-completion;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      // class-map type control subscriber *
      leaf "type" {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "Domain name of the class map";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "TRUE if everything matches in the class-map";
          }
          enum match-any {
            tailf:info "TRUE if anything matches in the class-map";
          }
          enum match-none {
            tailf:info "TRUE if nothing matches in the class-map";
          }
        }
      }

      // class-map type control subscriber * / match
      container match {
        tailf:info "match filter";

        // class-map type control subscriber * / match method
        container method {
          tailf:info "match the type of authentication method from an event";
          // class-map type control subscriber * / match method webauth
          leaf webauth {
            tailf:info "webauth";
            type empty;
          }
          // class-map type control subscriber * / match method mab
          leaf mab {
            tailf:info "mab";
            type empty;
          }
          // class-map type control subscriber * match method dot1x
          leaf dot1x {
            tailf:info "dot1x";
            type empty;
          }
        }

        // class-map type control subscriber * / match result-type
        container result-type {
          tailf:info "match the result type, optionally for a specific method";

          // class-map type control subscriber * / match result-type method
          container method {
            tailf:info "match the result of a particular method";

            // class-map type control subscriber * / match result-type method mab
            container dot1x {
              tailf:info "dot1x result";
              uses result-type-method-grouping;
            }

            // class-map type control subscriber * / match result-type method mab
            container mab {
              tailf:info "mab result";
              uses result-type-method-grouping;
            }

            // class-map type control subscriber * / match result-type method webauth
            container webauth {
              tailf:info "webauth result";
              uses result-type-method-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// policy-map
  /// ========================================================================

  list policy-map {
    tailf:info "Configure QoS Policy Map";
    tailf:cli-mode-name "config-pmap";
    // When deleting policy-map, delete before following config:
    tailf:cli-diff-dependency "../mls/qos/aggregate-policer";
    tailf:cli-diff-dependency "../policer/aggregate";
    tailf:cli-diff-dependency "../tailfned/police";

    key name;
    leaf name {
      tailf:cli-disallow-value "(type)|(http)|(im)|(imap)|(p2p)|(pop3)|(smtp)|(sunrpc)";
      type string {
        tailf:info "WORD;;policy-map name";
      }
    }

    // policy-map type *
    leaf "type" {
      tailf:info "type of the policy-map";
      tailf:cli-prefix-key;
      type enumeration {
        enum inspect {
          tailf:info "Configure Firewall Policy Map";
        }
        enum performance-monitor {
          tailf:info "Performance monitoring policy-map type";
        }
        enum mace {
          tailf:info "Configure MACE Policy Map";
        }
        enum packet-service {
          tailf:info "Configure Packet Service Policy Map";
        }
        enum appnav {
          tailf:info "Configure a APPNAV Policy Map";
        }
      }
    }

    leaf protocol {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      type enumeration {
        enum http {
          tailf:info "Configure CBAC policy-map for HTTP protocol";
        }
        enum im {
          tailf:info "Configure CBAC policy-map for IM protocol";
        }
        enum imap {
          tailf:info "Configure CBAC policy-map for IMAP protocol";
        }
        enum p2p {
          tailf:info "Configure CBAC policy-map for P2P protocols";
        }
        enum pop3 {
          tailf:info "Configure CBAC policy-map for POP3 protocol";
        }
        enum smtp {
          tailf:info "Configure CBAC policy-map for SMTP protocol";
        }
        enum sunrpc {
          tailf:info "Configure CBAC policy-map for RPC protocol";
        }
      }
    }

    // policy-map * / description
    leaf "description" {
      tailf:info "Policy-Map description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this policy-map (up to 200 characters)";
        length "1..200";
      }
    }

    // policy-map * / class *
    list class {
      tailf:info "policy criteria";
      tailf:cli-mode-name "config-pmap-c";
      tailf:cli-show-long-obu-diffs;
      tailf:cli-diff-dependency "../../class-map";
      ordered-by user;
      key name;
      // policy-map * / class type inspect *
      leaf "type" {
        tailf:info "type of the class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum inspect {
            tailf:info "Configure CBAC Class Map";
          }
        }
      }
      // policy-map * / class *
      leaf name {
        tailf:cli-disallow-value "type|class-default";
        tailf:non-strict-leafref {
          path "../../../class-map/name";
        }
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      uses policy-map-class-grouping;
    }

    // policy-map * / class class-default
    container class-default {
      tailf:cli-drop-node-name;
      list class {
        tailf:info "policy criteria";
        tailf:cli-mode-name "config-pmap-c";
        key name;
        leaf name {
          type enumeration {
            enum class-default {
              tailf:info "System default class matching otherwise "+
                "unclassified packets";
            }
          }
        }
        uses policy-map-class-grouping;
      }
    }
  }


  /// ========================================================================
  /// policy-map type control subscriber
  /// ========================================================================

  container policy-map-event-control {
    tailf:cli-drop-node-name;
    list policy-map {
      tailf:info "Configure QoS Policy Map";
      tailf:cli-mode-name "config-event-control-policymap";
      tailf:cli-sequence-commands;
      key name;
      leaf name {
        tailf:cli-disallow-value "type";
        tailf:cli-diff-dependency "../../../class-map";
        tailf:cli-diff-dependency "../../../class-map-filter-control/class-map";
        type string {
          tailf:info "WORD;;policy-map name";
        }
      }
      /// policy-map type control subscriber *
      leaf "type" {
        tailf:info "type of the policy-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum control {
            tailf:info "Configure control policies";
          }
        }
      }
      leaf domain {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum subscriber {
            tailf:info "subscriber control policy domain";
          }
        }
      }

      // policy-map * / event *
      list event {
        tailf:info "The event type this control class-map triggers upon";
        tailf:cli-mode-name "config-class-control-policymap";
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "name match";
        leaf name {
          tailf:cli-suppress-range;
          type enumeration {
            enum aaa-available {
              tailf:info "aaa-available event";
            }
            enum absolute-timeout {
              tailf:info "absolute timeout event";
            }
            enum agent-found {
              tailf:info "agent found event";
            }
            enum authentication-failure {
              tailf:info "authentication failure event";
            }
            enum authentication-success {
              tailf:info "authentication success event";
            }
            enum authorization-failure {
              tailf:info "authorization failure event";
            }
            enum authorization-success {
              tailf:info "authorization success event";
            }
            enum identity-update {
              tailf:info "identity update event";
            }
            enum inactivity-timeout {
              tailf:info "inactivity timeout event";
            }
            enum remote-authentication-failure {
              tailf:info "authentication failure event";
            }
            enum remote-authentication-success {
              tailf:info "authentication remote success event";
            }
            enum session-disconnected {
              tailf:info "session disconnected event";
            }
            enum session-started {
              tailf:info "session started event";
            }
            enum tag-added {
              tailf:info "tag to apply event";
            }
            enum tag-removed {
              tailf:info "tag to remove event";
            }
            enum template-activated {
              tailf:info "template activated event";
            }
            enum template-activation-failed {
              tailf:info "template activation failed event";
            }
            enum template-deactivated {
              tailf:info "template deactivated event";
            }
            enum template-deactivation-failed {
              tailf:info "template deactivation failed event";
            }
            enum timer-expiry {
              tailf:info "timer-expiry event";
            }
            enum violation {
              tailf:info "session violation event";
            }
          }
        }
        leaf match {
          tailf:key-default "match-all";
          type enumeration {
            enum match-all {
              tailf:info "Evaluate all the classes";
            }
            enum match-first {
              tailf:info "Evaluate the first class";
            }
          }
        }

        // policy-map * / event * / * class
        list class-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-class-control-policymap";
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-254>;;class number, 1 for 1st class, 2 for 2nd...";
            }
          }
          leaf class {
            tailf:info "The class type this control policy-map triggers upon";
            tailf:cli-hide-in-submode;
            type union {
              type string {
                tailf:info "WORD;;Name of control class-map to reference";
              }
              type enumeration {
                enum always {
                  tailf:info "This control class-map always matches";
                }
              }
            }
          }
          leaf execute {
            tailf:cli-drop-node-name;
            tailf:cli-hide-in-submode;
            type enumeration {
              enum do-all {
                tailf:info "Execute all the actions";
              }
              enum do-until-failure {
                tailf:info "Execute actions until one of them fails";
              }
              enum do-until-success {
                tailf:info "Execute actions until one of them is successful";
              }
            }
          }

          // policy-map * / event * / * class / *
          list action-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-254>;;action number, 1 for 1st action, 2 for 2nd...";
              }
            }
            leaf action {
              tailf:cli-drop-node-name;
              type enumeration {
                enum activate {
                  tailf:info "activate template or policy ";
                }
                enum authenticate {
                  tailf:info "authenticate a session";
                }
                enum authentication-restart {
                }
                enum authorize {
                  tailf:info "authorize session";
                }
                enum notify {
                  tailf:info "notifies the session attributes";
                }
                enum set-domain {
                  tailf:info "set domain";
                }
                enum set-timer {
                  tailf:info "set abs timer to pop N seconds from now";
                }
                enum unauthorize {
                  tailf:info "unauthorize session";
                }
                enum terminate {
                }
              }
            }
            leaf action-string {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info "WORD;;action string";
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot11
  /// ========================================================================

  container dot11 {
    tailf:info "IEEE 802.11 config commands";

    // dot11 syslog
    // no dot11 syslog
    leaf syslog {
      tailf:info "Enable syslog";
      tailf:cli-show-no;
      tailf:cli-full-command;
      type empty;
    }

    // dot11 ssid *
    list ssid {
      tailf:info "Configure radio service set parameters";
      tailf:cli-mode-name "config-ssid";
      key id;
      leaf id {
        type string {
          tailf:info "LINE;;radio Service Set ID (Up to 32 characters";
          length "0..32";
        }
      }

      // dot11 ssid * / vlan
      leaf vlan {
        tailf:info "bind ssid to vlan";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;vlan ID number or name string";
        }
      }

      // dot11 ssid * / authentication
      container authentication {
        tailf:info "authentication method";

        // dot11 ssid * / authentication open
        container open {
          tailf:info "open method";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          presence true;

          choice open-choice {
            // dot11 ssid * / authentication open mac-address
            leaf mac-address {
            tailf:info "mac-address authentication method";
            type string {
              tailf:info "WORD;;mac address list-name (1 -- 31 characters)";
            }
            }

            // dot11 ssid * / authentication open eap
            leaf eap {
              tailf:info "eap method";
              type string {
                tailf:info "WORD;;eap list name (1 -- 31 characters)";
              }
            }
          }
        }

        // dot11 ssid * / authentication network-eap
        leaf network-eap {
          tailf:info "leap method";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;leap list name (1 -- 31 characters)";
          }
        }

        // dot11 ssid * / authentication key-management
        container key-management {
          tailf:info "key management";

          // dot11 ssid * / authentication key-management wpa
          container wpa {
            tailf:info "allow WPA clients";
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            presence true;
            // dot11 ssid * / authentication key-management wpa version
            leaf version {
              tailf:info "Specify WPA version";
              type enumeration {
                enum "1" {
                  tailf:info "WPA version 1";
                }
                enum "2" {
                  tailf:info "WPA version 2";
                }
              }
            }
            // dot11 ssid * / authentication key-management wpa optional
            leaf optional {
              tailf:info "allow legacy clients";
              type empty;
            }
          }
        }
      }

      // dot11 ssid * / guest-mode
      leaf guest-mode {
        tailf:info "guest ssid";
        tailf:cli-full-command;
        type empty;
      }

      // dot11 ssid * / mbssid
      container mbssid {
        tailf:info "Multiple BSSID";

        // dot11 ssid * / mbssid guest-mode
        leaf guest-mode {
          tailf:info "guest ssid";
          type empty;
        }
      }

      // dot11 ssid * / wpa-psk ascii
      // dot11 ssid * / wpa-psk hex
      container wpa-psk {
        tailf:info "Configure Wi-Fi Protected Access pre-shared key";
        choice wpa-psk-choice {
          container ascii {
            tailf:info "Key entered as ascii chars";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping;
          }
          container hex {
            tailf:info "Key entered as hex chars";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses password-grouping;
          }
        }
      }
    }

    // dot11 arp-cache
    container arp-cache {
      tailf:info "Enable DOT11 ARP cache";
      tailf:cli-delete-when-empty;
      presence true;

      // dot11 arp-cache optional
      leaf optional {
        tailf:info "Disable ARP Cache until all associated client IP "+
          "addresses are learned";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// bridge
  /// ========================================================================

  container bridge {
    tailf:info "Bridge Group.";

    // bridge irb
    leaf irb {
      tailf:info "Integrated routing and bridging";
      tailf:cli-full-command;
      type empty;
    }

    // bridge *
    list bridge-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint8 {
          tailf:info "<1-255>;;Bridge Group number for Bridging.";
          range "1..255";
        }
      }

      // bridge * / protocol
      leaf protocol {
        tailf:info "Specify spanning tree protocol";
        type enumeration {
          enum dec {
            tailf:info "DEC protocol";
          }
          enum ibm {
            tailf:info "IBM protocol";
          }
          enum ieee {
            tailf:info "IEEE 802.1 protocol";
          }
          enum vlan-bridge {
            tailf:info "vlan-bridge protocol";
          }
        }
      }

      // bridge * / route ip
      container route {
        tailf:info "Specify a protocol to be routed in this bridge group";
        leaf ip {
          tailf:info "IP";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// bridge-domain
  /// ========================================================================

  container bridge-domain {
    tailf:info "Bridge-domain global configuration commands";

    // bridge-domain *
    list bridge-domain-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-bdomain";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../vlan/vlan-list";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-16384>;;bridge-domain ID";
          range "1..16384";
        }
      }

      // bridge-domain * / member *
      container member {
        tailf:info "bridge-domain member";

        // bridge-domain * / member vfi
        leaf vfi {
          tailf:info "Configure the Virtual Forwarding Instance (VFI) member";
          tailf:non-strict-leafref {
            path "../../../../l2vpn-vfi/l2vpn/vfi/context/name";
          }
          type string {
            tailf:info "WORD;;Enter VFI name (Max Size 31)";
          }
        }

        // bridge-domain * / member * service-instance
        list interface-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "name service-instance";
          leaf name {
            tailf:cli-disallow-value "vfi";
            tailf:cli-diff-dependency "../../../../../interface";
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf service-instance {
            tailf:info "ethernet service instance";
            tailf:cli-expose-key-name;
            type uint16 {
              tailf:info "<1-8000>;;Service Instance Identifier";
              range "1..8000";
            }
          }
        }

        // bridge-domain * / member * service-instance * encapsulation
        list ip-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of the peer";
            }
          }
          leaf vcid {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-4294967295>;;Enter VC ID value";
              range "1..4294967295";
            }
          }
          choice encapsulation-template-choice {
            container encapsulation {
              tailf:info "Data encapsulation method";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf mpls {
                tailf:info "Use MPLS encapsulation";
                type empty;
              }
            }
            leaf template {
              tailf:info "Template to use for encapsulation and protocol configuration";
              type string {
                tailf:info "WORD;;template name (Max size 32)";
              }
            }
          }
        }
      }

      // bridge-domain * / mac
      container mac {
        tailf:info "MAC Address related commands";

        // bridge-domain * / mac limit maximum addresses
        container limit {
          tailf:info "Limit the MAC Addresses learnt";
          container maximum {
            tailf:info "Maximum";
            leaf addresses {
              tailf:info "Addresses";
              type uint16 {
                tailf:info "<1-10000>;;Number of addresses that can be learnt";
                range "1..10000";
              }
            }
          }
        }

        // bridge-domain * / mac aging-time
        leaf aging-time {
          tailf:info "Set age time of mac addresses per bridge domain";
          type uint16 {
            tailf:info "<10-600>;;Aging time in seconds, default 300 seconds "+
              "(or 1800 seconds for overlay bridge domains)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-group
  /// ========================================================================

  list service-group {
    tailf:info "service-group global command";
    key id;
    leaf id {
      type uint32 {
        tailf:info "<1-32768>;;Service Group ID Number";
        range "1..32768";
      }
    }

    // service-group * / description
    leaf "description" {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description string";
      }
    }

    // service-group * / service-policy
    container service-policy {
      tailf:info "Configure Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// service-instance
  /// ========================================================================

  container service-instance {
    tailf:info "Configure service-instance";

    // service-instance mdns-sd service *
    container mdns-sd {
      tailf:info "Static Service MDNS configuration";
      list service {
        tailf:info "Provide only Service Instance Name";
        tailf:cli-mode-name "config-mdns-sd-si";
        key "name regtype domain";
        leaf name {
          type string {
            tailf:info "WORD;;Specify Service instance name";
          }
        }
        leaf regtype {
          tailf:cli-expose-key-name;
          type string {
            tailf:info "Service Type: Specify in the form or _xxx._yyy";
            pattern "_[a-z]{3}._[a-z]{3}";
          }
        }
        leaf domain {
          tailf:info "Domain: Specify domain";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Domain";
          }
        }

        // service-instance mdns-sd service * / target-hostname
        leaf target-hostname {
          tailf:info "Enter FQDN of target host";
          type string {
            tailf:info "WORD;;Enter FQDN of target host";
          }
        }

        // service-instance mdns-sd service * / priority
        leaf priority {
          tailf:info "Specify Priority";
          type uint16 {
            tailf:info "<0-360>;;Specify Priority for this service";
            range "0..360";
          }
        }

        // service-instance mdns-sd service * / weight
        leaf weight {
          tailf:info "Specify Weight";
          type uint16 {
            tailf:info "<0-360>;;Specify Weight for the service";
            range "0..360";
          }
        }

        // service-instance mdns-sd service * / port
        leaf port {
          tailf:info "Specify Port on which service is running";
          type uint32 {
            tailf:info "<0-65535>;;Specify Port for the service";
            range "0..65535";
          }
        }

        // service-instance mdns-sd service * / txt
        leaf txt {
          tailf:info "Text record string with type=name pairs separated using <\\>";
          type string {
            tailf:info "WORD;;TEXT Record for the Service. Maximum 1024 characters";
            length "0..1024";
          }
        }

        // service-instance mdns-sd service * / ipv4addr
        leaf ipv4addr {
          tailf:info "IPV4 address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPV4 address of service";
          }
        }

        // service-instance mdns-sd service * / ipv6addr
        leaf ipv6addr {
          tailf:info "IPV6 address";
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPV6 address of service";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// service-insertion
  /// ========================================================================

  container service-insertion {
    tailf:info "Service Insertion mode";
    tailf:cli-diff-dependency "../interface/Loopback";
    tailf:cli-diff-dependency "../interface/Tunnel";

    // service-insertion service-node-group *
    list service-node-group {
      tailf:info "service node Group";
      tailf:cli-mode-name "config-service-insertion-sng";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service node Group Name";
        }
      }

      // service-insertion service-node-group * / description
      leaf "description" {
        tailf:info "Group Description";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Group Description";
        }
      }

      // service-insertion service-node-group * / service-node *
      list service-node {
        tailf:info "service node";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip-address;
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;service node IP ADDRESS";
          }
        }
      }

      // service-insertion service-node-group * / node-discovery
      leaf node-discovery {
        tailf:cli-full-command;
        type enumeration {
          enum enable;
        }
      }
    }

    // service-insertion appnav-controller-group *
    list appnav-controller-group {
      tailf:info "AppNav Controller Group";
      tailf:cli-mode-name "config-service-insertion-acg";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;AppNav Controller Group Name";
        }
      }

      // service-insertion appnav-controller-group * / description
      leaf "description" {
        tailf:info "Group Description";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Group Description";
        }
      }

      // service-insertion appnav-controller-group * / appnav-controller *
      list appnav-controller {
        tailf:info "AppNav controller";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key ip-address;
        leaf ip-address {
          // dep: before this created, must change
          tailf:cli-diff-dependency "/ios:interface/Loopback/ip/address/primary" {
            tailf:cli-trigger-on-set;
          }
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;AppNav controller IP address";
          }
        }
      }
    }

    // service-insertion service-context *
    list service-context {
      tailf:info "Service Context";
      tailf:cli-mode-name "config-service-insertion-context";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;service controller, e.g. waas/1";
        }
      }

      // service-insertion service-context * /  appnav-controller-group
      leaf appnav-controller-group {
        tailf:info "AppNav Controller Group";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../appnav-controller-group/name";
        }
        type string {
          tailf:info "WORD;;AppNav Controller Group";
        }
      }

      // service-insertion service-context * / service-node-group
      leaf service-node-group {
        tailf:info "Service node Group";
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../service-node-group/name";
        }
        type string {
          tailf:info "WORD;;service node Group";
        }
      }

      // service-insertion service-context * / service-policy
      leaf service-policy {
        tailf:info "Specify a service policy for the service context";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        tailf:non-strict-leafref {
          path "../../../policy-map/name";
        }
        type string {
          tailf:info "WORD;;Name of the preconfigured service policy";
        }
      }

      // service-insertion service-context * / vrf
      container vrf {
        tailf:info "Configure forwarding table";
        choice c-type {
          leaf name {
            tailf:info "vrf name";
            type string {
              tailf:info "WORD;;vrf name";
            }
          }
          leaf "default" {
            tailf:info "default";
            type empty;
          }
          leaf global {
            tailf:info "global";
            type empty;
          }
        }
      }

      // service-insertion service-context * / enable
      leaf enable {
        tailf:info "service context enable";
        tailf:cli-suppress-no;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// vtp
  /// ========================================================================

  container vtp {
    tailf:info "Configure global VTP state";

    // vtp file
    leaf file {
      tailf:info "Configure IFS filesystem file where VTP configuration is "
        +"stored.";
      type string {
        tailf:info "WORD;;The ascii name of the IFS filesystem file where VTP "
          +"configuration is stored.";
      }
    }

    // vtp interface
    leaf interface {
      tailf:info "Configure interface as the preferred source for the VTP IP "
        +"updater address.";
      tailf:cli-diff-dependency "../../interface";
      type string {
        tailf:info "WORD;;The name of the interface providing the VTP updater "
          +"ID for this device.";
      }
    }

    // vtp password
    leaf password {
      tailf:info "Set the password for the VTP administrative domain";
      type string {
        tailf:info "WORD;;The ascii password for the VTP administrative "
          +"domain.";
      }
    }

    // vtp pruning
    leaf pruning {
      tailf:info "Set the adminstrative domain to permit pruning";
      type empty;
    }

    // vtp version
    leaf version {
      tailf:info "Set the adminstrative domain to VTP version";
      type uint8 {
        tailf:info "<1-3>;;Set the adminstrative domain VTP version number";
        range "1..3";
      }
    }

    // vtp domain
    leaf domain {
      tailf:info "Set the name of the VTP administrative domain.";
      type string {
        tailf:info "WORD;;The ascii name for the VTP administrative domain.";
      }
    }

    // vtp mode
    leaf mode {
      tailf:info "Configure VTP device mode";
      type enumeration {
        enum client {
          tailf:info "Set the device to client mode.";
        }
        enum off {
          tailf:info "Set the device to off mode.";
        }
        enum server {
          tailf:info "Set the device to server mode.";
        }
        enum transparent {
          tailf:info "Set the device to transparent mode.";
        }
      }
    }
  }


  /// ========================================================================
  /// link
  /// ========================================================================

  container link {
    tailf:info "Enable Link State Tracking feature";
    container state {
      tailf:info "Enable link state tracking feature";

      // link state track *
      leaf-list track {
        tailf:info "Enable link state tracking for the group";
        tailf:cli-list-syntax;
        type uint8 {
          tailf:info "<1-10>;;Link state group number to trac";
          range "1..8";
        }
      }
    }
  }

  /// ========================================================================
  /// vlan
  /// ========================================================================

  container vlan {
    tailf:info "VLAN commands";

    choice vlan-accounting-choice {

      // no vlan accounting
      leaf accounting {
        tailf:info "VLAN accounting configuration";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // no vlan accounting input
      container accounting-input {
        tailf:cli-drop-node-name;
        container accounting {
          leaf "input" {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }

      // no vlan accounting output
      container accounting-output {
        tailf:cli-drop-node-name;
        container accounting {
          leaf "output" {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }
      }
    }

    // vlan internal
    container internal {
      tailf:info "internal VLAN";
      container allocation {
        tailf:info "internal VLAN allocation";
        leaf policy {
          type enumeration {
            enum ascending {
              tailf:info "Allocates internal VLANs from 1006 to 4094";
            }
            enum descending {
              tailf:info "Allocates internal VLANs from 4094 to 1006.";
            }
          }
        }
      }
    }

    // vlan dot1q
    container dot1q {
      tailf:info "dot1q parameters";
      container tag {
        tailf:info "tag parameters";
        leaf native {
          tailf:info "tag native vlan";
          type empty;
        }
      }
    }

    // vlan access-log
    container access-log {
      tailf:info "Configure VACL logging";
      leaf maxflow {
        tailf:info "Set vacl logging maximum flow number";
        type uint16 {
          tailf:info "<0-2048>;;Maximum flow number";
          range "0..2048";
        }
      }
      leaf ratelimit {
        tailf:info "Set vacl logging rate limiter";
        type uint16 {
          tailf:info "<10-5000>;;Maximum number of packets logged per second";
          range "10..5000";
        }
      }
      leaf threshold {
        tailf:info "Set vacl log-update threshold";
        type uint32 {
          tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
          range "0..2147483647";
        }
      }
    }

    // vlan filter *
    list filter {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;VLAN map name";
        }
      }
      leaf-list vlan-list {
        tailf:info "VLANs to apply filter to";
        tailf:cli-replace-all;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "<1-4094>;;VLAN id";
          range "1..4094";
        }
      }
      //note: did not implement 'all' because replaced with 1-4094 by device.
    }

    // vlan *
    list vlan-list {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-vlan";
      tailf:cli-range-list-syntax;
      tailf:meta-data "range-list-syntax-mode" {
        tailf:meta-value "vlan <ID>";
      }
      tailf:meta-data "max-values-mode" {
        tailf:meta-value "1 :: 32 :: ,"; // values start after 1 word, max 32 per line, separator ,
      }
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }

      // vlan * / name
      leaf name {
        tailf:info "Ascii name of the VLAN";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../vlan-list/name" {
          tailf:cli-trigger-on-set;
        }
        type string {
          tailf:info "The ascii name for the VLAN (Max Size 32)";
          length "1..32";
        }
      }

      // vlan * / state
      leaf state {
        tailf:info "Operational state of the VLAN";
        type enumeration {
          enum active {
            tailf:info "VLAN Active State";
          }
          enum suspend {
            tailf:info "VLAN Suspended State";
          }
        }
      }

      // vlan * / mtu
      leaf mtu {
        tailf:info "VLAN Maximum Transmission Unit";
        type uint16 {
          tailf:info "<576-18190>;;Value of VLAN Maximum Tranmission Unit";
          range "576..18190";
        }
      }

      // vlan * / remote-span
      leaf remote-span {
        tailf:info "Configure as Remote SPAN VLAN";
        tailf:cli-full-command;
        type empty;
      }

      // vlan * / uni-vlan
      leaf uni-vlan {
        tailf:info "Configure a UNI VLAN";
        tailf:cli-full-command;
        type enumeration {
          enum community {
            tailf:info "UNI/ENI community VLAN";
          }
          enum isolated {
            tailf:info "UNI/ENI isolated VLAN";
          }
        }
      }
    }

    // vlan configuration *
    list configuration {
      tailf:info "Apply service policy to VLANs";
      tailf:cli-range-list-syntax;
      tailf:cli-mode-name "config-vlan-config";
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-3967,4048-4094>;;VLAN ID 1-4094 or "
            +"range(s): 1-5, 10 or 2-5,7-19";
          range "1..4094";
        }
      }

      // vlan configuration * / service policy
      container service-policy {
        tailf:info "Configure Service Policy";
        tailf:cli-compact-syntax;
        uses service-policy-grouping;
      }
    }

    // vlan access-map *
    list access-map {
      tailf:info "Create vlan access-map or enter vlan access-map command mode";
      tailf:cli-mode-name "config-access-map";
      key "name number";
      leaf name {
        type string {
          tailf:info "WORD;;Vlan access map tag";
        }
      }
      leaf number {
        type uint16 {
          tailf:info "<0-65535>;;Sequence to insert to/delete from existing "+
            "vlan access-map entry";
        }
      }

      // vlan access-map * / action
      leaf action {
        tailf:info "Take the action";
        type enumeration {
          enum drop {
            tailf:info "Drop packets";
          }
          enum forward {
            tailf:info "Forward packets";
          }
        }
      }

      // vlan access-map * / match
      container match {
        tailf:info "Match values.";

        // vlan access-map * / match mac address *
        container mac {
          tailf:info "MAC based match";
          leaf-list address {
            tailf:info "Match MAC address to access control.";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../mac/access-list/extended/id";
            }
            type string {
              tailf:info "WORD;;Access-list name";
            }
          }
        }

        // vlan access-map * / match ip address *
        container ip {
          tailf:info "IP based match";
          leaf-list address {
            tailf:info "Match IP address to access control.";
            tailf:cli-flat-list-syntax;
            type exp-ip-acl-type;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// lldp
  /// ========================================================================

  container lldp {
    tailf:info "Global LLDP configuration subcommands";

    // lldp run
    leaf run {
      tailf:info "Enable LLDP";
      type empty;
    }
  }


  /// ========================================================================
  /// EXEC (exec commands executed in config mode)
  /// ========================================================================

  container EXEC {
    tailf:cli-drop-node-name;

    // default
    tailf:action "default" {
      tailf:info "Set a command to its defaults";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;default <argument(s)>";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }

    // execute (run config exec ommands, e,g,; 'crypto key generate')
    tailf:action "exec" {
      tailf:info "Execute config exec-commands, e.g. 'crypto key generate'";
      tailf:actionpoint ncsinternal {
        tailf:internal;
      }
      input {
        leaf-list args {
          tailf:cli-drop-node-name;
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "ACTION:;;exec \"<command> <argument(s)> [options]\"";
          }
        }
      }
      output {
        leaf result {
          type string;
        }
      }
    }
  }


  /// ========================================================================
  /// pm-agent
  /// ========================================================================

  container pm-agent {
    tailf:info "pm-agent Configuration Commands";
    tailf:cli-run-template-enter 'pm-agent\n ! meta-data :: $(.ipath) :: shutdown-container-before-change :: pm-agent\n';
    tailf:cli-exit-command "! exit-meta-data-pm-agent";
    tailf:ned-data "." {
      tailf:transaction to;
    }
    tailf:cli-add-mode;
    presence true;

    // pm-agent / tenant
    container tenant {
      tailf:info "enter the tenant configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "specify the tenant id";
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-4294967295>;;specify the tenant-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "specify the tenant name";
        type string {
          tailf:info "WORD;;tenant Name";
        }
      }
    }

    // pm-agent / region
    container region {
      tailf:info "Enter the region ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "Specify the region ID";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the region-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "Specify the region name";
        type string {
          tailf:info "WORD;;region Name";
        }
      }
    }

    // pm-agent / site
    container site {
      tailf:info "Enter the site configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:info "Specify the site ID";
        type uint32 {
          tailf:info "<1-4294967295>;;Specify the site-id value";
          range "1..4294967295";
        }
      }
      leaf name {
        tailf:info "Specify the site name";
        type string {
          tailf:info "WORD;;Site Name";
        }
      }
    }

    // pm-agent / device
    container device {
      tailf:info "Enter the device ID";

      // pm-agent / device id
      container id {
        tailf:info "Specify the device ID";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Specify the device-id value";
            range "1..4294967295";
          }
        }
        leaf name {
          tailf:info "Specify the device name";
          type string {
            tailf:info "WORD;;device name";
          }
        }
      }

      // pm-agent / device type
      leaf "type" {
        tailf:info "Enter the device type";
        tailf:cli-full-command;
        type enumeration {
          enum ntr {
            tailf:info "ntr device type";
          }
          enum pxtr {
            tailf:info "pxtr device type";
          }
          enum rtr {
            tailf:info "rtr device type";
          }
          enum xtr {
            tailf:info "xtr device type";
          }
        }
      }
    }

    // pm-agent / pmcs
    container pmcs {
      tailf:info "Enter the pmcs configuration";

      // pm-agent / pmcs ipv4 *
      list ipv4 {
        tailf:info "Enter the IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IPv4 pmcs address e.g 10.10.0.0";
          }
        }
      }

      // pm-agent / pmcs ipv6 *
      list ipv6 {
        tailf:info "Enter the IPv6 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;IPv6 pmcs Addr, e.g abcd:1234";
          }
        }
      }
    }

    // pm-agent / instance-id *
    list instance-id {
      tailf:info "Enter the instance ID";
      tailf:cli-mode-name "config-pm-agent-instance";
      key id;
      leaf id {
        type uint32 {
          tailf:info "<0-4294967295>;;Specify the instance-id value";
        }
      }

      // pm-agent / instance-id * / enterprise-prefix
      container enterprise-prefix {
        tailf:info "Enterprise prefix configuration";

        // pm-agent / instance-id * / enterprise-prefix ipv4 prefix-list
        leaf prefix-list {
          tailf:cli-remove-before-change;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;prefix-list containing list of site targets";
          }
        }

        // pm-agent / instance-id * / enterprise-prefix ipv4 prefix-list
        // Note: IWAN3
        container ipv4 {
          tailf:info "IPv4 enterprise prefix-list";
          leaf prefix-list {
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;prefix-list containing list of site targets";
            }
          }
        }

        // pm-agent / instance-id * / enterprise-prefix ipv6 prefix-list
        container ipv6 {
          tailf:info "IPv6 enterprise prefix-list";
          leaf prefix-list {
            tailf:cli-remove-before-change;
            type string {
              tailf:info "WORD;;prefix-list containing list of site targets";
            }
          }
        }
      }
    }

    // pm-agent / shutdown
    leaf shutdown {
      tailf:info "shut the device";
      type empty;
    }
  }


  /// ========================================================================
  /// crypto
  /// ========================================================================

  container crypto {
    tailf:info "Encryption module";

    // crypto keyring *
    list keyring {
      tailf:info "Key ring commands";
      tailf:cli-mode-name "conf-keyring";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;name of the key ring";
        }
      }
      leaf vrf {
        tailf:info "Mention a vrf it belongs to";
        tailf:cli-hide-in-submode;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;the VRF name";
        }
      }

      // crypto keyring * / pre-shared-key address *
      container pre-shared-key {
        tailf:info "Pre-Shared Key";

        // crypto keyring * / pre-shared-key address *
        list address {
          tailf:info "pre shared key by address";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-remove-before-change;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;address prefix";
            }
          }
          leaf mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;address prefix mask";
            }
          }
          container "key" {
            tailf:info "specify the key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            uses crypto-key-grouping;
          }
        }
      }
    }

    // crypto logging
    container logging {
      tailf:info "logging messages";

      // crypto logging session
      leaf session {
        tailf:info "logging up/down session";
        type empty;
      }

      // crypto logging ikev2
      leaf ikev2 {
        tailf:info "logging IKEv2 sessions";
        type empty;
      }
    }

    // crypto ikev2
    container ikev2 {
      tailf:info "Configure IKEv2 Options";

      // crypto ikev2 name-mangler *
      list name-mangler {
        tailf:info "Name mangler";
        tailf:cli-mode-name "config-ikev2-name-mangler";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the mangler";
          }
        }
        // crypto ikev2 name-mangler * / fqdn
        leaf fqdn {
          tailf:info "Derive name from FQDN identity";
          type enumeration {
            enum all {
              tailf:info "entire portion of fqdn identity";
            }
            enum domain {
              tailf:info "domain portion of fqdn identity";
            }
            enum hostname {
              tailf:info "hostname portion of fqdn identity";
            }
          }
        }
      }

      // crypto ikev2 authorization policy *
      container authorization {
        tailf:info "IKEv2 authorization";
        list policy {
          tailf:info "IKEv2 authorization policy";
          tailf:cli-mode-name "config-ikev2-author-policy";
          tailf:cli-full-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ikev2 authorization policy * / pool
          leaf pool {
            tailf:info "Specify local address pool";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;address pool name";
            }
          }

          // crypto ikev2 authorization policy * / netmask
          leaf netmask {
            tailf:info "Specify netmask of the config address";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;netmask";
            }
          }

          // crypto ikev2 authorization policy * / aaa
          container aaa {
            tailf:info "Specify aaa attribute list";
            container attribute {
              tailf:info "AAA attribute list";
              leaf "list" {
                tailf:info "AAA attribute list";
                type string {
                  tailf:info "WORD;;AAA attribute list name";
                }
              }
            }
          }

          // crypto ikev2 authorization policy * / route
          container route {
            tailf:info "specify route parameters";

            // crypto ikev2 authorization policy * / route set
            container set {
              tailf:info "Specify route set parameters";
              // crypto ikev2 authorization policy * / route set access-list
              container access-list {
                tailf:info "Specify the route access-list";
                leaf ipv4 {
                  tailf:cli-drop-node-name;
                  type std-ip-acl-type;
                }
                leaf ipv6 {
                  tailf:info "ipv6 access-list";
                  type string {
                    tailf:info "WORD;;access-list name";
                  }
                }
              }
              // crypto ikev2 authorization policy * / route set interface
              // crypto ikev2 authorization policy * / route set interface *
              container interface {
                tailf:info "Specify the route interface [interface-name]";
                tailf:cli-display-separated;
                presence true;
                list interface-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Interface name";
                    }
                  }
                }
              }
            }

            // crypto ikev2 authorization policy * / route accept any
            container accept {
              tailf:info "Route accept parameters";
              container any {
                tailf:info "Accept all subnets from peer";
                choice any-choice {
                  leaf distance {
                    tailf:info "Specify distance for routes to remote subnets";
                    type uint8 {
                      tailf:info "<1-255>;;Routing distance";
                      range "1..255";
                    }
                    default 1;
                  }
                  leaf tag {
                    tailf:info "Specify tag for routes to remote subnets";
                    type uint32 {
                      tailf:info "<1-497777>;;Routing tag ID";
                      range "1..497777";
                    }
                  }
                }
              }
            }
          }

          // crypto ikev2 authorization policy * / session-lifetime
          leaf session-lifetime {
            tailf:info "Specify maximum session lifetime";
            type uint32 {
              tailf:info "<120-25920000>;;maximum session lifetime in seconds";
              range "120..25920000";
            }
          }
        }
      }

      // crypto ikev2 redirect client
      container redirect {
        tailf:info "IKEv2 Redirect Mechanism for load-balancing";
        container client {
          tailf:info "Enables Redirect Mechanism on Client";
          tailf:cli-delete-when-empty;
          presence true;
          leaf max-redirects {
            tailf:info "Redirect loop detection";
            type uint8 {
              tailf:info "<1-255>;;Max no. of Redirects per session, "+
                "Default value is 5";
              range "1..255";
            }
            default 5;
          }
        }
      }

      // crypto ikev2 keyring *
      list keyring {
        tailf:info "Define IKEv2 Keyring";
        tailf:cli-mode-name "config-ikev2-keyring";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Keyring";
          }
        }

        // crypto ikev2 keyring * / peer *
        list peer {
          tailf:info "Configure a Peer and associated keys";
          tailf:cli-mode-name "config-ikev2-keyring-peer";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the peer block";
            }
          }

          // crypto ikev2 keyring * / peer * / description
          leaf "description" {
            tailf:info "Specify a description of this peer";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;description of the peer";
            }
          }

          // crypto ikev2 keyring * / peer * / address
          container address {
            tailf:info "Specify IPv4/IPv6 address of peer";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice address-choice {
              case ipv4 {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 Address";
                  }
                }
                leaf ipv4-mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                  default "255.255.255.255";
                }
              }
              case ipv6 {
                leaf ipv6-address {
                  tailf:cli-drop-node-name;
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 address/prefix";
                  }
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / identity
          container "identity" {
            tailf:info "Specify IKE identity to use";
            choice identity-choice {

              // crypto ikev2 keyring * / peer * / identity key-id
              leaf key-id {
                tailf:info "proprietary types of identification (ID KEY ID)";
                type string {
                  tailf:info "WORD;;ID_KEY_ID <string>";
                }
              }

              // crypto ikev2 keyring * / peer * / identity fqdn
              container fqdn {
                tailf:info "Use FQDN";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf domain {
                  tailf:info "email Domain Name";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-incomplete-command;
                  type empty;
                }
                leaf name {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Specify the name string";
                  }
                }
              }
            }
          }

          // crypto ikev2 keyring * / peer * / pre-shared-key
          container pre-shared-key {
            tailf:info "specify the pre-shared key";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;

            choice pre-shared-key-choice {
              case one-case {
                uses crypto-key-grouping;
              }
              case local-remote-case {
                // crypto ikev2 keyring * / peer * / pre-shared-key local
                container local {
                  tailf:cli-optional-in-sequence;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping;
                }
                // crypto ikev2 keyring * / peer * / pre-shared-key remote
                container remote {
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping;
                }
              }
            }
          }
        }
      }

      // crypto ikev2 proposal *
      list proposal {
        tailf:info "Define IKEV2 proposals";
        tailf:cli-mode-name "config-ikev2-proposal";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 proposal";
          }
        }

        // crypto ikev2 proposal * / encryption
        leaf-list encryption {
          tailf:info "Set encryption algorithm(s) for proposal";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum aes-cbc-128 {
              tailf:info "AES-CBC-128";
            }
            enum "3des" {
              tailf:info "3DES";
            }
            enum aes-cbc-192 {
              tailf:info "AES-CBC-192";
            }
            enum aes-cbc-256 {
              tailf:info "AES-CBC-256";
            }
            enum des {
              tailf:info "DES";
            }
          }
        }

        // crypto ikev2 proposal * / integrity
        leaf-list integrity {
          tailf:info "Set integrity hash algorithm(s) for proposal";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha1 {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard 2 (256 bit)";
            }
            enum sha384 {
              tailf:info "Secure Hash Standard 2 (384 bit)";
            }
            enum sha512 {
              tailf:info "Secure Hash Standard 2 (512 bit)";
            }
          }
        }

        // crypto ikev2 proposal * / group
        leaf-list group {
          tailf:info "Set the Diffie-Hellman group(s)";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type enumeration {
            enum "1" {
              tailf:info "DH 768 MODP";
            }
            enum "14" {
              tailf:info "DH 2048 MODP";
            }
            enum "15" {
              tailf:info "DH 3072 MODP";
            }
            enum "16" {
              tailf:info "DH 4096 MODP";
            }
            enum "19" {
              tailf:info "DH 256 ECP";
            }
            enum "2" {
              tailf:info "DH 1024 MODP";
            }
            enum "20" {
              tailf:info "DH 384 ECP";
            }
            enum "21" {
              tailf:info "DH 521 ECP";
            }
            enum "24" {
              tailf:info "DH 2048 (256 subgroup) MODP";
            }
            enum "5" {
              tailf:info "DH 1536 MODP";
            }
          }
        }
      }

      // crypto ikev2 policy *
      list policy {
        tailf:info "Define IKEV2 policies";
        tailf:cli-mode-name "config-ikev2-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 policy";
          }
        }

        // crypto ikev2 policy * / proposal
        leaf proposal {
          tailf:info "Specify Proposal";
          tailf:non-strict-leafref {
            path "../../../../crypto/ikev2/proposal/name";
          }
          type string {
            tailf:info "WORD;;Specify the name of proposal to be attached";
          }
        }

        // crypto ikev2 policy * / match
        container match {
          tailf:info "Match values of local fields";

          // crypto ikev2 policy * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto ikev2 policy * / match address local *
          container address {
            tailf:info "Specify the address to match";
            list local {
              tailf:info "Local address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
              }
            }
          }
        }
      }

      // crypto ikev2 profile *
      list profile {
        tailf:info "Define IKEv2 Profiles";
        tailf:cli-mode-name "config-ikev2-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of IKEv2 Profile";
          }
        }

        // crypto ikev2 profile * / description
        leaf "description" {
          tailf:info "Specify a description of this profile";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;a 1 line description of the profile";
          }
        }

        // crypto ikev2 profile * / match
        container match {
          tailf:info "Match values of peer";

          // crypto ikev2 profile * / match address local *
          container address {
            tailf:info "IP address";
            list local {
              tailf:info "Local address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type inet:host {
                  tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address";
                }
              }
            }
          }

          // crypto ikev2 profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto ikev2 profile * / match identify remote
          container "identity" {
            tailf:info "IKE identity";

            // crypto ikev2 profile * / match identity remote
            container remote {
              tailf:info "Remote identity";

              // crypto ikev2 profile * / match identity remote any
              leaf any {
                tailf:info "match any peer identity";
                tailf:cli-full-command;
                type empty;
              }

              // crypto ikev2 profile * / match identity remote key-id *
              list key-id {
                tailf:info "key-id opaque string ";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    tailf:info "WORD;;Specify the key-id string";
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote fqdn
              container fqdn {
                tailf:info "Fully qualified domain name string";

                // crypto ikev2 profile * / match identity remote fqdn *
                list fqdn-list {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }

                // crypto ikev2 profile * / match identity remote fqdn domain *
                list domain {
                  tailf:info "match domain instead of exact";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key name;
                  leaf name {
                    type string {
                      tailf:info "WORD;;Specify the name string";
                    }
                  }
                }
              }

              // crypto ikev2 profile * / match identity remote address *
              list address {
                tailf:info "match address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key name;
                leaf name {
                  type union {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address";
                    }
                    type ipv6-prefix {
                      tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                    }
                  }
                }
                leaf mask {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP mask";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / identify
        container "identity" {
          tailf:info "Specify IKE identity to use";

          // crypto ikev2 profile * / identify local
          container local {
            tailf:info "Specify the local IKE identity to use "+
              "for the negotiation";
            choice local-choice {
              leaf dn {
                tailf:info "Distinguished Name";
                type empty;
              }
              leaf email {
                tailf:info "Fully qualified email string";
                type string {
                  tailf:info "WORD;;email <user@domain>";
                }
              }
              leaf fqdn {
                tailf:info "Fully qualified domain name string";
                type string {
                  tailf:info "WORD;;FQDN <host.domain>";
                }
              }
              leaf address {
                tailf:info "address";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 address";
                  }
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / authentication
        container authentication {
          tailf:info "Set authentication method";

          // crypto ikev2 profile * / authentication local
          container local {
            tailf:info "Set local authentication method";
            choice method-choice {
              container eap {
                tailf:info "Extended Authentication Protocol";
                presence true;
              }
              leaf ecdsa-sig {
                tailf:info "ECDSA Signature";
                type empty;
              }
              container pre-share {
                tailf:info "Pre-Shared Key";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                presence true;
                container "key" {
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping;
                }
              }
              leaf rsa-sig {
                tailf:info "Rivest-Shamir-Adleman Signature";
                type empty;
              }
            }
          }

          // crypto ikev2 profile * / authentication remote
          container remote {
            tailf:info "Set remote authentication method";
            tailf:cli-delete-when-empty;
            presence true;
            choice method-choice {
              container eap {
                tailf:info "Extended Authentication Protocol";
                tailf:cli-delete-when-empty;
                presence true;
                leaf query-identity {
                  tailf:info "query EAP identity from peer ";
                  type empty;
                }
              }
              leaf ecdsa-sig {
                tailf:info "ECDSA Signature";
                type empty;
              }
              container pre-share {
                tailf:info "Pre-Shared Key";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-delete-when-empty;
                presence true;
                container "key" {
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  uses crypto-key-grouping;
                }
              }
              leaf rsa-sig {
                tailf:info "Rivest-Shamir-Adleman Signature";
                type empty;
              }
            }
          }
        }

        // crypto ikev2 profile * / pki trustpoint *
        container pki {
          tailf:info "Specify certificate authorities to trust";
          leaf-list trustpoint {
            tailf:info "Cert authority trustpoint for RSA sig";
            tailf:cli-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../crypto/pki/trustpoint/id";
            }
            type string {
              tailf:info "WORD;;Specify the trustpoint label to use";
            }
          }
        }

        // crypto ikev2 profile * / keyring
        container keyring {
          tailf:info "Specify keyring to use";
          choice keyring-choice {
            container aaa {
              tailf:info "AAA based keyring";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf name-mangler {
                tailf:info "Specify the name-mangler to derive username";
                tailf:non-strict-leafref {
                  path "../../../../../../crypto/ikev2/name-mangler/name";
                }
                type string {
                  tailf:info "WORD;;mangler name";
                }
              }
            }
            leaf local {
              tailf:info "Local keyring";
              tailf:non-strict-leafref {
                path "../../../../../crypto/ikev2/keyring/name";
              }
              type string {
                tailf:info "WORD;;Keyring name";
              }
            }
          }
        }

        // crypto ikev2 profile * / nat keepalive
        container nat {
          tailf:info "NAT-transparency";
          leaf keepalive {
            tailf:info "NAT keepalive interval";
            type uint16 {
              tailf:info "<5-3600>;;NAT keepalive interval in seconds";
              range "5..3600";
            }
          }
        }

        // crypto ikev2 profile * / aaa
        container aaa {
          tailf:info "Specify AAA related configs";

          // crypto ikev2 profile * / aaa authentication eap
          container authentication {
            tailf:info "AAA authentication";
            leaf eap {
              tailf:info "AAA EAP authentication";
              type string {
                tailf:info "WORD;;AAA list name";
              }
            }
          }

          // crypto ikev2 profile * / aaa authorization
          container authorization {
            tailf:info "AAA authorization";

            // crypto ikev2 profile * / aaa authorization group
            container group {
              tailf:info "AAA group authorization";

              // crypto ikev2 profile * / aaa authorization group psk list
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth method is PSK";
                uses crypto-ikev2-profile-aaa-authorization-group-list {
                  refine "list/password/secret" {
                    tailf:meta-data "secret-password" {
                      tailf:meta-value "crypto ikev2 profile <profile><NL><*> ::  aaa authorization group psk list <list> password <PASSWORD>";
                    }
                  }
                }
              }

              // crypto ikev2 profile * / aaa authorization group eap list
              container eap {
                tailf:info "AAA list to use when IKEv2 remote auth method is EAP";
                uses crypto-ikev2-profile-aaa-authorization-group-list {
                  refine "list/password/secret" {
                    tailf:meta-data "secret-password" {
                      tailf:meta-value "crypto ikev2 profile <profile><NL><*> ::  aaa authorization group eap list <list> password <PASSWORD>";
                    }
                  }
                }
              }
            }

            // crypto ikev2 profile * / aaa authorization user
            container user {
              tailf:info "AAA user authorization";
              container psk {
                tailf:info "AAA list to use when IKEv2 remote auth "+
                  "method is PSK";
                leaf cached {
                  tailf:info "Use cached attributes from EAP authentication "+
                    "or AAA pre-shared key fetch";
                  type empty;
                }
                leaf "list" {
                  tailf:info "AAA method list";
                  type string {
                    tailf:info "WORD;;AAA list name";
                  }
                }
              }
            }
          }
        }

        // crypto ikev2 profile * / virtual-template
        container virtual-template {
          tailf:info "Specify the virtual-template for dynamic interface creation";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf number {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-4095>;;Virtual-template number";
              range "1..4095";
            }
          }
          leaf mode {
            tailf:info "Enabling Tunnel Auto Mode";
            type enumeration {
              enum auto {
                tailf:info "Auto - Enable Auto feature on the ike profile";
              }
            }
          }
        }

        // crypto ikev2 profile * / lifetime
        leaf lifetime {
          tailf:info "Set lifetime for ISAKMP security association";
          type uint32 {
            tailf:info "<120-86400>;;lifetime in seconds";
            range "120..86400";
          }
          default 86400;
        }

        // crypto ikev2 profile * / dpd
        container dpd {
          tailf:info "Enable IKE liveness check for peers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<10-3600>;;DPD R-U-THERE interval";
              range "10..3600";
            }
          }
          leaf retry-interval {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<2-60>;;DPD Retry Interval";
            }
          }
          leaf queries {
            tailf:cli-drop-node-name;
            type enumeration {
              enum  on-demand {
                tailf:info "Send DPD queries only as needed";
              }
              enum periodic {
                tailf:info "Send DPD queries at regular intervals";
              }
            }
          }
        }
      }

      // crypto ikev2 fragmentation
      container fragmentation {
        tailf:info "Enable fragmentation of ikev2 packets";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf mtu {
          tailf:info "MTU size for fragmentation";
          type uint16 {
            tailf:info "<68-1500>;;ikev2 MTU including IP and UDP header size";
            range "68..1500";
          }
        }
      }

      // no crypto ikev2 http-url cert
      container http-url {
        tailf:info "Enable http URL lookup";
        leaf cert {
          tailf:info "Enable certificate lookup based on HTTP-based URL";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // crypto ikev2 client flexvpn *
      container client {
        tailf:info "IKEv2 client configuration";
        list flexvpn {
          tailf:info "Configure an IKEv2 FlexVPN client";
          tailf:cli-mode-name "config-ikev2-flexvpn";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;IKEv2 FlexVPN name";
            }
          }

          // crypto ikev2 client flexvpn * / peer
          container peer {
            tailf:info "Allowed Encryption/Decryption Peer";

            // crypto ikev2 client flexvpn * / peer *
            list peer-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key sequence;
              leaf sequence {
                type uint8 {
                  tailf:info "<1-255>;;peer sequence number";
                  range "1..255";
                }
              }
              choice address-choice {
                leaf ipv4-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;ip address";
                  }
                }
                leaf ipv6-address {
                  tailf:cli-drop-node-name;
                  type inet:ipv6-address {
                    tailf:info "X:X:X:X::X;;IPv6 address";
                  }
                }
                case fqdn {
                  leaf fqdn {
                    tailf:info "Peer host name";
                    type string {
                      tailf:info "WORD;;Peer Hostname";
                    }
                  }
                  leaf dynamic {
                    tailf:info "Dynamic host name";
                    tailf:cli-optional-in-sequence;
                    type empty;
                  }
                  leaf ipv6 {
                    tailf:info "IPv6 host name";
                    tailf:cli-optional-in-sequence;
                    type empty;
                  }
                }
              }

              // crypto ikev2 client flexvpn * / peer * track
              leaf track {
                tailf:info "Peer track object";
                type uint16 {
                  tailf:info "<1-1000>;;Track object number";
                  range "1..1000";
                }
              }
            }

            // crypto ikev2 client flexvpn * / peer reactivate
            leaf reactivate {
              tailf:info "Re-activate peer enabled";
              tailf:cli-full-command;
              type empty;
            }
          }

          // crypto ikev2 client flexvpn * / source *
          list source {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-remove-before-change;
            key seq;
            leaf seq {
              type uint8 {
                tailf:info "<1-255>;;source sequence number";
                range "1..255";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              uses interface-name-grouping;
            }
            leaf track {
              tailf:info "source track object";
              type uint16 {
                tailf:info "<1-1000>;;track object number";
                range "1..1000";
              }
            }
          }

          // crypto ikev2 client flexvpn * / client
          container client {
            tailf:info "Client interface";
            container connect {
              tailf:info "tunnel interface";
              // crypto ikev2 client flexvpn * / client connect Tunnel
              leaf Tunnel {
                tailf:info "Tunnel interface";
                tailf:cli-allow-join-with-value {
                  tailf:cli-display-joined;
                }
                tailf:non-strict-leafref {
                  path "../../../../../../../interface/Tunnel/name";
                }
                type uint32 {
                  tailf:info "<0-2147483647>;;Tunnel interface number";
                  range "0..2147483647";
                }
              }
            }
          }
        }
      }

      // crypto ikev2 dpd
      container dpd {
        tailf:info "Enable IKE liveness check for peers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf retry-interval {
          tailf:cli-drop-node-name;
          type uint32;
        }
        leaf mode {
          tailf:cli-drop-node-name;
          type enumeration {
            enum on-demand { }
            enum periodic { }
          }
        }
      }
    }

    // crypto pki
    container pki {
      tailf:info "Public Key components";

      // crypto pki server *
      list server {
        // NOTE: See ///EXEC for rollover [cancel] sub command.
        tailf:info "Enable IOS Certificate server";
        tailf:cli-mode-name "cs-server";
        tailf:cli-compact-syntax;
        tailf:cli-full-command;
        max-elements 1;
        key cs-label;
        leaf cs-label {
          type string {
            tailf:info "WORD;;Certificate Server Name";
          }
        }

        // crypto pki server * / shutdown
        leaf shutdown {
          tailf:info "Shutdown the Certificate Server";
          type empty;
        }

        // crypto pki server * / database archive
        container database {
          tailf:info "Certificate Server database config parameters";
          container archive {
            tailf:info "Backup Certificate Server Signing Certificate and Keys";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf format {
              tailf:cli-drop-node-name;
              type enumeration {
                enum pem {
                  tailf:info "PEM format";
                }
                enum pkcs12 {
                  tailf:info "PKCS12 format";
                }
              }
            }
            container password {
              tailf:info "Passphrase to protect the private key archive";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf "type" {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<0-9>;;Encryption type";
                  range "0..9";
                }
              }
              leaf secret {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "LINE;;Password";
                }
              }
            }
          }
        }

        // crypto pki server * / grant
        leaf grant {
          tailf:info "Certificate granting options";
          type enumeration {
            enum auto {
              tailf:info "Automatically grant incoming SCEP enrollment "+
              "requests";
            }
            enum none {
              tailf:info "Automatically reject any incoming SCEP enrollment "+
              "request";
            }
            enum ra-auto {
              tailf:info "Automatically grant RA-authorized incoming SCEP "+
                "enrollment request";
            }
          }
        }

        // crypto pki server * / hash
        leaf hash {
          tailf:info "Hash algorithm";
          type enumeration {
            enum md5 {
              tailf:info "use md5 hash algorithm";
            }
            enum sha1 {
              tailf:info "use sha1 hash algorithm";
            }
            enum sha256 {
              tailf:info "use sha256 hash algorithm";
            }
            enum sha384 {
              tailf:info "use sha384 hash algorithm";
            }
            enum sha512 {
              tailf:info "use sha512 hash algorithm";
            }
          }
        }
      }

      // crypto pki trustpoint *
      list trustpoint {
        tailf:info "Define a CA trustpoint";
        tailf:cli-mode-name "ca-trustpoint";
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;CA Server Name";
          }
        }

        // crypto pki trustpoint * / serial-number
        container serial-number {
          tailf:info "include serial number";
          tailf:cli-reset-container;
          presence true;
          leaf none {
            tailf:info "do not include serial number";
            type empty;
          }
        }

        // crypto pki trustpoint * / ip-address
        leaf ip-address {
          tailf:info "include ip address";
          tailf:cli-diff-dependency "../../../../interface";
          type union {
            type string {
              tailf:info "LINE;;interface name or ip address";
            }
            type enumeration {
              enum none {
                tailf:info "do not include ip address";
              }
            }
          }
        }

        // crypto pki trustpoint * / enrollment
        container enrollment {
          tailf:info "Enrollment parameters";

          // crypto pki trustpoint * / enrollment http-proxy
          leaf http-proxy {
            tailf:info "HTTP proxy server for enrollment";
            type string {
              tailf:info "WORD;;host-name";
            }
          }

          // crypto pki trustpoint * / enrollment mode ra
          container mode {
            tailf:info "Mode supported by the Certificate Authority";
            leaf ra {
              tailf:info "Registration Authority mode";
              type empty;
            }
          }

          // crypto pki trustpoint * / enrollment pkcs12
          leaf pkcs12 {
            tailf:info "";
            type empty;
          }

          // crypto pki trustpoint * / enrollment profile
          leaf profile {
            tailf:info "Specify an profile for enrollment";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }

          // crypto pki trustpoint * / enrollment retry
          container retry {
            tailf:info "Polling parameters";
            leaf count {
              tailf:info "How many times to poll CA for our certificate";
              type uint8 {
                tailf:info "<1-100>;;Number of times to poll a CA for a "
                  +"certificate";
                range "1..100";
              }
            }
            leaf period {
              tailf:info "How long to wait between requests to CA for our "
                +"certificate";
              type uint8 {
                tailf:info "<1-60>;;Period in minutes between attempts to "
                  +"contact a CA";
                range "1..60";
              }
            }
          }

          // crypto pki trustpoint * / enrollment selfsigned
          leaf selfsigned {
            tailf:info "Generate a Self Signed Certificate";
            type empty;
          }

          // crypto pki trustpoint * / enrollment terminal
          container terminal {
            tailf:info "Enroll via the terminal (cut-and-paste)";
            tailf:cli-delete-when-empty;
            presence true;
            leaf pem {
              tailf:info "Include PEM encapsulation boundaries";
              type empty;
            }
          }

          // crypto pki trustpoint * / enrollment url
          leaf url {
            tailf:info "CA server enrollment URL";
            type string {
              tailf:info "WORD;;HTTP URL";
            }
          }
        }

        // crypto pki trustpoint * / password
        container password {
          tailf:info "revocation password";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }

        // crypto pki trustpoint * / subject-name
        leaf subject-name {
          tailf:info "Subject Name";
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Subject Name";
          }
        }

        // crypto pki trustpoint * / fqdn
        leaf fqdn {
          tailf:info "include fully-qualified domain name";
          tailf:cli-full-command;
          type union {
            type enumeration {
              enum none {
                tailf:info "do not include fully-qualified domain name";
              }
            }
            type string {
              tailf:info "LINE;;fully-qualified domain name";
            }
          }
        }

        // crypto pki trustpoint * / usage
        container usage {
          tailf:info "Certificate Usage";
          leaf ike {
            tailf:info "IKE certificate";
            type empty;
          }
          leaf ssl-server {
            tailf:info "SSL server certificate";
            type empty;
          }
          leaf ssl-client {
            tailf:info "SSL client certificate";
            type empty;
          }
        }

        // crypto pki trustpoint * / revocation-check
        leaf-list revocation-check {
          tailf:info "Revocation checking options";
          tailf:cli-flat-list-syntax;
          tailf:cli-replace-all;
          ordered-by user;
          type enumeration {
            enum crl { // Note: DO NOT reorder, Enum(0) used in java code.
              tailf:info "Revocation check by CRL";
            }
            enum none {
              tailf:info "Ignore revocation check";
            }
            enum ocsp {
              tailf:info "Revocation check by OCSP";
            }
          }
        }

        // crypto pki trustpoint * / source interface
        container source {
          tailf:info "Specify source";
          container interface {
            tailf:info "Interface used as source address";
            uses interface-name-grouping;
          }
        }

        // crypto pki trustpoint * / rsakeypair
        container rsakeypair {
          tailf:info "Specify rsakeypair for this identity";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf key-label {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;RSA keypair label";
            }
          }
          leaf key-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<360-4096>;;General Purpose or Signature Key length";
              range "360..4096";
            }
          }
          leaf encryption-key-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<360-4096>;;Encryption Key length";
              range "360..4096";
            }
          }
        }

        // crypto pki trustpoint * / auto-enroll
        container auto-enroll {
          tailf:info "Automatically enroll this router identity";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
          leaf percent {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-100>;;renewal percentage";
              range "0..100";
            }
          }
          leaf regenerate {
            tailf:info "Regenerate keys on re-enrollment";
            type empty;
          }
        }
      }

      // crypto pki certificate
      container certificate {
        tailf:info "Actions on certificates";

        // crypto pki certificate chain *
        list chain {
          tailf:info "Identify certificates";
          tailf:cli-mode-name "config-cert-chain";
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../trustpoint";
            type string {
              tailf:info "WORD;;CA Server Name";
            }
          }

          // crypto pki certificate chain * / certificate *
          list certificate {
            tailf:info "Certificate issued by the CA";
            tailf:cli-mode-name "config-pki-hexmode-quotedstring";
            tailf:cli-delete-when-empty;
            tailf:cli-exit-command "quit";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-full-command;
            tailf:cli-reset-container;
            key serial;
            leaf serial {
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;Certificate serial number";
              }
            }
            leaf cert-type {
              tailf:cli-optional-in-sequence;
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum ca {
                  tailf:info "A certificate";
                }
                enum ra-encrypt {
                  tailf:info "A encryption certificate";
                }
                enum ra-general {
                  tailf:info "A general purpose certificate";
                }
                enum ra-sign {
                  tailf:info "A signing certificate";
                }
                enum rollover {
                  tailf:info "Shadow rollover certificate";
                }
                enum self-signed {
                  tailf:info "Self-signed certificate";
                }
              }
            }
            leaf rollover {
              tailf:info "Shadow rollover certificate";
              tailf:cli-optional-in-sequence;
              tailf:cli-prefix-key;
              type empty;
            }
            leaf cert {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value "rollover|ca|ra-encrypt|ra-general"+
                "|ra-sign|self-signed";
              type string {
                tailf:info "WORD;;file specification";
              }
            }
          }
        }
      }

      // crypto pki token *
      container token {
        tailf:info "Configure cryptographic token";
        list token-name {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;token name";
            }
          }
          uses crypto-pki-token-grouping;
        }
      }

      // crypto pki default
      container "default" {
        tailf:info "set default values for tokens";
        uses crypto-pki-token-grouping;
      }
    }

    // crypto isakmp
    container isakmp {
      tailf:info "Configure ISAKMP policy";

      // no crypto isakmp default policy
      container "default" {
        tailf:info "ISAKMP default policy";
        leaf policy {
          tailf:info "Enable default policies for ISAKMP protection suite";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // no crypto isakmp enable
      leaf enable {
        tailf:info "Enable ISAKMP";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // crypto isakmp identity
      leaf "identity" {
        tailf:info "Set the identity which ISAKMP will use";
        type enumeration {
          enum address {
            tailf:info "Use the IP address of the interface for the identity";
          }
          enum dn {
            tailf:info "Use the distinguished name of the router cert for the identity";
          }
          enum hostname {
            tailf:info "Use the hostname of the router for the identity";
          }
        }
        default address;
      }

      // crypto isakmp fragmentation
      leaf fragmentation {
        tailf:info "IKE Fragmentation enabled if required";
        type empty;
      }

      // crypto isakmp invalid-spi-recovery
      leaf invalid-spi-recovery {
        tailf:info "Initiate IKE and send Invalid SPI Notify";
        type empty;
      }

      // crypto isakmp client configuration
      container client {
        tailf:info "Set client configuration policy";
        container configuration {
          tailf:info "Set client configuration policy";

          // crypto isakmp client configuration group *
          list group {
            tailf:info "Set group profile attributes for client";
            tailf:cli-mode-name "config-isakmp-group";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;group name";
              }
            }

            // crypto isakmp client configuration group * / key
            container "key" {
              tailf:info "pre-shared key/IKE password";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              uses crypto-key-grouping {
                refine "secret" {
                  tailf:cli-remove-before-change;
                }
              }
            }

            // crypto isakmp client configuration group * / pool
            leaf pool {
              tailf:info "Set name of address pool";
              type string {
                tailf:info "WORD;;address pool name";
              }
            }

            // crypto isakmp client configuration group * / netmask
            leaf netmask {
              tailf:info "netmask used by the client for local connectivity";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Subnet Mask to be issued for client use";
              }
            }
          }
        }
      }

      // crypto isakmp profile *
      list profile {
        tailf:info "Define ISAKMP Profiles";
        tailf:cli-mode-name "conf-isa-prof";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ISAKMP Profile";
          }
        }

        // crypto isakmp profile * / description
        leaf "description" {
          tailf:info "Specify a description of this profile";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;a 1 line description of the profile";
          }
        }

        // crypto isakmp profile * / vrf
        leaf vrf {
          tailf:info "Specify the VRF it is related to";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VRF Name";
          }
        }

        // crypto isakmp profile * / keyring *
        list keyring {
          tailf:info "Specify keyring to use";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-diff-dependency "../../../../keyring";
            type union {
              type enumeration {
                enum "default" {
                  tailf:info "Use global keyring";
                }
              }
              type string {
                tailf:info "WORD;;Name of the keyring to use";
              }
            }
          }
        }

        // crypto isakmp profile * / self-identify
        container self-identity {
          tailf:info "Specify Identity to use";
          choice  self-identity-choice {
            container address {
              tailf:info "Use IPv4 address";
              presence true;
            }
            container fqdn {
              tailf:info "Use FQDN";
              presence true;
            }
            leaf user-fqdn {
              tailf:info "Use user FQDN";
              type string {
                tailf:info "WORD;;User FQDN <user@full.domain.name>";
              }
            }
          }
        }

        // crypto isakmp profile * / match
        container match {
          tailf:info "Match values of peer";

          // crypto isakmp profile * / match fvrf
          leaf fvrf {
            tailf:info "fvrf of the profile";
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type union {
              type string {
                tailf:info "WORD;;fvrf name (default: global)";
              }
              type enumeration {
                enum any {
                  tailf:info "any fvrf";
                }
              }
            }
          }

          // crypto isakmp profile * / match identity
          container "identity" {
            tailf:info "Peer identity";

            // crypto isakmp profile * / match identity group *
            list group {
              tailf:info "Group name";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Specify the group name";
                }
              }
            }

            // crypto isakmp profile * / match identity address *
            container address {
              tailf:info "IP Address(es)";
              list ipv4 {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key "address mask";
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IP address prefix";
                  }
                }
                leaf mask {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;specify mask";
                  }
                }
                leaf vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }
              container ipv4-host {
                tailf:cli-drop-node-name;
                list ipv4 {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key address;
                  leaf address {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;IP address prefix";
                    }
                  }
                  leaf vrf {
                    tailf:cli-drop-node-name;
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Specify the F VRF (default global)";
                    }
                  }
                }
              }
              list ipv6 {
                tailf:info "IPv6 Address(es)";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key address;
                leaf address {
                  type ipv6-prefix {
                    tailf:info "X:X:X:X::X/<0-128>;;IPv6 address prefix";
                  }
                }
                leaf vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }
            }

            // crypto isakmp profile * / match identity host
            container host {
              tailf:info "match a hostname/domain";

              // crypto isakmp profile * / match identity host
              leaf domain-name {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;Specify the domain name";
                }
              }

              // crypto isakmp profile * / match identity host * <vrf>
              list domain-name-vrf {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-incomplete-command;
                tailf:cli-incomplete-no;
                key domain;
                leaf domain {
                  type string {
                    tailf:info "WORD;;Specify the domain name";
                  }
                }
                leaf vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;Specify the F VRF (default global)";
                  }
                }
              }

              // crypto isakmp profile * / match identity host domain *
              container domain {
                tailf:info "match domain instead of exact";

                // crypto isakmp profile * / match identity host domain * <vrf>
                list domain-name-vrf {
                  tailf:cli-drop-node-name;
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-incomplete-command;
                  tailf:cli-incomplete-no;
                  key domain;
                  leaf domain {
                    type string {
                      tailf:info "WORD;;Specify the domain name";
                    }
                  }
                  leaf vrf {
                    tailf:cli-drop-node-name;
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Specify the VRF (default global)";
                    }
                  }
                }

                // crypto isakmp profile * / match identity host domain
                leaf domain-name {
                  tailf:cli-drop-node-name;
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Specify the domain name";
                  }
                }
              }
            }
          }
        }

        // crypto isakmp profile * / client
        container client {
          tailf:info "Specify client configuration settings";

          // crypto isakmp profile * / client authentication
          container authentication {
            tailf:info "Use Extended Authentication";
            leaf "list" {
              tailf:info "AAA authentication list to use";
              type string {
                tailf:info "WORD;;Named authentication list.";
              }
            }
          }

          // crypto isakmp profile * / client configuration address
          container configuration {
            tailf:info "Specify client configuration settings";
            container address {
              tailf:info "Specify client network address configuration";

              // crypto isakmp profile * / client configuration address initiate
              leaf initiate {
                tailf:info "Push the network address to the client";
                type empty;
              }

              // crypto isakmp profile * / client configuration address respond
              leaf respond {
                tailf:info "Respond to network address requests "+
                  "from the client";
                type empty;
              }
            }
          }
        }

        // crypto isakmp profile * / isakmp authorization list
        container isakmp {
          tailf:info "ISAKMP Authorization command";
          container authorization {
            tailf:info "Authorization parameters.";
            leaf "list" {
              tailf:info "AAA authorization list to use";
              type string {
                tailf:info "WORD;;Named authorization list.";
              }
            }
          }
        }

        // crypto isakmp profile * / keepalive
        container keepalive {
          tailf:info "Set a keepalive interval for use with IOS peers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf seconds {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<10-3600>;;Number of seconds between keep alives";
              range "10..3600";
            }
          }
          leaf retry {
            tailf:info "Retry interval if keepalive fails";
            type uint8 {
              tailf:info "<2-60>;;Number of seconds between retries if "+
                "keepalive fails";
              range "2..60";
            }
          }
        }

        // crypto isakmp profile * / local-address
        container local-address {
          tailf:info "Interface to use for local address for this isakmp profile";
          choice local-address-choice {
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Specify an IPv4 address to bind to";
              }
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Specify an IPv6 address to bind to";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              uses interface-name-grouping;
            }
          }
        }

        // crypto isakmp profile * / virtual-template
        leaf virtual-template {
          tailf:info "Specify the virtual-template for dynamic interface "+
            "creation.";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-200>;;Virtual-template Number to clone";
            range "1..200";
          }
        }

        // crypto isakmp profile * / qos-group
        leaf qos-group {
          tailf:info "Apply a Qos policy class map for this profile";
          type uint16 {
            tailf:info "<1-1023>;;Qos Group value";
            range "1..1023";
          }
        }
      }

      // crypto isakmp policy *
      list policy {
        tailf:info "Set policy for an ISAKMP protection suite";
        tailf:cli-mode-name "config-isakmp";
        key priority;
        leaf priority {
          type uint16 {
            tailf:info "<1-10000>;;Priority of protection suite";
          }
        }

        // crypto isakmp policy * / encr
        container encr {
          tailf:info "Set encryption algorithm for protection suite";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf algorithm {
            tailf:cli-drop-node-name;
            type enumeration {
              enum des {
                tailf:info "DES - Data Encryption Standard (56 bit keys).";
              }
              enum "3des" {
                tailf:info "Three key triple DES";
              }
              enum aes {
                tailf:info "AES - Advanced Encryption Standard.";
              }
            }
            default des;
          }
          leaf bits {
            when "../algorithm = 'aes'" {
              tailf:dependency "../algorithm";
            }
            tailf:cli-drop-node-name;
            type enumeration {
              enum "128" {
                tailf:info "128 bit keys.";
              }
              enum "192" {
                tailf:info "192 bit keys.";
              }
              enum "256" {
                tailf:info "256 bit keys.";
              }
            }
            default 128;
          }
        }

        // crypto isakmp policy * / hash
        leaf hash {
          tailf:info "Set hash algorithm for protection suite";
          type enumeration {
            enum md5 {
              tailf:info "Message Digest 5";
            }
            enum sha {
              tailf:info "Secure Hash Standard";
            }
            enum sha256 {
              tailf:info "Secure Hash Standard";
            }
          }
          default sha;
        }

        // crypto isakmp policy * / authentication
        leaf authentication {
          tailf:info "Set authentication method for protection suite";
          type enumeration {
            enum pre-share {
              tailf:info "Pre-Shared Key";
            }
            enum rsa-encr {
              tailf:info "Rivest-Shamir-Adleman Encryption";
            }
            enum rsa-sig {
              tailf:info "Rivest-Shamir-Adleman Signature";
            }
          }
        }

        // crypto isakmp policy * / group
        leaf group {
          tailf:info "Set the Diffie-Hellman group";
          type enumeration {
            enum "1" {
              tailf:info "Diffie-Hellman group 1 (768 bit)";
            }
            enum "2" {
              tailf:info "Diffie-Hellman group 2 (1024 bit)";
            }
            enum "5" {
              tailf:info "Diffie-Hellman group 5 (1536 bit)";
            }
            enum "14" {
              tailf:info "Diffie-Hellman group 14 (2048 bit)";
            }
            enum "15" {
              tailf:info "Diffie-Hellman group 15 (3072 bit)";
            }
            enum "16" {
              tailf:info "Diffie-Hellman group 16 (4096 bit)";
            }
            enum "19" {
              tailf:info "Diffie-Hellman group 19 (256 bit ecp)";
            }
            enum "20" {
              tailf:info "Diffie-Hellman group 20 (384 bit ecp)";
            }
            enum "21" {
              tailf:info "Diffie-Hellman group 21 (521 bit ecp)";
            }
            enum "24" {
              tailf:info "Diffie-Hellman group 24 (2048 bit, 256 bit subgroup)";
            }
          }
        }

        // crypto isakmp policy * / lifetime
        leaf lifetime {
          tailf:info "Set lifetime for ISAKMP security association";
          type uint32 {
            tailf:info "<60-86400>;;lifetime in seconds";
            range "60..86400";
          }
          default 86400;
        }
      }

      // crypto isakmp keepalive
      container keepalive {
        tailf:info "Set a keepalive interval for use with IOS peers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<10-3600>;;Number of seconds between keep alives";
            range "10..3600";
          }
        }
        leaf retry-seconds {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<2-60>;;Number of seconds between retries if keepalive fails";
            range "2..60";
          }
        }
        leaf option {
          tailf:cli-drop-node-name;
          type enumeration {
            enum periodic {
              tailf:info "When using Dead Peer Detection (DPD), "+
              "send periodic DPD messages";
            }
            enum on-demand {
              tailf:info "When using Dead Peer Detection (DPD), send DPD "+
                "messages only as needed";
            }
          }
          default on-demand;
        }
      }

      // crypto isakmp nat
      container nat {
        tailf:info "Set a nat  keepalive interval for use with IOS peers";
        container keepalive {
          tailf:info "Set a keepalive interval for use with IOS peers";
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<5-3600>;;Number of seconds between keep alives";
              range "5..3600";
            }
          }
        }
      }

      // crypto isakmp key * address
      list "key" {
        tailf:info "Set pre-shared key for remote peer";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        key address;
        leaf address {
          tailf:cli-expose-key-name;
          tailf:info "define shared key with IP address";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Peer IP address";
          }
        }
        leaf encrypted {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum "6" {
              tailf:info "Specifies an ENCRYPTED password will follow";
            }
          }
        }
        leaf keystring {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value "0|6";
          tailf:cli-reset-container;
          tailf:cli-remove-before-change;
          tailf:meta-data "secret-password" {
            tailf:meta-value "crypto isakmp key <PASSWORD> address <key>";
          }
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Peer IP subnet mask";
          }
        }
        leaf no-xauth {
          tailf:info "Bypasses XAuth for this peer";
          type empty;
        }
      }

      // crypto isakmp key ? address ipv6 *
      container key-ipv6-list {
        tailf:cli-drop-node-name;
        list "key" {
          tailf:info "Set pre-shared key for remote peer";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key ipv6;
          leaf ipv6 {
            tailf:info "define shared key with IPv6 address";
            tailf:cli-expose-key-name;
            type ipv6-prefix {
              tailf:info "X:X:X:X::X/<0-128>;;Peer IPv6 prefix";
            }
          }
          leaf encrypted {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "6" {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf keystring {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-disallow-value "0|6";
            tailf:cli-reset-container;
            tailf:cli-remove-before-change;
            tailf:meta-data "secret-password" {
              tailf:meta-value "crypto isakmp key <PASSWORD> address ipv6 <key>";
            }
            type string {
              tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
            }
          }
          leaf address {
            tailf:info "define shared key with IP address";
            tailf:cli-prefix-key;
            type empty;
          }
          leaf no-xauth {
            tailf:info "Bypasses XAuth for this peer";
            type empty;
          }
        }
      }

      // crypto isakmp key * hostname
      container key-hostname-list {
        tailf:cli-drop-node-name;
        list "key" {
          tailf:info "Set pre-shared key for remote peer";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key hostname;
          leaf hostname {
            tailf:cli-expose-key-name;
            tailf:info "define shared key with hostname";
            type string {
              tailf:info "WORD;;hostname of peer with whom the key is shared";
            }
          }
          leaf encrypted {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum "6" {
                tailf:info "Specifies an ENCRYPTED password will follow";
              }
            }
          }
          leaf keystring {
            tailf:cli-drop-node-name;
            tailf:cli-prefix-key;
            tailf:cli-disallow-value "0|6";
            tailf:cli-reset-container;
            tailf:cli-remove-before-change;
            tailf:meta-data "secret-password" {
              tailf:meta-value "crypto isakmp key <PASSWORD> hostname <key>";
            }
            type string {
              tailf:info "WORD;;The UNENCRYPTED (cleartext) user password";
            }
          }
          leaf no-xauth {
            tailf:info "Bypasses XAuth for this peer";
            type empty;
          }
        }
      }
    }

    // crypto ipsec
    container ipsec {
      tailf:info "Configure IPSEC policy";

      // crypto ipsec optional
      container optional {
        tailf:info "Enable optional encryption for IPSec";
        tailf:cli-delete-when-empty;
        presence true;
        leaf retry {
          tailf:info "Configure length of IPSec retry interval";
          type uint32 {
            tailf:info "<60-86400>;;Number of seconds between IPSec retries";
            range "60..86400";
          }
        }
      }

      // crypto ipsec security-association
      container security-association {
        tailf:info "Security association parameters";

        // crypto ipsec security-association idle-time
        leaf idle-time {
          tailf:info "Automatically delete IPSec SAs after a "+
            "given idle period.";
          type uint32 {
            tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
            range "60..86400";
          }
        }

        // crypto ipsec security-association lifetime
        container lifetime {
          tailf:info "security association lifetime";
          leaf kilobytes {
            tailf:info "Volume-based key duration";
            type union {
              type uint32 {
                tailf:info "<2560-4294967295>;;Security association "+
                  "duration in kilobytes encrypted";
              }
              type enumeration {
                enum disable {
                  tailf:info "Disable Volume-based Rekey";
                }
              }
            }
          }
          leaf seconds {
            tailf:info "Time-based key duration";
            type uint32 {
              tailf:info "<120-86400>;;Security association "+
                "duration in seconds";
              range "120..86400";
            }
          }
        }

        // crypto ipsec security-association replay
        container replay {
          tailf:info "Set replay checking.";
          leaf disable {
            tailf:info "Disable replay checking";
            type empty;
          }
          leaf window-size {
            tailf:info "Set replay window size.";
            type ipsec-window-size-type;
          }
        }
      }

      // crypto ipsec transform-set *
      list transform-set {
        tailf:info "Define transform and settings";
        tailf:cli-mode-name "cfg-crypto-trans";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Transform set tag";
          }
        }
        leaf transform1 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum ah-md5-hmac {
              tailf:info "AH-HMAC-MD5 transform";
            }
            enum ah-sha-hmac {
              tailf:info "AH-HMAC-SHA transform";
            }
            enum ah-sha256-hmac {
              tailf:info "AH-HMAC-SHA256 transform";
            }
            enum ah-sha384-hmac {
              tailf:info "AH-HMAC-SHA384 transform";
            }
            enum ah-sha512-hmac {
              tailf:info "AH-HMAC-SHA512 transform";
            }
          }
        }
        leaf transform2 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum esp-3des {
              tailf:info "ESP transform using 3DES(EDE) cipher (168 bits)";
            }
            enum esp-aes {
              tailf:info "ESP transform using AES cipher";
            }
            enum esp-des {
              tailf:info "ESP transform using DES cipher (56 bits)";
            }
            enum esp-gcm {
              tailf:info "ESP transform using GCM";
            }
            enum esp-gmac {
              tailf:info "ESP transform using GMAC cipher";
            }
            enum esp-null {
              tailf:info "ESP transform w/o cipher";
            }
            enum esp-seal {
              tailf:info "ESP transform using SEAL cipher (160 bits)";
            }
          }
        }
        leaf transform2-bits {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum "128" {
              tailf:info "128 bit keys (with transform2)";
            }
            enum "192" {
              tailf:info "192 bit keys (with transform2)";
            }
            enum "256" {
              tailf:info "256 bit keys (with transform2)";
            }
          }
          default 128;
        }
        leaf transform3 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum esp-md5-hmac {
              tailf:info "ESP transform using HMAC-MD5 auth";
            }
            enum esp-sha-hmac {
              tailf:info "ESP transform using HMAC-SHA auth";
            }
            enum esp-sha256-hmac {
              tailf:info "ESP transform using HMAC-SHA256 auth";
            }
            enum esp-sha384-hmac {
              tailf:info "ESP transform using HMAC-SHA384 auth";
            }
            enum esp-sha512-hmac {
              tailf:info "ESP transform using HMAC-SHA512 auth";
            }
          }
        }
        leaf transform4 {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum comp-lzs {
              tailf:info "IP Compression using the LZS compression algorithm";
            }
          }
        }

        // crypto ipsec transform-set * / mode
        container mode {
          tailf:info "encapsulation mode (transport/tunnel)";
          choice mode-choice {

            // crypto ipsec transform-set * / mode transport
            container transport {
              tailf:info "transport (payload encapsulation) mode";
              presence true;
              leaf require {
                tailf:info "Accept only the configured encapsulation mode.";
                type empty;
              }
            }

            // crypto ipsec transform-set * / mode tunnel
            leaf tunnel {
              tailf:info "tunnel (datagram encapsulation) mode";
              type empty;
            }
            default tunnel; // cat6500
          }
        }
      }

      // no crypto ipsec default transform-set
      container "default" {
        tailf:info "Default transform-set";
        leaf transform-set {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // crypto ipsec fragmentation
      leaf fragmentation {
        tailf:info "Handling of fragmentation of near-MTU sized packets";
        type enumeration {
          enum after-encryption {
            tailf:info "Perform fragmentation of large packets after "+
              "IPSec encapsulation.";
          }
          enum before-encryption {
            tailf:info "Perform fragmentation of large packets before "+
              "IPSec encapsulation.";
          }
        }
      }

      // crypto ipsec df-bit
      leaf df-bit {
        tailf:info "Handling of encapsulated DF bit.";
        type enumeration {
          enum clear {
            tailf:info "Clear DF bit for encapsulated packets.";
          }
          enum copy {
            tailf:info "Copy DF bit from inner for encapsulated packets.";
          }
          enum set {
            tailf:info "Set DF bit for encapsulated packets.";
          }
        }
      }

      // crypto ipsec nat-transparency
      leaf nat-transparency {
        tailf:info "IPsec NAT transparency model";
        type enumeration {
          enum spi-matching {
            tailf:info "Match inbound SPI to outbound SPI for IPsec aware NAT";
          }
          enum udp-encapsulation {
            tailf:info "UDP encapsulation of IPsec protocols";
          }
        }
      }

      // crypto ipsec profile *
      list profile {
        tailf:info "Configure an ipsec policy profile";
        tailf:cli-mode-name "ipsec-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }

        // crypto ipsec profile * / set
        container set {
          tailf:info "Set values for encryption/decryption";

          // crypto ipsec profile * / set security-association
          container security-association {
            tailf:info "Security association parameters";

            // crypto ipsec profile * / set security-association dfbit
            leaf dfbit {
              tailf:info "Handling of encapsulated DF bit.";
              tailf:cli-full-command;
              type enumeration {
                enum clear {
                  tailf:info "Clear DF bit for encapsulated packets.";
                }
                enum copy {
                  tailf:info "Copy DF bit from inner for encapsulated packets.";
                }
                enum set {
                  tailf:info "Set DF bit for encapsulated packets.";
                }
              }
            }

            // crypto ipsec profile * / set security-association lifetime
            container lifetime {
              tailf:info "security association lifetime";
              leaf kilobytes {
                tailf:info "Volume-based key duration";
                type union {
                  type uint32 {
                    tailf:info "<2560-4294967295>;;Security association "+
                      "duration in kilobytes encrypted";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable Volume-based Rekey";
                    }
                  }
                }
              }
              choice time-based-choice {
                default seconds;
                leaf seconds {
                  tailf:info "Time-based key duration";
                  type uint32 {
                    tailf:info "<120-86400>;;Security association "+
                      "duration in seconds";
                    range "120..86400";
                  }
                  default 3600;
                }
                leaf days {
                  tailf:info "Time-based key duration in days";
                  type uint8 {
                    tailf:info "<1-30>;;Security association duration in days";
                    range "1..30";
                  }
                }
              }
            }

            // crypto ipsec profile * / set security-association idle-time
            container idle-time {
              tailf:info "Automatically delete IPSec SAs after a given idle period.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
                  range "60..86400";
                }
              }
              leaf "default" {
                tailf:info "All SAs idle-out reset to default peer";
                type empty;
              }
            }

            // crypto ipsec profile * / set security-association replay
            container replay {
              tailf:info "Set replay checking.";
              leaf disable {
                tailf:info "Disable replay checking";
                type empty;
              }
              leaf window-size {
                tailf:info "Set replay window size.";
                type ipsec-window-size-type;
              }
            }

            // crypto ipsec profile * / set security-association dummy
            container dummy {
              tailf:info "Enable transmitting dummy packets";
              choice dummy-choice {
                leaf pps {
                  tailf:info "Simulated traffic rate (in pps)";
                  type uint8 {
                    tailf:info "<0-25>;;Rate of simulated traffic (in PPS)";
                    range "0..25";
                  }
                }
                leaf seconds {
                  tailf:info "Simulated traffic rate (in seconds)";
                  type uint16 {
                    tailf:info "<1-3600>;;Rate of simulated traffic "+
                      "(seconds between packets)";
                    range "1..3600";
                  }
                }
              }
            }

            // crypto ipsec profile * / set security-association ecn
            leaf ecn {
              tailf:info "Handling of ECN bit";
              tailf:cli-full-command;
              type enumeration {
                enum discard {
                  tailf:info "Discard the Explicit Congestion Notification bits on decryption";
                }
                enum propagate {
                  tailf:info "Propagate the Explicit Congestion Notification bits on decryption (RFC4301)";
                }
              }
            }
          }

          // crypto ipsec profile * / set transform-set
          leaf transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:non-strict-leafref {
              path "../../../../../crypto/ipsec/transform-set/name";
            }
            type string {
              tailf:info "WORD;;Proposal tag";
            }
          }

          // crypto ipsec profile * / set pfs
          leaf pfs {
            tailf:info "Specify pfs settings";
            tailf:cli-full-command;
            type isakmp-pfs-type;
          }

          // crypto ipsec profile * / set identity
          leaf "identity" {
            tailf:info "Identity restriction.";
            type string {
              tailf:info "WORD;;Identity name";
            }
          }

          // crypto ipsec profile * / set mixed-mode
          leaf mixed-mode {
            tailf:info "Turn on IPSec mixed-mode";
            tailf:cli-full-command;
            type empty;
          }

          choice ike-profile {
            // crypto ipsec profile * / set isakmp-profile
            leaf isakmp-profile {
              tailf:info "Specify isakmp Profile";
              tailf:non-strict-leafref {
                path "../../../../../crypto/isakmp/profile/name";
              }
              type string {
                tailf:info "WORD;;Name the isakmp profile";
              }
            }
            // crypto ipsec profile * / set ikev2-profile
            leaf ikev2-profile {
              tailf:info "Specify ikev2 Profile";
              tailf:non-strict-leafref {
                path "../../../../../crypto/ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;Profile name";
              }
            }
          }
        }

        // crypto ipsec profile * / responder-only
        leaf responder-only {
          tailf:info "Do not initiate SAs from this device";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // crypto call admission limit
    container call {
      tailf:info "Configure Crypto Call Admission Control";
      container admission {
        tailf:info "Configure Crypto Call Admission Control";
        container limit {
          tailf:info "Configure Crypto Call Admission Control limits";

          // crypto call admission limit ike
          container ike {
            tailf:info "Configure Crypto Call Admission Control active IKE SA limit";
            // crypto call admission limit ike in-negotiation-sa
            leaf in-negotiation-sa {
              tailf:info "Maximum number of in-negotiation IKE SAs allowed";
              type uint32 {
                tailf:info "<10-99999>;;maximum in-negotiation IKE SA limit";
                range "10..99999";
              }
            }
          }
        }
      }
    }

    // crypto gdoi
    container gdoi {
      tailf:info "Configure GDOI policy";

      // crypto gdoi group *
      list group {
        tailf:info "Define a GDOI group";
        tailf:cli-mode-name "config-gdoi-group";
        key name;
        leaf name {
          tailf:cli-disallow-value "ipv6";
          type string {
            tailf:info "WORD;;Group Name";
          }
        }
        leaf ipv6 {
          tailf:cli-prefix-key;
          type empty;
        }

        // crypto gdoi group * / identify
        container "identity" {
          tailf:info "Set the identity of the group";
          choice identify-choice {
            leaf number {
              tailf:info "Set the identity of the group as a number";
              type uint32 {
                tailf:info "<0-2147483647>;;Set the group number";
              }
            }
            container address {
              tailf:info "Set the identity of the group as an address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group IPv4 address";
                }
              }
            }
          }
        }

        // crypto gdoi group * / server
        container server {
          tailf:info "Set the group server for of the group";

          // crypto gdoi group * / server local
          container local {
            tailf:info "Identify a group server defined locally";
            tailf:cli-add-mode;
            tailf:cli-mode-name "gdoi-local-server";
            tailf:cli-delete-when-empty;
            presence true;
            must "not(../address/ipv4/name)" {
              error-message "Cannot Configure the key server as local.";
              tailf:dependency "../address/ipv4/name";
            }
            tailf:cli-diff-dependency "../address/ipv4/name" {
              tailf:cli-trigger-on-set;
            }

            // crypto gdoi group * / server local / rekey
            container rekey {
              tailf:info "Configure rekey policy for the group";

              // crypto gdoi group * / server local / rekey lifetime
              container lifetime {
                tailf:info "Define the rekey lifetime";
                choice lifetime-choice {
                  // crypto gdoi group * / server local / rekey lifetime seconds
                  leaf seconds {
                    tailf:info "Time-based key duration";
                    type uint32 {
                      tailf:info "<300-86400>;;Lifetime in seconds";
                    }
                    default 86400;
                  }
                  leaf days {
                    type uint32 {
                      tailf:info "Lifetime in days";
                    }
                  }
                  default seconds;
                }
              }

              // crypto gdoi group * / server local / rekey retransmit
              container retransmit {
                tailf:info "Define the rekey retransmission parameters";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf number-of-seconds {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<10-60>;;Retransmit after this many seconds";
                    range "10..60";
                  }
                }
                choice retransmit-choice {
                  leaf number {
                    tailf:info "Retransmit this many times";
                    type uint8 {
                      tailf:info "<1-10>;;Number of retransmissions";
                      range "1..10";
                    }
                  }
                  leaf periodic {
                    type empty;
                  }
                }
              }

              // crypto gdoi group * / server local / rekey authentication
              container authentication {
                tailf:info "Identify the rekey authentication keypair";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                choice authentication-choice {
                  leaf mypubkey {
                    tailf:info "Identify a keypair associated with this device";
                    type empty;
                  }
                  leaf pubkey {
                    type empty;
                  }
                }
                leaf rsa {
                  tailf:info "Identify an RSA keypair";
                  type string {
                    tailf:info "WORD;;Key name";
                  }
                }
              }

              // crypto gdoi group * / server local / rekey transport unicast
              container transport {
                tailf:info "Specify the rekey distribution method";
                leaf unicast {
                  tailf:info "specify unicast rekey distribution";
                  type empty;
                }
              }
            }

            // crypto gdoi group * / server local / replay
            container replay {
              container time {
                leaf window-size {
                  type uint32 {
                  }
                }
              }
            }

            // crypto gdoi group * / server local / sa
            container sa {
              tailf:info "Configure a security association";

              // crypto gdoi group * / server local / sa ipsec *
              list ipsec {
                tailf:info "Configure an IPsec SA";
                tailf:cli-mode-name "gdoi-sa-ipsec";
                key id;
                leaf id {
                  type uint32 {
                    tailf:info "<1-65535>;;Sequence to insert into SA list";
                    range "1..65535";
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / profile
                leaf profile {
                  tailf:info "Configure an ipsec profile for the SA";
                  tailf:non-strict-leafref {
                    path "../../../../../../../../crypto/ipsec/profile/name";
                  }
                  type string {
                    tailf:info "WORD;;Profile name";
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / match
                container match {
                  tailf:info "Match characteristics of packets to encrypt";
                  container address {
                    tailf:info "Match addresses of packets to encrypt";
                    choice address-choice {
                      leaf ipv4 {
                        tailf:info "Match ipv4 packets";
                        type ext-ip-acl-type;
                        //FIXME: dependency?
                      }
                      leaf ipv6 {
                        tailf:info "Match ipv6 packets";
                        tailf:non-strict-leafref {
                          path "../../../../../../../../../../ipv6/access-list/named-acl/name";
                        }
                        type string {
                          tailf:info "WORD;;IPv6 access list";
                        }
                      }
                    }
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / replay
                container replay {
                  tailf:info "Set replay method";
                  container counter {
                    tailf:info "Enable anti-replay check for single source "+
                      "traffic by using sequence number";
                    leaf window-size {
                      tailf:info "Set replay window size.";
                      type ipsec-window-size-type;
                    }
                  }
                }

                // crypto gdoi group * / server local / sa ipsec * / tag cts sgt
                container tag {
                  tailf:info "Set inline tagging method";
                  container cts {
                    tailf:info "Cisco Trust Security";
                    leaf sgt {
                      tailf:info "Security Group Tag";
                      type empty;
                    }
                  }
                }
              }
            }

            // crypto gdoi group * / server local / address ipv4
            container address {
              tailf:info "Configure server source address";
              leaf ipv4 {
                tailf:info "Set ipv4 address of local server";
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;IPv4 local address";
                  }
                  type string {
                    tailf:info "WORD;;Interface name";
                  }
                }
              }
            }

            // crypto gdoi group * / server local / redundancy
            container redundancy {
              tailf:info "Enter cooperative key server configuration mode";
              tailf:cli-add-mode;
              tailf:cli-mode-name "gdoi-coop-ks-config";
              tailf:cli-full-command;
              // crypto gdoi group * / server local / redundancy local
              container local {
                tailf:info "Local key server configurations";
                tailf:cli-delete-when-empty;
                presence true;
                leaf priority {
                  tailf:info "Set local server priority";
                  type uint8 {
                    tailf:info "<1-255>;;Local server priority";
                  }
                }
              }
              // crypto gdoi group * / server local / redundancy peer
              container peer {
                tailf:info "Peer server configurations";
                container address {
                  tailf:info "Peer server address";
                  leaf ipv4 {
                    tailf:info "Set peer server ipv4 address";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Peer server ipv4 address";
                    }
                  }
                }
              }
            }
          }

          // crypto gdoi group * / server address ipv4
          container address {
            tailf:info "Identify the group server by address";
            list ipv4 {
              tailf:info "Set the IPv4 address of the group server";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              must "not(../../local)" {
                error-message "Key server is already configured as local";
                tailf:dependency "../../local";
              }
              tailf:cli-diff-dependency "../../local" {
                tailf:cli-trigger-on-set;
              }
              key name;
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group server IPv4 address";
                }
              }
            }
          }
        }

        // crypto gdoi group * / client registration interface
        container client {
          tailf:info "Set the group client management/register interface";
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Set the group client management/register interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }

    // crypto dynamic-map *
    list dynamic-map {
      tailf:info "Specify a dynamic crypto map template";
      tailf:cli-mode-name "config-crypto-map";
      key "name map-entry";
      leaf name {
        type string {
          tailf:info "WORD;;Dynamic crypto map template tag";
        }
      }
      leaf map-entry {
        type uint32 {
          tailf:info "<1-65535>;;Sequence to insert into dynamic-map entry";
        }
      }

      // crypto dynamic-map * / set
      container set {
        tailf:info "Set values for encryption/decryption";

        // crypto dynamic-map * / set isakmp-profile
        leaf isakmp-profile {
          tailf:info "Specify isakmp Profile";
          tailf:non-strict-leafref {
            path "../../../../crypto/isakmp/profile/name";
          }
          type string {
            tailf:info "WORD;;Name the isakmp profile";
          }
        }

        // crypto dynamic-map * / set  transform-set
        leaf-list transform-set {
          tailf:info "Specify list of transform sets in priority order";
          tailf:cli-replace-all;
          tailf:cli-flat-list-syntax;
          tailf:non-strict-leafref {
            path "../../../../crypto/ipsec/transform-set/name";
          }
          type string {
            tailf:info "WORD;;Proposal tag";
          }
        }
      }

      // crypto dynamic-map * / match address
      container match {
        tailf:info "Match values.";
        leaf address {
          tailf:info "Match address of packets to encrypt";
          type ext-acl-type;
        }
      }
    }


    // crypto map *
    list map {
      tailf:info "Enter a crypto map";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-disallow-value "ipv6";
        type string {
          tailf:info "WORD;;Crypto map tag";
        }
      }
      leaf ipv6 {
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }

      // crypto map * local-address
      container local-address {
        tailf:info "Interface to use for local address for this crypto map";
        tailf:cli-optional-in-sequence;
        uses interface-name-grouping;
      }

      // crypto map * gdoi fail-close
      container gdoi {
        tailf:info "Configure crypto map gdoi features";
        tailf:cli-optional-in-sequence;
        container fail-close {
          tailf:info "Configure crypto map on Fail Close mode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-crypto-map-fail-close";
          presence true;

          // crypto map * gdoi fail-close / match address
          container match {
            tailf:info "Match address of packets for fail-close";
            leaf address {
              tailf:info "Match address of packets for fail-close.";
              type ext-acl-type;
            }
          }

          // crypto map * gdoi fail-close / activate
          leaf activate {
            tailf:info "Activate the crypto map to work in fail-close mode";
            type empty;
          }
        }
      }

      // crypto map * *
      list seq-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name "config-crypto-map";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-65535>;;Sequence to insert into crypto map entry";
          }
        }

        // crypto map * * gdoi
        // crypto map * * ipsec-manual
        // crypto map * * ipsec-isakmp
        // crypto map * * ckm
        leaf policy {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          tailf:cli-no-value-on-delete;
          type enumeration {
            enum ipsec-isakmp {
              tailf:info "IPSEC w/ISAKMP";
            }
            enum ipsec-manual {
              tailf:info "IPSEC w/manual keying";
            }
            enum gdoi {
              tailf:info "GDOI";
            }
            enum ckm {
              tailf:info "configure kgs map";
            }
          }
        }

        // crypto map * * ipsec-isakmp dynamic
        leaf dynamic {
          tailf:info "Enable dynamic crypto map support";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          tailf:non-strict-leafref {
            path "../../../../crypto/dynamic-map/name";
          }
          type string {
            tailf:info "WORD;;Name of dynamic-map template";
          }
        }

        // crypto map * * ipsec-isakmp profile
        leaf profile {
          tailf:info "Enable crypto map as a crypto-profile";
          tailf:cli-hide-in-submode;
          tailf:cli-optional-in-sequence;
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          when "../policy = 'ipsec-isakmp'" {
            tailf:dependency "../policy";
          }
          tailf:non-strict-leafref {
            path "../../../../crypto/isakmp/profile/name";
          }
          type string {
            tailf:info "WORD;;Name for this crypto profile";
          }
        }

        // crypto map * * ipsec-isakmp / description
        leaf "description" {
          tailf:cli-break-sequence-commands;
          tailf:info "Description of the crypto map statement policy";
          tailf:cli-full-command;
          tailf:cli-preformatted;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;A Short description";
          }
        }

        // crypto map * * ipsec-isakmp / set
        // crypto map * * ipsec-manual / set
        // crypto map * * ckm / set
        container set {
          tailf:info "Set values for encryption/decryption";
          when "../policy != 'gdoi'" {
            tailf:dependency "../policy";
          }

          // crypto map * ipsec-isakmp / set transform-set *
          leaf-list transform-set {
            tailf:info "Specify list of transform sets in priority order";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-full-command;
            tailf:non-strict-leafref {
              path "../../../../../crypto/ipsec/transform-set/name";
            }
            max-elements 6;
            type string {
              tailf:info "WORD;; Proposal tag";
            }
          }

          // crypto map * ipsec-isakmp / set isakmp-profile
          leaf isakmp-profile {
            tailf:info "Specify isakmp Profile";
            tailf:non-strict-leafref {
              path "../../../../../crypto/isakmp/profile/name";
            }
            type string {
              tailf:info "WORD;;Name the isakmp profile";
            }
          }

          // crypto map * ipsec-isakmp / set peer *
          leaf-list peer {
            tailf:info "Allowed Encryption/Decryption peer";
            tailf:cli-list-syntax;
            type inet:host {
              tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Address of peer";
            }
          }

          // crypto map * ipsec-isakmp / set security-association
          container security-association  {
            tailf:info "Security association parameters";

            // crypto map * ipsec-isakmp / set security-association level per-host
            container level {
              tailf:info "specify a security association granularity level for identities";
              leaf per-host {
                tailf:info "granularity to host level";
                type empty;
              }
            }

            // crypto map * ipsec-isakmp / set security-association dfbit
            leaf dfbit {
              tailf:info "Handling of encapsulated DF bit.";
              tailf:cli-full-command;
              type enumeration {
                enum clear {
                  tailf:info "Clear DF bit for encapsulated packets.";
                }
                enum copy {
                  tailf:info "Copy DF bit from inner for encapsulated packets.";
                }
                enum set {
                  tailf:info "Set DF bit for encapsulated packets.";
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association lifetime
            container lifetime {
              tailf:info "security association lifetime";
              leaf kilobytes {
                tailf:info "Volume-based key duration";
                type union {
                  type uint32 {
                    tailf:info "<2560-4294967295>;;Security association "+
                      "duration in kilobytes encrypted";
                    range "2560..4294967295";
                  }
                  type enumeration {
                    enum disable {
                      tailf:info "Disable Volume-based Rekey";
                    }
                  }
                }
              }
              choice days-seconds-choice {
                leaf days {
                  tailf:info "Time-based key duration in days";
                  type uint8 {
                    tailf:info "<1-30>;;Security association duration in days";
                    range "1..30";
                  }
                }
                leaf seconds {
                  tailf:info "Time-based key duration in seconds";
                  type uint32 {
                    tailf:info "<120-2592000>;;Security association duration in seconds";
                    range "120..2592000";
                  }
                  default 3600;
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association idle-time
            container idle-time {
              tailf:info "Automatically delete IPSec SAs after a given idle period.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf seconds {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<60-86400>;;Idle time at which IPSec SAs are deleted";
                  range "60..86400";
                }
              }
              leaf "default" {
                tailf:info "All SAs idle-out reset to default peer";
                type empty;
              }
            }

            // crypto map * ipsec-isakmp / set security-association replay
            container replay {
              tailf:info "Set replay checking.";
              leaf disable {
                tailf:info "Disable replay checking";
                type empty;
              }
              leaf window-size {
                tailf:info "Set replay window size.";
                type enumeration {
                  enum "1024";
                  enum "512";
                  enum "256";
                  enum "128";
                  enum "64";
                }
                default "64";
              }
            }

            // crypto map * ipsec-isakmp / set security-association dummy
            container dummy {
              tailf:info "Enable transmitting dummy packets";
              choice dummy-choice {
                leaf pps {
                  tailf:info "Simulated traffic rate (in pps)";
                  type uint8 {
                    tailf:info "<0-25>;;Rate of simulated traffic (in PPS)";
                    range "0..25";
                  }
                }
                leaf seconds {
                  tailf:info "Simulated traffic rate (in seconds)";
                  type uint16 {
                    tailf:info "<1-3600>;;Rate of simulated traffic "+
                      "(seconds between packets)";
                    range "1..3600";
                  }
                }
              }
            }

            // crypto map * ipsec-isakmp / set security-association ecn
            leaf ecn {
              tailf:info "Handling of ECN bit";
              tailf:cli-full-command;
              type enumeration {
                enum discard {
                  tailf:info "Discard the Explicit Congestion Notification bits on decryption";
                }
                enum propagate {
                  tailf:info "Propagate the Explicit Congestion Notification bits on decryption (RFC4301)";
                }
              }
            }
          }

          // crypto map * ipsec-isakmp / set pfs
          leaf pfs {
            tailf:info "Specify pfs settings";
            tailf:cli-full-command;
            type isakmp-pfs-type;
          }

          // crypto map * * gdoi / set reverse-route
          container reverse-route {
            tailf:info "Reverse Route Injection.";

            // crypto map * * gdoi / set reverse-route tag distance
            leaf distance {
              tailf:info "Distance metric for this static route";
              type uint8 {
                tailf:info "<1-255>;;Routing distance";
                range "1..255";
              }
              default 1;
            }

            // crypto map * * gdoi / set reverse-route tag
            leaf tag {
              tailf:info "Create route and tag it";
              type uint32 {
                tailf:info "<1-4294967295>;;Routing Tag ID";
                range "1..4294967295";
              }
            }
          }

          // crypto map * * gdoi / set group
          leaf group {
            tailf:info "Set the san group parameters";
            tailf:non-strict-leafref {
              path "../../../../gkm/group/name";
            }
            type string {
              tailf:info "WORD;;Set GDOI san group name";
            }
          }
        }

        // crypto map * * gdoi / set
        container gdoi-set {
          tailf:cli-break-sequence-commands;
          tailf:cli-drop-node-name;
          when "../policy = 'gdoi'" {
            tailf:dependency "../policy";
          }
          container set {
            tailf:info "Set values for encryption/decryption";
            leaf group {
              tailf:info "Set the secure group parameters";
              tailf:non-strict-leafref {
                path "../../../../../../crypto/gdoi/group/name";
              }
              type string {
                tailf:info "WORD;;Set the group name";
              }
            }
          }
        }

        // crypto map * * gdoi / match
        container match {
          tailf:info "Match values.";
          leaf address {
            tailf:info "Match address of packets to encrypt";
            type ext-ip-acl-type;
          }
        }

        // crypto map * * ipsec-isakmp / reverse-route
        container reverse-route {
          tailf:info "Reverse Route Injection";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf remote-peer {
            tailf:info "Create route in route table for remote tunnel endpoint";
            tailf:cli-optional-in-sequence;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address overrides remote tunnel endpoint";
            }
          }
          leaf gateway {
            tailf:info "Force encrypted traffic via this preferred gateway";
            tailf:cli-optional-in-sequence;
            when "../remote-peer" {
              tailf:dependency "../remote-peer";
            }
            type empty;
          }
          leaf static {
            tailf:info "Create routes based on static ACLs permanently";
            type empty;
          }
        }

        // crypto map * * ipsec-isakmp / qos pre-classify
        container qos {
          tailf:info "Quality of Service related commands";
          leaf pre-classify {
            tailf:info "Enable QOS classification before packets are tunnel encapsulated";
            type empty;
          }
        }
      }
    }

    // crypto gkm
    container gkm {
      tailf:info "Configure GKM (Group Key Management, GDOI or G-IKEv2) Policy";

      // crypto gkm group *
      list group {
        tailf:info "Configure a GKM (Group Key Management, GDOI or G-IKEv2) Group";
        tailf:cli-mode-name "config-gkm-group";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Group Name";
          }
        }

        // crypto gkm group * / identify
        container "identity" {
          tailf:info "Set the identity of the group";
          choice identity-choice {
            // crypto gkm group * / identify number
            leaf number {
              tailf:info "Set the identity of the group as a number";
              type uint32 {
                tailf:info "<0-4294967295>;;Set the group number";
              }
            }
            // crypto gkm group * / identify address ipv4
            container address {
              tailf:info "Set the identity of the group as an address";
              leaf ipv4 {
                tailf:info "Set the identity of the group as an IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group IPv4 address";
                }
              }
            }
          }
        }

        // crypto gkm group * / server
        container server {
          tailf:info "Set the group server for of the group";

          // crypto gkm group * / server address *
          list address {
            tailf:info "Identify the group server by address";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-show-long-obu-diffs;
            ordered-by user;
            key "protocol address";
            leaf protocol {
              type enumeration {
                enum ipv4 {
                  tailf:info "Set the IPv4 address of the group server";
                }
                enum ipv6 {
                  tailf:info "Set the IPv6 address of the group server";
                }
              }
            }
            leaf address {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;Group server IPv4 address";
                }
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;Group server IPv6 address";
                }
              }
            }
          }
        }

        // crypto gkm group * / client
        container client {
          tailf:info "Set the group client parameters";

          // crypto gkm group * / client protocol
          container protocol {
            tailf:info "Group Member Registration & Rekey Protocol";
            leaf gikev2 {
              tailf:info "Use G-IKEv2 Protocol for Registration & Rekey";
              tailf:non-strict-leafref {
                path "../../../../../ikev2/profile/name";
              }
              type string {
                tailf:info "WORD;;IKEv2 Profile Name for G-IKEv2 Registration";
              }
            }
          }

          // crypto gkm group * / client registration interface
          container registration {
            tailf:info "Set the group client management/register interface";
            container interface {
              tailf:info "Set the group client management/register interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }

    // crypto ssl
    container ssl {
      tailf:info "Configure Crypto SSL Options";

      // crypto ssl proposal *
      list proposal {
        tailf:info "Define ssl Proposal";
        tailf:cli-mode-name "config-crypto-ssl-proposal";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl Proposal";
          }
        }

        // crypto ssl proposal * / protection
        leaf-list protection {
          tailf:info "Specify the protection algorithms";
          tailf:cli-flat-list-syntax;
          type enumeration {
            enum rsa-3des-ede-sha1 {
              tailf:info "RSA, 3DES and SHA1";
            }
            enum rsa-rc4128-md5 {
              tailf:info "RSA, RC4 and MD5";
            }
            enum rsa-aes128-sha1 {
              tailf:info "RSA, AES128 and SHA1";
            }
            enum rsa-aes256-sha1 {
              tailf:info "RSA, AES256 and SHA1";
            }
          }
        }
      }

      // crypto ssl authorization policy *
      container authorization {
        tailf:info "ssl authorization";
        list policy {
          tailf:info "Crypto SSL authorization policy";
          tailf:cli-mode-name "config-crypto-ssl-auth-policy";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }

          // crypto ssl authorization policy * / pool
          leaf pool {
            tailf:info "Specify pool";
            type string {
              tailf:info "WORD;;pool";  // ip local pool mypool
            }
          }

          // crypto ssl authorization policy * / dns
          container dns {
            tailf:info "Specify DNS Addresses";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf primary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Primary DNS IP address";
              }
            }
            leaf secondary-server {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Secondary DNS IP address";
              }
            }
          }

          // crypto ssl authorization policy * / banner
          leaf banner {
            tailf:info "Specify banner";
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;banner string";
            }
          }

          // crypto ssl authorization policy * / def-domain
          leaf def-domain {
            tailf:info "Specify def_domain";
            type string {
              tailf:info "WORD;;def_domain string";
            }
          }
        }
      }

      // crypto ssl policy *
      list policy {
        tailf:info "Define SSL policies";
        tailf:cli-mode-name "config-crypto-ssl-policy";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl policy";
          }
        }

        // crypto ssl policy * / ssl proposal
        container ssl {
          tailf:info "Specify ssl proposal";
          leaf proposal {
            tailf:info "Specify Proposal";
            type string {
              tailf:info "WORD;;Specify the name of proposal to be attached";
            }
          }
        }

        // crypto ssl policy * / pki
        container pki {
          tailf:info "Trustpoint options";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf trustpoint {
            tailf:info "Certificate Trustpoint to authenticate clients";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;Trustpoint name";
            }
          }
          leaf sign {
            tailf:info "Sign";
            type empty;
          }
        }

        // crypto ssl policy * / ip address
        container ip {
          tailf:info "ip options";
          container address {
            tailf:info "ip address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf local {
              tailf:info "ip address local";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf port {
              tailf:info "port configuration";
              type union {
                type uint16 {
                  tailf:info "443;;Default secure port";
                  range "443";
                }
                type uint16 {
                  tailf:info "<1025-65535>;;Port number";
                  range "1025..65535";
                }
              }
            }
          }
        }

        // crypto ssl policy * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }

      // crypto ssl profile *
      list profile {
        tailf:info "Define ssl Profiles";
        tailf:cli-mode-name "config-crypto-ssl-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of ssl profile";
          }
        }

        // crypto ssl profile * / match
        container match {
          tailf:info "Specify the type to match";

          // crypto ssl profile * / match policy
          leaf policy {
            tailf:info "Specify Policy";
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../crypto/ssl/policy/name";
            }
            type string {
              tailf:info "WORD;;Specify the name of policy to be attached";
            }
          }

          // crypto ssl profile * / match url
          leaf url {
            tailf:info "Specify url";
            type string {
              tailf:info "WORD;;gateway[:port]/domain "+
                "(specify port if not 443)";
            }
          }
        }

        // crypto ssl profile * / aaa
        container aaa {
          tailf:info "aaa";

          // crypto ssl profile * / aaa authentication
          container authentication {
            tailf:info "aaa authentication";
            leaf "list" {
              tailf:info "aaa authentication list";
              type string {
                tailf:info "WORD;;Specify the list name";
              }
            }
          }

          // crypto ssl profile * / aaa authorization
          container authorization {
            tailf:info "aaa authorization";
            container user {
              tailf:info "AAA user authorization";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf "list" {
                tailf:info "AAA method list";
                type string {
                  tailf:info "WORD;;AAA list name";
                }
              }
              leaf aaa-username {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;AAA username";
                }
              }
            }
          }
        }

        // crypto ssl profile * / authentication remote user-credentials
        container authentication {
          tailf:info "Specify authentication mode";
          container remote {
            tailf:info "remote server";
            leaf user-credentials {
              tailf:info "User credential mode";
              type empty;
            }
          }
        }

        // crypto ssl profile * / shutdown
        leaf shutdown {
          tailf:info "shutdown";
          type empty;
        }
      }
    }

    // crypto tls-tunnel *
    list tls-tunnel {
      tailf:info "Configure Crypto TLS-Tunnel Options";
      tailf:cli-mode-name "config-crypto-tls-tunnel";
      tailf:cli-run-template-enter 'crypto tls-tunnel $(name)\n ! meta-data :: $(.ipath) :: shutdown-container-before-change :: tls-tunnel\n';
      tailf:cli-exit-command "! exit-meta-data-tls-tunnel";
      tailf:ned-data "." {
        tailf:transaction to;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of TLS-Tunnel";
        }
      }

      // crypto tls-tunnel * / server *
      list server {
        tailf:info "Specify the Server Address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        max-elements 2;
        key "protocol address";
        leaf protocol {
          type enumeration {
            enum ipv4 {
              tailf:info "IPv4 address";
            }
            enum ipv6 {
              tailf:info "IPv6 address";
            }
          }
        }
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 Address";
            }
          }
        }
        leaf port {
          tailf:info "Port Configuration";
          type union {
            type uint16 {
              tailf:info "Default Secure Port";
              range "443";
            }
            type uint16 {
              tailf:info "<1025-65535>;;Port Number";
              range "1025..65535";
            }
          }
        }
      }

      // crypto tls-tunnel * / protection
      leaf protection {
        tailf:info "Cipher-Suite";
        tailf:cli-full-command;
        type enumeration {
          enum dhe-psk-aes128-cbc-sha1 {
            tailf:info "DHE, PSK, AES128-CBC and SHA1";
          }
          enum dhe-psk-aes256-cbc-sha1 {
            tailf:info "DHE, PSK, AES256-CBC and SHA1";
          }
          enum psk-aes128-cbc-sha1 {
            tailf:info "PSK, AES128-CBC and SHA1";
          }
          enum psk-aes256-cbc-sha1 {
            tailf:info "PSK, AES256-CBC and SHA1";
          }
        }
        default dhe-psk-aes256-cbc-sha1;
      }

      // crypto tls-tunnel * / local-interface *
      list local-interface {
        tailf:info "Specify the WAN interfaces";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:info "Specify the Interface Priority (1 is highest)";
          type uint8 {
            tailf:info "<1-3>;;rank";
            range "1..3";
          }
        }
      }

      // crypto tls-tunnel * / psk id key
      container psk {
        tailf:info "Specify the Pre-Shared Key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf id {
          tailf:info "Key Identity";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;identity";
          }
        }
        container "key" {
          tailf:info "Specify the Key";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses crypto-key-grouping;
        }
      }

      // crypto tls-tunnel * / overlay-address
      container overlay-address {
        tailf:info "Specify the Overlay Address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 Address";
            }
          }
        }
        leaf vrf {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF";
          }
        }
      }

      // crypto tls-tunnel * / shutdown
      leaf shutdown {
        tailf:info "Shutdown the TLS-Tunnel";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// transport-map
  /// ========================================================================

  container transport-map {
    tailf:info "Configure transport map";
    container "type" {
      tailf:info "Specify transport map type";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;

      // transport-map type persistent *
      list persistent {
        tailf:info "Persistent transport types";
        tailf:cli-mode-name "config-tmap";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Transport map name";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum ssh {
              tailf:info "Persistent ssh transport type";
            }
            enum telnet {
              tailf:info "Persistent telnet transport type";
            }
            enum webui {
              tailf:info "Persistent webui transport type";
            }
          }
        }

        // transport-map type persistent * / authentication-retries
        leaf authentication-retries {
          tailf:info "Specify number of authentication retries";
          type uint8 {
            tailf:info "<0-5>;;Number of authentication retries";
            range "0..5";
          }
        }

        // transport-map type persistent * / rsa keypair-name
        container rsa {
          tailf:info "Configure RSA key-pair";
          leaf keypair-name {
            tailf:info "Configure RSA key-pair";
            type string {
              tailf:info "WORD;;RSA key-pair name";
            }
          }
        }

        // transport-map type persistent * / transport
        container transport {
          tailf:info "Configure interface(s) for the transport";
          container interface {
            tailf:info "Configure interface(s) for the transport";
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// macro
  /// ========================================================================

  container macro {
    tailf:info "Create a command macro";

    // no macro auto monitor
    container auto {
      leaf monitor {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // macro name *
    list name {
      tailf:info "Name of the macro";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of the macro to apply";
        }
      }
      leaf commands {
        tailf:cli-drop-node-name;
        tailf:cli-no-value-on-delete;
        type string {
          tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
            "End delimeter @ is added automatically.";
        }
      }
    }
  }


  /// ========================================================================
  /// buffers
  /// ========================================================================

  container buffers {
    tailf:info "Adjust system buffer pool parameters";
    container huge {
      tailf:info "Huge buffers";

      // buffers huge size
      leaf "size" {
        tailf:info "Size of huge buffers";
        type uint32 {
          tailf:info "<18024-65535>;;Size of huge buffers";
          range "18024..65535";
        }
      }
    }
  }


  /// ========================================================================
  /// track
  /// ========================================================================

  container track {
    tailf:info "Object tracking configuration commands";

    // track *
    list track-object {
      tailf:cli-drop-node-name;
      tailf:cli-mode-name "config-track";
      tailf:cli-compact-syntax;
      tailf:cli-diff-dependency "../../ip/vrf";
      tailf:cli-diff-dependency "../../vrf/definition";
      key object-number;
      leaf object-number {
        type uint16 {
          tailf:info "<1-1000>;;Tracked object";
          range "1..1000";
        }
      }

      choice track-type {
        // track * rtr
        container rtr {
          tailf:info "Response Time Reporter (RTR) entr";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf operation-number {
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-2147483647>;;Entry number";
              range "1..2147483647";
            }
          }
          leaf option {
            tailf:cli-drop-node-name;
            type enumeration {
              enum reachability {
                tailf:info "Reachability";
              }
              enum state {
                tailf:info "Return code state";
              }
            }
          }
        }

        // track * list boolean
        container "list" {
          tailf:info "Group objects in a list";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          leaf boolean {
            tailf:info "List state based on a boolean calculation on objects";
            type enumeration {
              enum and {
                tailf:info "Boolean AND operation on list";
              }
              enum or {
                tailf:info "Boolean OR operation on list";
              }
            }
          }
        }

        // track * interface
        container interface {
          tailf:info "Select an interface to track";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses interface-name-grouping;
          container ip {
            tailf:info "IP parameters";
            tailf:cli-flatten-container;
            tailf:cli-optional-in-sequence;
            leaf routing {
              tailf:info "Track interface IP routing capability";
              type empty;
            }
          }
          leaf line-protocol {
            tailf:info "Track interface line-protocol";
            tailf:cli-full-command;
            type empty;
          }
        }

        // track * ip
        container ip {
          tailf:info "IP protocol";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;

          // track * ip route
          container route {
            tailf:info "IP route";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf "prefix" {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Prefix";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;mask";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Route reachability state";
                type empty;
              }
              container metric {
                tailf:info "Route metric";
                tailf:cli-flatten-container;
                leaf threshold {
                  tailf:info "Route metric threshold";
                  type empty;
                }
              }
            }
          }

          // track * ip sla
          container sla {
            tailf:info "IP Service Level Agreement";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf operation-number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Entry number";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Reachability";
                type empty;
              }
              leaf state {
                tailf:info "Return code state";
                type empty;
              }
              default state;
            }
          }
        }

        // track * ipv6
        container ipv6 {
          tailf:info "IPv6 protocol";
          tailf:cli-hide-in-submode;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;

          // track * ipv6 route
          container route {
            tailf:info "IPv6 route";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf "prefix" {
              tailf:cli-drop-node-name;
              type ipv6-prefix {
                tailf:info "X:X:X:X::X/<0-128>;;IPv6 prefix";
              }
            }
            choice option-choice {
              leaf reachability {
                tailf:info "Route reachability state";
                type empty;
              }
              container metric {
                tailf:info "Route metric";
                tailf:cli-flatten-container;
                leaf threshold {
                  tailf:info "Route metric threshold";
                  type empty;
                }
              }
            }
          }
        }
      }

      // track * / object *
      list object {
        tailf:info "Add a tracked object to list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        when "../list/boolean" {
          tailf:dependency "../list/boolean";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-1000>;;Tracked object number";
            range "1..1000";
          }
        }
        leaf not {
          tailf:info "Negate the state of object";
          type empty;
        }
      }

      // track * / ip vrf
      container ip-vrf {
        tailf:cli-drop-node-name;
        when "../ip" {
          tailf:dependency "../ip";
        }
        container ip {
          tailf:info "Tracking IP configuration subcommands";
          leaf vrf {
            tailf:info "Configure VPN Routing/Forwarding table";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
      }

      // track * / ipv6 vrf
      container ipv6-vrf {
        tailf:cli-drop-node-name;
        when "../ipv6" {
          tailf:dependency "../ipv6";
        }
        container ipv6 {
          tailf:info "Tracking IP configuration subcommands";
          leaf vrf {
            tailf:info "Configure VPN Routing/Forwarding table";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
        }
      }

      // track * / delay
      container delay {
        tailf:info "Tracking delay";
        tailf:cli-compact-syntax;
        leaf down {
          tailf:info "Delay down change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
        leaf up {
          tailf:info "Delay up change notification";
          type uint8 {
            tailf:info "<0-180>;;Seconds to delay";
            range "0..180";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// csdb
  /// ========================================================================

  container csdb {
    tailf:info "Common Session Database";

    // csdb tcp
    container tcp {
      tailf:info "CSDB TCP protocol";

      // csdb tcp finwait-time
      leaf finwait-time {
        tailf:info "CSDB TCP protocol: FIN/RST timeout";
        type uint8 {
          tailf:info "<1-50>;;fin/rst timeout value (sec), default 5 sec";
          range "1..50";
        }
        default 5;
      }

      // csdb tcp idle-time
      leaf idle-time {
        tailf:info "CSDB TCP protocol: idle timeout";
        type uint16 {
          tailf:info "<1-36000>;;idle timeout value (sec), default 3600 sec";
          range "1..36000";
        }
        default 3600;
      }

      // csdb tcp reassembly
      container reassembly {
        tailf:info "CSDB Out-of-Order Module";
        leaf max-memory {
          tailf:info "CSDB Out-of-Order: Queue Memory";
          type uint32 {
            tailf:info "<1-102400>;;OoO memory (KB), default 1024 KB";
            range "1..102400";
          }
          default 1024;
        }
        leaf max-queue-length {
          tailf:info "CSDB Out-of-Order: Queue Length";
          type uint8 {
            tailf:info "<0-128>;;OoO queue length, default 16 packets, "+
              "O means disable OoO";
            range "0..128";
          }
          default 16;
        }
      }

      // csdb tcp synwait-time
      leaf synwait-time {
        tailf:info "CSDB TCP protocol: 3-way handshake timeout";
        type uint16 {
          tailf:info "<0-300>;;syn timeout value (sec), default 30 sec";
          range "0..300";
        }
        default 30;
      }
    }

    // csdb udp idle-time
    container udp {
      tailf:info "CSDB UDP protocol";
      leaf idle-time {
        tailf:info "CSDB UDP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 30 sec";
          range "1..1200";
        }
        default 30;
      }
    }

    // csdb icmp idle-time
    container icmp {
      tailf:info "CSDB ICMP protocol";
      leaf idle-time {
        tailf:info "CSDB ICMP Protocol: idle time";
        type uint16 {
          tailf:info "<1-1200>;;idle timeout value (sec), default 10 sec";
          range "1..1200";
        }
        default 10;
      }
    }

    // csdb session max-session
    container session {
      tailf:info "CSDB Session Management";
      leaf max-session {
        tailf:info "CSDB Session: maximum session";
        type uint32 {
          tailf:info "<1-655350>;;session, default 65535";
          range "1..655350";
        }
        default 65535;
      }
    }
  }


  /// ========================================================================
  /// ethernet
  /// ========================================================================

  container ethernet {
    tailf:info "Ethernet configuration";

    // ethernet lmi
    container lmi {
      tailf:info "Local Management Interface";

      // ethernet lmi global
      leaf global {
        tailf:info "Ethernet LMI is enabled on all supported Interfaces";
        type empty;
      }

      // ethernet lmi ce
      leaf ce {
        tailf:info "Ethernet LMI Customer Edge";
        type empty;
      }
    }

    // ethernet evc *
    list evc {
      tailf:info "define an Ethernet virtual connection (EVC)";
      tailf:cli-mode-name "config-evc";
      tailf:cli-compact-syntax;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;EVC identifier of length <1-100>";
          length "1..100";
        }
      }

      // ethernet evc * / oam protocol
      container oam {
        tailf:info "OAM Protocol";
        container protocol {
          tailf:info "Protocol for EVC status reporting";
          choice protocol-choice {

            // ethernet evc * / oam protocol ldp
            leaf ldp {
              tailf:info "Protocol LDP";
              type empty;
            }

            // ethernet evc * / oam protocol cfm domain
            container cfm {
              tailf:info "Protocol CFM";
              leaf domain {
                tailf:info "Protocol CFM Domain";
                type string {
                  tailf:info "WORD;;domain name";
                }
              }
            }
          }
        }
      }
    }

    // ethernet cfm
    container cfm {
      tailf:info "Connectivity Fault Management";
      tailf:cli-diff-dependency "../evc";

      // ethernet cfm enable
      leaf enable {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm ieee
      leaf ieee {
        tailf:info "CFM IEEE enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm global
      leaf global {
        tailf:info "CFM global enable";
        tailf:cli-full-command;
        type empty;
      }

      // ethernet cfm logging
      container logging {
        tailf:info "Enable CFM syslog messages";
        presence true;
      }

      // ethernet cfm traceroute cache
      container traceroute {
        tailf:info "CFM Traceroute";
        container cache {
          tailf:info "CFM Traceroute Cache";
          tailf:cli-display-separated;
          presence true;

          // ethernet cfm traceroute cache size
          leaf size {
            tailf:info "Cache size";
            type uint16 {
              tailf:info "<1-4095>;;Number of cached lines (default 100)";
              range "1..4095";
            }
            default 100;
          }

          // ethernet cfm traceroute cache hold-time
          leaf hold-time {
            tailf:info "Hold Time";
            type uint16 {
              tailf:info "<1-65535>;;minutes (default 100)";
              range "1..65535";
            }
            default 100;
          }
        }
      }

      // ethernet cfm mip auto-create *
      container mip {
        tailf:info "CFM MIP commands";

        // ethernet cfm mip auto-create level ? evc *
        list auto-create {
          tailf:info "CFM MIP auto creation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          key evc;
          leaf evc {
            tailf:info "auto create for CFM over EVC";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          leaf level {
            tailf:info "Maintenance Level";
            tailf:cli-prefix-key;
            type uint8 {
              tailf:info "<0-7>;;maintenance level number";
              range "0..7";
            }
          }
        }
      }

      // ethernet cfm domain *
      list domain {
        tailf:info "Configure a domain";
        tailf:cli-mode-name "config-ecfm";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-diff-dependency "../ieee";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;maintenance domain name";
          }
        }
        // ethernet cfm domain * level
        leaf level {
          tailf:info "Maintenance Level";
          tailf:cli-hide-in-submode;
          type uint8 {
            tailf:info "<0-7>;;maintenance level number";
          }
        }

        // ethernet cfm domain * level / mip autocreate
        container mip {
          tailf:info "MIP commands for Domain";
          container auto-create {
            tailf:info "Enable auto MIP creation at Domain Level";
            tailf:cli-delete-when-empty;
            presence true;
            leaf lower-mep-only {
              tailf:info "Only for lower MEPs";
              type empty;
            }
          }
        }

        // ethernet cfm domain * level / mep archive-hold-time
        container mep {
          tailf:info "Maintenance End Point commands";
          leaf archive-hold-time {
            tailf:info "Time in minutes for entry to be retained";
            type uint16 {
              tailf:info "<1-65535>;;minutes (default 100)";
              range "1..65535";
            }
            default 100;
          }
        }

        // ethernet cfm domain * level / sender-id chassis
        leaf sender-id {
          tailf:info "Include Sender ID TLV";
          tailf:cli-full-command;
          type enumeration {
            enum chassis {
              tailf:info "Send Chassis ID";
            }
            enum none {
              tailf:info "Info not included in Sender Id";
            }
          }
        }

        // ethernet cfm domain * level / service *
        list service {
          tailf:info "Maintenance Association within Domain";
          tailf:cli-mode-name "config-ecfm-srv";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key csi-id;
          leaf csi-id {
            type string {
              tailf:info "WORD;;service instance id - short MA name";
            }
          }
          // ethernet cfm domain * level / service * port
          leaf port {
            tailf:info "DOWN service direction with no vlan association";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            tailf:cli-full-command;
            type empty;
          }
          // ethernet cfm domain * level / service * efc
          leaf evc {
            tailf:info "Specify EVC";
            tailf:cli-hide-in-submode;
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;EVC name";
            }
          }
          // ethernet cfm domain * level / service * efc vlan
          leaf vlan {
            tailf:info "Specify vlan (range 1-4094)";
            tailf:cli-hide-in-submode;
            type uint16 {
              tailf:info "<1-4094>;;between 1 and 4094";
              range "1..4094";
            }
          }
          // ethernet cfm domain * level / service * efc direction
          leaf direction {
            tailf:info "service direction";
            tailf:cli-hide-in-submode;
            tailf:cli-full-command;
            type enumeration {
              enum down {
                tailf:info "direction towards the LAN";
              }
            }
          }

          // ethernet cfm domain * level / service * / continuity-check
          container continuity-check {
            tailf:cli-break-sequence-commands;
            tailf:info "Enable Continuity Check for Maintenance Association";
            tailf:cli-display-separated;
            presence true;
            // ethernet cfm domain * level / service * /
            // .. continuity-check interval
            leaf interval {
              tailf:info "Interval Continuity Check messages transmitted";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;interval string";
              }
            }
          }

          // ethernet cfm domain * level / service * / sender-id
          leaf sender-id {
            tailf:info "Include Sender ID TLV";
            tailf:cli-full-command;
            type enumeration {
              enum chassis {
                tailf:info "Send Chassis ID";
              }
              enum none {
                tailf:info "Info not included in Sender Id";
              }
            }
          }

          // ethernet cfm domain * level / service * / ais
          container ais {
            tailf:info "AIS Maintenance Condition";
            // ethernet cfm domain * level / service * / ais period
            leaf period {
              tailf:info "AIS Transmission period";
              type enumeration {
                enum "1" {
                  tailf:info "Seconds";
                }
                enum "60" {
                  tailf:info "Seconds";
                }
              }
              default "60";
            }
            // ethernet cfm domain * level / service * / ais level
            leaf level {
              tailf:info "Maintenance Level to send AIS";
              type uint8 {
                tailf:info "<0-7>;;Maintenance Level";
                range "0..7";
              }
            }
          }

          // ethernet cfm domain * level / service * / efd notify g8032
          container efd {
            tailf:info "Ethernet Fault Detection";
            container notify {
              tailf:info "EFD Notification Registration";
              leaf g8032 {
                tailf:info "Notify G.8032 Controller of EFD events";
                type empty;
              }
            }
          }
        }
      }

      // ethernet cfm mep crosscheck start-delay
      container mep {
        tailf:info "Maintenance End Point";
        container crosscheck {
          tailf:info "Cross Check remote MEPs";
          leaf start-delay {
            tailf:info "Wait time before cross check starts";
            type uint16 {
              tailf:info "<1-65535>;;seconds (30 seconds default)";
            }
          }
        }
      }
    }

    // ethernet ring g8032
    container ring {
      tailf:info "Ring";
      container g8032 {
        tailf:info "Specify the g.8032 ethernet ring";

        // ethernet ring g8032 profile *
        list profile {
          tailf:info "g.8032 ring profile configuration";
          tailf:cli-mode-name "config-erp-profile";
          key profile-name;
          leaf profile-name {
            type string {
              tailf:info "WORD;;ERP profile name string";
            }
          }
          // ethernet ring g8032 profile * / timer
          container timer {
            tailf:info "g.8032 timer";
            // ethernet ring g8032 profile * / timer wtr
            leaf wtr {
              tailf:info "Wait-to-Restore time";
              type uint8 {
                tailf:info "<1-12>;;minutes";
                range "1..12";
              }
            }
            // ethernet ring g8032 profile * / timer guard
            leaf guard {
              tailf:info "Guard timer";
              type uint16 {
                tailf:info "<10-2000>;;milliseconds";
                range "10..2000";
              }
            }
          }
        }

        // ethernet ring g8032 *
        list g8032-list {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name "config-erp-ring";
          key ring-name;
          leaf ring-name {
            tailf:cli-disallow-value "profile";
            type string {
              tailf:info "WORD;;Name of the ethernet ring";
            }
          }

          // ethernet ring g8032 * / exclusion-list vlan-ids
          container exclusion-list {
            tailf:info "Specifiy exclusion list not protected by ERP";
            leaf-list vlan-ids {
              tailf:info "Assign list of VLANs to the exclusion list";
              tailf:cli-replace-all;
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "<1-4094>;;VLAN id";
                range "1..4094";
              }
            }
          }

          // ethernet ring g8032 * / port0 interface
          container port0 {
            tailf:info "Port0 of the local node connected to G.8032 ring";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-erp-ring-port";
            tailf:cli-incomplete-command;
            container interface {
              tailf:info "Assign port interface";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-hide-in-submode;
              uses interface-name-grouping;
            }

            // ethernet ring g8032 * / port0 interface / monitor service
            container monitor {
              tailf:info "Assign the Ethernet Service Instance to monitor "+
                "g.8032 ring port";
              container service {
                tailf:info "Specify an Ethernet Service Instance";
                leaf instance {
                  tailf:info "Specify an Ethernet Service Instance";
                  type uint16 {
                    tailf:info "Ethernet Service Instance ID";
                    range "1..8000";
                  }
                }
              }
            }
          }

          // ethernet ring g8032 * / port1
          choice port1-choice {
            // ethernet ring g8032 * / port1 interface
            container port1 {
              tailf:info "Port1 of the local node connected to G.8032 ring";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-ring-port";
              tailf:cli-incomplete-command;
              container interface {
                tailf:info "Assign port interface";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-hide-in-submode;
                uses interface-name-grouping;
              }

              // ethernet ring g8032 * / port1 interface / monitor service
              container monitor {
                tailf:info "Assign the Ethernet Service Instance to monitor "+
                  "g.8032 ring port";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
            }
            // ethernet ring g8032 * / port1 none
            container port1-none {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              container port1 {
                leaf none {
                  tailf:info "Assign port1 as none to enable g.8032 open-ring";
                  type empty;
                }
              }
            }
          }

          // ethernet ring g8032 * / instance *
          list instance {
            tailf:info "Configure the g.8032 ethernet ring instance";
            tailf:cli-mode-name "config-erp-inst";
            tailf:cli-full-command;
            key instance-id;
            leaf instance-id {
              type uint8 {
                tailf:info "<1-2>;;Instance number";
                range "1..2";
              }
            }

            // ethernet ring g8032 * / instance * / profile
            leaf profile {
              tailf:info "Specify associated g.8032 ethernet ring profile";
              type string {
                tailf:info "WORD;;Ethernet ring profile name";
              }
            }

            // ethernet ring g8032 * / instance * / rpl
            container rpl {
              tailf:info "Specify RPL owner, neighbor or next-neighbor";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf port {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum port0 {
                    tailf:info "Assign port0 as RPL owner, neighbor or "+
                    "next-neighbor";
                  }
                  enum port1 {
                    tailf:info "Assign port1 as RPL owner, neighbor or "+
                    "next-neighbor";
                  }
                }
              }
              leaf "type" {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum neighbor {
                    tailf:info "RPL neighbor";
                  }
                  enum next-neighbor {
                    tailf:info "RPL next neighbor";
                  }
                  enum owner {
                    tailf:info "RPL owner";
                  }
                }
              }
            }

            // ethernet ring g8032 * / instance * / inclusion-list
            container inclusion-list {
              tailf:info "Specify inclusion list protected by ERP";
              leaf-list vlan-ids {
                tailf:info "Associates a set of VLAN IDs with the current "+
                  "instance";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;List of VLAN IDs in the form a-b,c,d,e-f,g";
                  range "1..4094";
                }
              }
            }
            // ethernet ring g8032 * / instance * / aps-channel
            container aps-channel {
              tailf:info "Configure g.8032 instance aps-channel";
              tailf:cli-add-mode;
              tailf:cli-mode-name "config-erp-inst-aps";
              // ethernet ring g8032 * / instance * / aps-channel / port0
              container port0 {
                tailf:info "Configure g.8032 aps-channel info associated "+
                  "to port0";
                container service {
                  tailf:info "Specify an Ethernet Service Instance";
                  leaf instance {
                    tailf:info "Specify an Ethernet Service Instance";
                    type uint16 {
                      tailf:info "<1-8000>;;Ethernet Service Instance ID";
                      range "1..8000";
                    }
                  }
                }
              }
              // ethernet ring g8032 * / instance * / aps-channel / port1
              container port1 {
                tailf:info "Configure g.8032 aps-channel info associated "+
                  "to port1";
                choice port1-choice {
                  // ethernet ring g8032 * / instance * / aps-channel /
                  // .. port1 service
                  container service {
                    tailf:info "Specify an Ethernet Service Instance";
                    leaf instance {
                      tailf:info "Specify an Ethernet Service Instance";
                      type uint16 {
                        tailf:info "<1-8000>;;Ethernet Service Instance ID";
                        range "1..8000";
                      }
                    }
                  }
                  // ethernet ring g8032 * / instance * / aps-channel /
                  // .. port1 none
                  leaf none {
                    tailf:info "Specify port1 APS channel as none";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
    }

    // ethernet tcn-propagation *
    list tcn-propagation {
      tailf:info "Enable TCN propagation";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key "source to";
      leaf source {
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
      leaf to {
        tailf:info "propagate TCN to";
        tailf:cli-expose-key-name;
        type enumeration {
          enum g8032 {
            tailf:info "g.8032 ethernet ring";
          }
          enum rep {
            tailf:info "REP ethernet ring";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// performance
  /// ========================================================================

  container performance {
    tailf:info "Global Performance monitor configuration";

    // performance monitor context * profile
    container monitor {
      tailf:info "monitor";
      list context {
        tailf:info "Define ezPM context";
        tailf:cli-mode-name "config-perf-mon";
        tailf:cli-incomplete-command;
        tailf:cli-sequence-commands;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;ezPM context name";
          }
        }
        leaf profile {
          tailf:info "Select ezPM profile";
          tailf:cli-hide-in-submode;
          tailf:cli-full-command;
          type enumeration {
            enum application-experience {
              tailf:info "Application eXperience performance monitor profile";
            }
            enum application-performance {
              tailf:info "Application performance profile";
            }
            enum application-statistics {
              tailf:info "Application statistics profile";
            }
          }
        }

        // performance monitor context * profile / exporter destination *
        container exporter {
          tailf:cli-break-sequence-commands;
          tailf:info "Create exporter";
          list destination {
            tailf:info "Export destination configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "address source";
            leaf address {
              type inet:host {
                tailf:info "Hostname or A.B.C.D or X:X::X;;Destination address";
              }
            }
            leaf source {
              tailf:info "Originating interface";
              tailf:cli-expose-key-name;
              tailf:cli-diff-dependency "../../../../../../interface";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            // performance monitor context * profile / exporter destination * vrf
            leaf vrf {
              tailf:info "vrf";
              // note: not dependent on vrf to exist
              type string {
                tailf:info "WORD;;VRF label";
              }
            }
            // performance monitor context * profile / exporter destination * transport
            leaf transport {
              tailf:info "transport";
              type enumeration {
                enum udp {
                  tailf:info "UDP transport protocol";
                }
              }
            }
            // performance monitor context * profile / exporter destination * port
            leaf port {
              tailf:info "port";
              type uint16 {
                tailf:info "<1-65535>;;Optional port value";
                range "1..65535";
              }
            }
          }
        }

        // performance monitor context * profile / traffic-monitor
        container traffic-monitor {
          tailf:info "Select traffic monitor ";

          // performance monitor context * profile / traffic-monitor all
          container all {
            tailf:info "All traffic monitors in this profile";
            presence true;

            // performance monitor context * profile / traffic-monitor all ipv4
            leaf ipv4 {
              tailf:info "Activate monitor for ipv4 traffic";
              type empty;
            }
            // performance monitor context * profile / traffic-monitor all ipv6
            leaf ipv6 {
              tailf:info "Activate monitor for ipv6 traffic";
              type empty;
            }
          }

          // performance monitor context * profile / traffic-monitor url
          container url {
            tailf:info "URL information, application response time (ART) "+
              "metrics and counters";
            tailf:cli-compact-syntax;
            presence true;
            leaf ipv4 {
              tailf:info "Activate monitor for ipv4 traffic";
              type empty;
            }
            leaf class-replace {
              tailf:info "Replace traffic classification";
              type string {
                tailf:info "WORD;;User defined class name";
              }
            }
            leaf cache-size {
              tailf:info "Maximum flow entries in the Flow Cache";
              type uint32 {
                tailf:info "<64-1048576>;;Maximum number of entries";
                range "64..1048576";
              }
            }
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-client-server-stats
          container application-client-server-stats {
            tailf:info "Per interface, client, server and application statistics";
            presence true;
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-stats
          container application-stats {
            tailf:info "Per application and interface statistics";
            presence true;
          }

          // performance monitor context * profile /
          // .. traffic-monitor application-response-time
          container application-response-time {
            tailf:info "Application response time (ART) metrics and statistics for TCP traffic";
            presence true;
          }

          // performance monitor context * profile / traffic-monitor media
          container media {
            tailf:info "Media metrics and statistics for RTP traffic";
            presence true;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// l2
  /// ========================================================================

  container l2 {
    tailf:info "Layer 2 configuration";

    // l2 vfi *
    list vfi {
      tailf:info "Configure a virtual forwarding instance";
      tailf:cli-mode-name "config-vfi";
      tailf:cli-compact-syntax;
      //tailf:cli-recursive-delete;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../bridge-domain";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
      // l2 vfi * point-to-point
      leaf point-to-point {
        tailf:info "Point-to-point configuration mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      // l2 vfi * manual
      leaf manual {
        tailf:info "Multipoint manual configuration mode";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }
      // l2 vfi * autodiscovery
      leaf autodiscovery {
        tailf:info "Multipoint autodiscovery configuration mode";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf evc {
        when "../autodiscovery" {
          tailf:dependency "../autodiscovery";
        }
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;EVC name";
        }
      }

      // l2 vfi * / vpn id
      container vpn {
        tailf:info "VPN configuration";
        leaf id {
          tailf:info "VPN id";
          type uint32 {
            tailf:info "<1-4294967295>;;VPN id value";
            range "1..4294967295";
          }
        }
      }

      // l2 vfi * / bridge-domain
      leaf bridge-domain {
        tailf:info "Bridge Domain";
        type uint16 {
          tailf:info "<1-8000>;;Bridge Domain ID value";
          range "1..8000";
        }
      }

      // l2 vfi * / mtu
      leaf mtu {
        tailf:cli-full-command;
        type uint16 {
        }
      }

      // l2 vfi * / rd
      leaf rd {
        tailf:info "Specify Route Distinguisher";
        tailf:cli-remove-before-change;
        tailf:cli-full-command;
        type rd-type;
      }

      // l2 vfi * / route-target
      container route-target {
        tailf:info "Specify Target VPN Extended Communities";
        tailf:cli-diff-dependency "../rd";
        uses route-target-grouping;
      }

      // l2 vfi * / neighbor *
      list neighbor {
        tailf:info "VFI neighbor configuration";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;VFI neighbor's router id";
          }
        }

        // l2 vfi * / neighbor * / <vcid>
        leaf vcid {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Enter VC ID value";
            range "1..4294967295";
          }
        }

        // l2 vfi * / neighbor * / encapsulation
        leaf encapsulation {
          tailf:info "Connection encapsulation type";
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum mpls {
              tailf:info "Use MPLS encapsulation";
            }
            enum l2tpv3 {
              tailf:info "Use L2TPv3 encapsulation";
            }
          }
        }

        // l2 vfi * / neighbor * / pw-class
        leaf pw-class {
          tailf:info "Pseudowire-class configuration";
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../pseudowire-class/name";
          }
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }

        // l2 vfi * / neighbor * / no-split-horizon
        leaf no-split-horizon {
          tailf:info "Disable split-horizon forwarding";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// interface
  /// ========================================================================

  container interface {
    tailf:info "Configure interfaces";
    tailf:cli-explicit-exit;

    // interface Null0
    list Null {
      tailf:info "Null interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-0>;;Null interface number";
          range "0";
        }
      }

      // interface Null0 / ip
      container ip {
        tailf:info "Interface Internet Protocol config commands";
        // no ip unreachables
        leaf unreachables {
          tailf:info "Enable sending ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }

      // interface Null0 / ipv6
      container ipv6 {
        tailf:info "IPv6 interface subcommands";
        // no ipv6 unreachables
        leaf unreachables {
          tailf:info "Enable sending of ICMP Unreachable messages";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // interface Loopback *
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2147483647>;;Loopback interface number";
          pattern '([0-9\.])+';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface VirtualPortGroup
    list VirtualPortGroup {
      tailf:info "Virtual Port Group";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<0-31>;;VirtualPortGroup interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Dot11Radio*
    list Dot11Radio {
      tailf:info "IEEE 802.11 WLAN";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "LINE;;Dot11Radio interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;

      // interface Dot11Radio* / encryption
      container encryption {
        tailf:info "Configure dot11 encryption parameters";

        // interface Dot11Radio* / encryption mode
        uses interface-encryption-mode-grouping;

        // interface Dot11Radio* / encryption vlan *
        list vlan {
          tailf:info "vlan";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;vlan ID number or vlan nam";
            }
          }

          // interface Dot11Radio* / encryption vlan * mode
          uses interface-encryption-mode-grouping;
        }
      }

      // interface Dot11Radio* / broadcast-key
      container broadcast-key {
        tailf:info "Configure broadcast key rotation period";

        // interface Dot11Radio* / broadcast-key vlan *
        list vlan {
          tailf:info "vlan";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;vlan ID number or vlan name";
            }
          }
          leaf change {
            tailf:info "key rotation";
            type uint32 {
              tailf:info "<10-10000000>;;Key rotation period in seconds";
              range "10..10000000";
            }
          }
        }
      }

      // interface Dot11Radio* / ssid
      list ssid {
        tailf:info "Configure radio service set parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "LINE;;radio Service Set ID (Up to 32 character";
            length "1..32";
          }
        }
      }

      // interface Dot11Radio* / antenna
      container antenna {
        tailf:info "dot11 radio antenna setting";

        // interface Dot11Radio* / antenna gain
        leaf gain {
          tailf:info "Configure Resultant Antenna Gain";
          type int16 {
            tailf:info "<-128 - 128>;;Resultant Antenna Gain in dB";
            range "-128..128";
          }
        }
      }

      // interface Dot11Radio* / peakdetect
      leaf peakdetect {
        type empty;
      }

      // interface Dot11Radio* / mbssid
      leaf mbssid {
        tailf:info "enable mbssid";
        tailf:cli-full-command;
        type empty;
      }

      // interface Dot11Radio* / speed
      leaf speed {
        tailf:info "Set allowed radio bit rates";
        tailf:cli-multi-value;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;allowed radio bit rates";
        }
      }

      // interface Dot11Radio* / dfs band
      container dfs {
        tailf:info "Dynamic Frequency Selection commands";
        container band {
          tailf:info "Specify frequency bands";
          tailf:cli-incomplete-no;
          choice band-choice {

            // interface Dot11Radio* / no dfs band block
            leaf block {
              tailf:info "Block specified frequency bands from being "+
                "selected by DFS";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface Dot11Radio* / dfs band * block
            container block-conf {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf one {
                tailf:info "5.150 to 5.250 GHz";
                tailf:alt-name "1";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf two {
                tailf:info "5.250 to 5.350 GHz";
                tailf:alt-name "2";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf three {
                tailf:info "5.470 to 5.725 GHz";
                tailf:alt-name "3";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf four {
                tailf:info "5.725 to 5.825 GHz";
                tailf:alt-name "4";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf block {
                tailf:info "Block specified frequency bands from being "+
                  "selected by DFS";
                type empty;
              }
            }
          }
        }
      }

      // interface Dot11Radio* / packet
      container packet {
        tailf:info "IEEE 802.11 packet";

        // interface Dot11Radio* / packet retries
        leaf retries {
          tailf:info "maximum best-effort data packet retries";
          type uint8 {
            tailf:info "<1-128>;;number of packet retries before giving up";
            range "1..128";
          }
        }
      }

      // interface Dot11Radio* / channel
      container channel {
        tailf:info "Set the radio frequency";

        // interface Dot11Radio* / channel dfs
        leaf dfs {
          tailf:info "Use Dynamic Frequency Selection";
          type empty;
        }
      }

      // interface Dot11Radio* / channel least-congested
      container channel-conf {
        tailf:cli-drop-node-name;
        container channel {
          tailf:info "Set the radio frequency";
          tailf:cli-compact-syntax;
          leaf least-congested {
            tailf:info "Scan for best frequency";
            type empty;
          }
          leaf-list frequency {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            ordered-by user;
            type uint16 {
              tailf:info "NUM;;frequency";
            }
          }
        }
      }

      // interface Dot11Radio* / station-role root
      container station-role {
        tailf:info "role of the radio";
        container root {
          tailf:info "Root access point or bridge";
          presence true;
        }
      }

      // interface Dot11Radio* / rts
      container rts {
        tailf:info "dot11 Request To Send";

        // interface Dot11Radio* / rts threshold
        leaf threshold {
          tailf:info "RTS threshold";
          type uint16 {
            tailf:info "<0-2347>;;threshold in bytes";
            range "0..2347";
          }
        }

        // interface Dot11Radio* / rts retries
        leaf retries {
          tailf:info "RTS max retries";
          type uint8 {
            tailf:info "<1-128>;;max retries";
            range "1..128";
          }
        }
      }

      // interface Dot11Radio* / world-mode
      container world-mode {
        tailf:info "Dot11 radio world mode";

        // interface Dot11Radio* / world-mode dot11d
        container dot11d {
          tailf:info "802.11d World Mode advertise country";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf country-code {
            tailf:info "ISO /IEC 3166-1 country code";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;;two characters country code";
            }
          }
          leaf location {
            tailf:cli-drop-node-name;
            type enumeration {
              enum both {
                tailf:info "location indoor and outdoor";
              }
              enum indoor {
                tailf:info "location indoor";
              }
              enum outdoor {
                tailf:info "location outdoor";
              }
            }
          }
        }
      }

      // interface Dot11Radio* / infrastructure-client
      leaf infrastructure-client {
        tailf:info "Reserve a dot11 virtual interface for a WGB client";
        type empty;
      }
    }

    // interface Embedded-Service-Engine *
    list Embedded-Service-Engine {
      tailf:info "cisco embedded service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-2>/<0-0>;;Embedded-Service-Engine interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Service-Engine *
    list Service-Engine {
      tailf:info "Cisco service engine module";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Tunnel *
    list Tunnel {
      tailf:info "Tunnel interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;Tunnel interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Tunnel* / tunnel
      uses interface-tunnel-grouping;
    }

    // interface Port-channel*
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;

      // interface Port-channel* / mlacp
      container mlacp {
        tailf:info "mLACP Port Channel interface subcommands";
        container interchassis {
          tailf:info "mLACP Interchassis commands";
          leaf group {
            tailf:info "Interchassis Group";
            type uint32 {
              tailf:info "<1-4294967295>;;Group ID";
            }
          }
        }
      }

      // interface Port-channel* / port-channel
      container port-channel {
        tailf:info "Port Channel interface subcommands";

        // interface Port-channel* / port-channel load-balance
        container load-balance {
          tailf:info "Configure load-balancing for egress traffic";

          // interface Port-channel* / port-channel load-balance flow-based
          leaf flow-based {
            tailf:info "Flow based load-balancing on the port-channel";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../link" {
              tailf:cli-trigger-on-set;
            }
            tailf:cli-diff-dependency "../weighted" {
              tailf:cli-trigger-on-set;
            }
            //when "not(../link)" {
              //tailf:dependency "../link";
            //}
            type empty;
          }

          // interface Port-channel* / port-channel load-balance link
          leaf link {
            tailf:info "Manually configure a member link for load-balancing";
            tailf:cli-full-command;
            //when "not(../flow-based)";
            type uint8 {
              tailf:info "<1-16>;;The link ID of the member link to use for"
                + " egress load-balancing";
              range "1..16";
            }
          }

          // interface Port-channel* / port-channel load-balance weighted
          container weighted {
            tailf:info "Configure weighted load-balancing on the port-channel";
            //when "not(../flow-based)";

            // interface Port-channel* / port-channel load-balance weighted default
            container "default" {
              tailf:info "Configure default parameters";
              leaf weight {
                tailf:info "Modify the default weight";
                type uint16 {
                  tailf:info "<1-10000>;;weight value";
                  range "1..10000";
                }
              }
            }

            // interface Port-channel* / port-channel load-balance weighted rebalance
            leaf rebalance {
              tailf:info "Configure or disable automatic rebalancing";
              type union {
                type uint16 {
                  tailf:info "<1-10000>;;The threshold weight used to trigger "
                    +"automatic rebalancing";
                  range "1..10000";
                }
                type enumeration {
                  enum "disable" {
                    tailf:info "Disable automatic rebalancing";
                  }
                }
              }
            }
          }
        }

        // interface Port-channel* / port-channel min-links
        leaf min-links {
          tailf:info "Minimum number of bundled ports needed to bring"
            + " up this port channel";
          type uint8 {
            tailf:info "<2-8>;;The minimum number of bundled ports needed"
              + " before this port channel can come up.";
            range "2..8";
          }
        }
      }
    }

    // subinterface Port-channel #.#
    container Port-channel-subinterface {
      tailf:cli-drop-node-name;
      list Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-recursive-delete;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Port-channel";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses interface-ethernet-pre-grouping;
        uses sub-interface-switch-grouping;
        uses sub-interface-ethernet-switch-grouping;
        uses sub-interface-common-switch-grouping;
        uses sub-interface-ethernet-post-grouping;
      }
    }

    // interface Multilink
    list Multilink {
      tailf:info "Multilink-group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-65535>;;Multilink interface number";
          range "1..65535";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface MFR *
    list MFR {
      tailf:info "Multilink Frame Relay bundle interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<0-2147483647>;;MFR interface number";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // subinterface MFR #.#
    container MFR-subinterface {
      tailf:cli-drop-node-name;
      list MFR {
        tailf:info "Multilink Frame Relay bundle interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../MFR";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses sub-interface-common-grouping;
      }
    }

    // interface BRI *
    list BRI {
      tailf:info "ISDN Basic Rate Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;BRI interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Ethernet
    list Ethernet {
      tailf:info "Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<slot>/<port>;;Ethernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface FastEthernet
    list FastEthernet {
      tailf:info "FastEthernet IEEE 802.3";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;FastEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface GigabitEthernet *
    list GigabitEthernet {
      tailf:info "GigabitEthernet IEEE 802.3z";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface TenGigabitEthernet *
    list TenGigabitEthernet {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;TenGigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface FortyGigabitEthernet *
    list FortyGigabitEthernet {
      tailf:info "Forty Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "X/Y/Z;;FortyGigabitEthernet interface id";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface HundredGigE *
    list HundredGigE {
      tailf:info "Ten Gigabit Ethernet";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-66>/<0-128>;;HundredGigE interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface Wlan-GigabitEthernet *
    list Wlan-GigabitEthernet {
      tailf:info "Internal GigabitEthernet IEEE 802.3z connecting "+
        "to embedded AP";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-0>;;Wlan-GigabitEthernet interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface wlan-ap *
    list wlan-ap {
      tailf:info "Service module interface to embedded AP";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-0>;;wlan-ap interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface Dialer *
    list Dialer {
      tailf:info "Dialer interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<0-255>;;Dialer interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface ATM*
    list ATM {
      tailf:info "ATM interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      leaf point-to-point {
        tailf:info "Point-to-point interface";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        type empty;
      }

      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface ATM* / ima
      container ima {
        tailf:info "IMA Interface commands";

        // interface ATM* / ima version
        leaf version {
          tailf:info "IMA version";
          tailf:cli-full-command;
          type enumeration {
            enum "1.0" {
              tailf:info "IMA version 1.0";
            }
            enum "1.1" {
              tailf:info "IMA version 1.1";
            }
          }
        }

        // interface ATM* / ima group-id
        leaf group-id {
          type uint8 {
          }
        }
      }

      // interface ATM* / atm
      container atm {
        tailf:info "Modify ATM parameters";

        // interface ATM* / atm bandwidth
        container bandwidth {
          tailf:info "Allow bandwidth change on ATM PVCs";
          // interface ATM* / atm bandwidth dynamic
          leaf dynamic {
            tailf:info "Allow dynamic bandwidth change on ATM PVCs";
            type empty;
          }
        }

        // interface ATM* / atm mcpt-timers
        container mcpt-timers {
          tailf:info "Configure Maximum cell Packing Timeout Values";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf timer-1 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<500-10000>;;MCPT timer1 value in microsecond";
              range "500..10000";
            }
          }
          leaf timer-2 {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<500-10000>;;MCPT timer2 value in microsecond";
              range "500..10000";
            }
          }
          leaf timer-3 {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1000-10000>;;MCPT timer3 value in microsecond";
              range "1000..10000";
            }
          }
        }

        // interface ATM* / no atm enable-ilmi-trap
        leaf enable-ilmi-trap {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface ATM* / atm ilmi-keepalive
        container ilmi-keepalive {
          tailf:info "Keepalive polling configuration";
          presence true;
        }

        // interface ATM* / atm route-bridged
        container route-bridged {
          tailf:info "Route 1483 Ethernet encapsulated packets";
          leaf ip {
            tailf:info "Route IP over RFC 1483 Ethernet";
            type empty;
          }
          leaf ipv6 {
            tailf:info "Route IPv6 over RFC 1483 Ethernet";
            type empty;
          }
        }
      }

      // interface ATM* / pvc *
      list pvc {
        tailf:info "Configure ATM PVC parameters";
        tailf:cli-mode-name "cfg-if-atm-pvc";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VPI/VCI or VCI or handle";
          }
        }

        // interface ATM* / pvc * l2transport
        leaf l2transport {
          tailf:info "Set PVC to L2 transport VC, No L3 function";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // interface ATM* / pvc * / class-vc
        leaf class-vc {
          tailf:info "Configure default vc-class name";
          tailf:non-strict-leafref {
            path "../../../../vc-class/atm/name";
          }
          type string {
            tailf:info "WORD;;ATM vc-class name to use on this VC";
          }
        }

        // interface ATM* / pvc * / cell-packing
        container cell-packing {
          tailf:info "ATM Cell packing";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf maxcells {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<2-28>;;Maximum number of Cells in a packet";
              range "2..28";
            }
          }
          leaf mcpt-timer {
            tailf:info "Which MCPT timer to use";
            type uint8 {
              tailf:info "<1-3>;;Which MCPT timer to use";
              range "1..3";
            }
          }
        }

        // interface ATM* / pvc * / encapsulation
        leaf encapsulation {
          tailf:info "Select ATM Encapsulation for VC";
          tailf:cli-full-command;
          type enumeration {
            enum aal0 {
              tailf:info "Raw Cell, No SAR processing(Like-Like)";
            }
            enum aal5 {
              tailf:info "AAL5 Encapsulation(Like-Like)";
            }
            enum aal5snap {
              tailf:info "AAL5+LLC/SNAP Encapsulation";
            }
          }
        }

        // interface ATM* / pvc * / service-policy
        container service-policy {
          tailf:info "Attach a policy-map to a VC";
          uses service-policy-grouping;
        }

        // interface ATM* / pvc * / pppoe-client
        container pppoe-client {
          tailf:info "pppoe-client";

          // interface ATM* / pvc * / pppoe-client / dial-pool-number *
          list dial-pool-number {
            tailf:info "dialer pool keyword";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-remove-before-change;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<1-255>;;Dialer pool number";
              }
            }

            // interface ATM* / pvc * / pppoe-client / dial-pool-number * /
            // .. dial-on-demand
            leaf dial-on-demand {
              tailf:info "dial on demand enabled";
              type empty;
            }

            // interface ATM* / pvc * / pppoe-client / dial-pool-number * /
            // .. restart
            leaf restart {
              tailf:info "Set restart timeout value";
              type uint16 {
                tailf:info "<1-3600>;;Restart timeout, in seconds";
                range "1..3600";
              }
            }

            // interface ATM* / pvc * / pppoe-client / dial-pool-number * /
            // .. mac-override
            leaf mac-override {
              tailf:info "Use mac-address from dialer interface";
              tailf:cli-full-command;
              type empty;
            }

            // interface ATM* / pvc * / pppoe-client / dial-pool-number * /
            // .. service-name
            leaf service-name {
              tailf:info "Service name requested by the PPPoE client "+
                "for this dial-pool-number";
              type string {
                tailf:info "LINE;;Service Name string";
              }
            }
          }

          // interface ATM* / pvc * / pppoe-client / ppp-max-payload
          leaf ppp-max-payload {
            tailf:info "Send PPP Max-Payload tag in PPPoE control packets";
            type uint16 {
              tailf:info "<64-2030>;;Maximum MRU value to be negotiated "+
                "during PPP LCP negotiation";
              range "64..2030";
            }
          }
        }

        // interface ATM* / pvc * / xconnect
        uses xconnect-grouping;
      }
    }

    // interface CEM *
    list CEM {
      tailf:info "Circuit Emulation interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface CEM* / cem *
      list cem {
        tailf:info "Configure a CEM channel";
        tailf:cli-mode-name "config-if-cem";
        key id;
        leaf id {
          tailf:info "<0-64>;;Enter the group value";
          type uint8 {
            range "0..64";
          }
        }

        // interface CEM* / cem * / cem class
        container cem {
          tailf:info "Apply CEM class";
          leaf class {
            tailf:info "Apply CEM class";
            tailf:non-strict-leafref {
              path "../../../../../class/cem/name";
            }
            type string {
              tailf:info "WORD;;cem class name";
            }
          }
        }

        // interface CEM* / cem * / service-policy input
        container service-policy {
          tailf:info "Attach a policy-map to CEM Circuit";
          leaf "input" {
            tailf:info "Attach a policy-map to ingress of CEM Circuit";
            tailf:non-strict-leafref {
              path "../../../../../policy-map/name";
            }
            type string {
              tailf:info "WORD;;Policy-map name";
            }
          }
        }

        // interface CEM* / cem * / xconnect
        uses xconnect-grouping;
      }
    }

    // interface BDI *
    list BDI {
      tailf:info "Bridge-Domain interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../bridge-domain/bridge-domain-list";
        type uint16 {
          tailf:info "<1-4095>;;BDI interface number";
          range "1..4095";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface BVI *
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          tailf:info "<1-255>;;BVI interface number";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Cable *
    list Cable {
      tailf:info "CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Cable* / downstream
      container downstream {
        tailf:info "Associate a Cable/Modular-Cable/Integrated-Cable "+
          "interface with this CGD host";

        // interface Cable* / downstream Cable *
        list Cable {
          tailf:info "Cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }

        // interface Cable* / downstream Modular-Cable *
        list Modular-Cable {
          tailf:info "Modular cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
          leaf upstream {
            tailf:info "Logical Identifier of upstreams serving these downstream rf-channels";
            type string {
              tailf:info "<grouplist>;;List of Ranges for upstream channel <0-11>";
            }
          }
        }

        // interface Cable* / downstream Integrated-Cable *
        list Integrated-Cable {
          tailf:info "Integrated cable";
          tailf:cli-allow-join-with-key;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "<slot>/<card>/<port>;;Enter slot/subslot/bay";
            }
          }
          leaf rf-channel {
            tailf:info "RF channel";
            type string {
              tailf:info "<grouplist>;;List of port numbers and number ranges";
            }
          }
        }
      }

      // interface Cable* / upstream *
      list upstream {
        tailf:info "Associate a Upstream channel with this CGD host";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-7>;;US channel index in M";
            range "0..7";
          }
        }
        leaf Upstream-Cable {
          tailf:info "Upstream Cable Controller";
          tailf:cli-incomplete-command;
          type string {
            tailf:info "<slot>/<card>/<port>;;slot/subslot/controller of "+
              "upstream us-channels";
          }
        }
        leaf us-channel {
          tailf:info "Associate Upstream channels into this MD";
          type uint8 {
            tailf:info "<0-7>;;US channel index in the controller";
            range "0..7";
          }
        }
      }

      // interface Cable* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface Cable* / cable tftp-enforce
        container tftp-enforce {
          tailf:info "Only allow modems to register if they attempt tftp first";
          tailf:cli-delete-when-empty;
          presence true;
          leaf mark-only {
            tailf:info "Allow registration but mark violating modems "+
              "with # symbol";
            type empty;
          }
        }

        // interface Cable* / cable ip-init
        leaf ip-init {
          tailf:info "IP Initialization Parameters";
          type enumeration {
            enum apm {
              tailf:info "Alternate Provisioning mode";
            }
            enum dual-stack {
              tailf:info "Dual-stack Provisioning mode";
            }
            enum ipv4 {
              tailf:info "IPv4 Provisioning mode";
            }
            enum ipv6 {
              tailf:info "IPv6 Provisioning mode";
            }
          }
          default ipv4;
        }

        // interface Cable* / cable mtc-mode
        container mtc-mode {
          tailf:info "Enable/Disable Multiple Transmit Channel Mode";
          presence true;
        }

        // interface Cable* / cable rcc-template *
        list rcc-template {
          tailf:info "Bind RCC template to interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key index;
          leaf index {
            type uint8 {
              tailf:info "<1-255>;;cable rcc-template id";
              range "1..255";
            }
          }
        }

        // interface Cable* / cable rcp-control verbose
        container rcp-control {
          tailf:info "Receive Channel Profile control";
          leaf verbose {
            tailf:info "Enable verbose reporting";
            type empty;
          }
        }

        // interface Cable* / cable shared-secret
        container shared-secret {
          tailf:info "Shared Secret String";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }

        // interface Cable* / cable dynamic-secret
        container dynamic-secret {
          tailf:info "Enable dynamic secret for CM config files";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice dynamic-secret-choice {
            case reject {
              leaf reject {
                tailf:info "Reject registration request from modems violating "+
                  "dynamic secret";
                type empty;
              }
            }
            case mark {
              leaf mark {
                tailf:info "Mark modems violating dynamic secret";
                type empty;
              }
            }
            case lock {
              leaf lock {
                tailf:info "Lock modems violating dynamic secret";
                type empty;
              }
              leaf lock-qos {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint16 {
                  tailf:info "<1-1023>;;Profile used to lock";
                  range "1..1023";
                }
              }
            }
          }
          leaf nocrypt {
            tailf:info "Do not encrypt modem config file name";
            type empty;
          }
        }

        // interface Cable* / cable enable-trap
        container enable-trap {
          tailf:info "Enable an SNMP cable trap";
          leaf cmonoff-notification {
            tailf:info "Cable Modem Online/Offline notification";
            type empty;
          }
          leaf cmonoff-interval {
            tailf:info "Interval in Seconds";
            type uint32 {
              tailf:info "<0-86400>;;Interval in secs";
              range "0..86400";
            }
          }
        }

        // interface * / no cable packet-cache
        leaf packet-cache {
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface Cable* / cable default-phy-burst
        leaf default-phy-burst {
          tailf:info "Max phy burst if max long data grant is 0";
          type uint16 {
            tailf:info "<0-4096>;;Maximal number of bytes allowed in a burst";
            range "0..4096";
          }
        }

        // interface Cable* / cable insertion-interval
        container insertion-interval {
          tailf:info "Period between initial ranging opportunities - msec";
          choice interval-choice {
            leaf fixed-intrvl {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<100-2000>;;Fixed period between initial "+
                  "ranging slots - msec";
              }
            }
            container automatic {
              tailf:info "Use automatic adjustment algorithm for initial "+
                "ranging period";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf min-intrvl {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<20-120>;;Lower bound on period between "+
                    "initial ranging slots - msecs";
                  range "20..120";
                }
                default 60;
              }
              leaf max-intrvl {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<240-1800>;;Upper bound on period between "+
                    "initial ranging slots - msecs";
                  range "240..1800";
                }
                default 480;
              }
            }
          }
        }

        // interface Cable* / cable map-advance
        container map-advance {
          tailf:info "Set algorithm for the look-ahead time in MAPs";
          choice map-advance-choice {
            // interface Cable* / cable map-advance static
            leaf static {
              type uint16 {
                tailf:info "<100-20000>;;max map advance - usecs";
                range "100..20000";
              }
            }
            // interface Cable* / cable map-advance dynamic
            container dynamic {
              tailf:info "Automatically tune the value to the current "+
                "propagation delay";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf safety {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<300-1500>;;Safety factor - usecs";
                  range "300..1500";
                }
              }
              leaf max-delay {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<100-20000>;;max map advance - usecs";
                  range "100..20000";
                }
              }
            }
          }
        }

        // interface Cable* / cable sync-interval
        leaf sync-interval {
          tailf:info "Interval between CMTS transmission of successive SYNC";
          type uint16 {
            tailf:info "<1-200>;;sync interval - msec";
            range "1..200";
          }
        }

        // interface Cable* / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Cable* / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";

          // interface Cable* / cable downstream description
          leaf "description" {
            tailf:info "Downstream name/description";
            tailf:cli-multi-value;
            tailf:cli-preformatted;
            tailf:cli-full-command;
            type string {
              tailf:info "LINE;;Up to 80 characters describing this DS port";
              length "0..80";
            }
          }

          // interface Cable* / cable downstream dsg
          container dsg {
            tailf:info "Downstream DSG settings";
            // interface Cable* / cable downstream dsg timer
            leaf timer {
              tailf:info "DSG Timer Setting";
              type uint16 {
                tailf:info "<1-65535>;;DSG timer index.";
              }
            }
            // interface Cable* / cable downstream dsg tg *
            list tg {
              tailf:info "DSG Tunnel group";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key tgid;
              leaf tgid {
                type uint16 {
                  tailf:info "<1-65535>;;DSG Tunnel Group ID";
                  range "1..65535";
                }
              }
              // interface Cable* / cable downstream dsg tg * channel *
              list channel {
                tailf:info "DSG Channel";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key channel-id;
                leaf channel-id {
                  type uint16 {
                    tailf:info "<1-65535>;;DSG Channel ID";
                    range "1..65535";
                  }
                }
              }
            }
          }
        }

        // interface Cable* / cable upstream
        container upstream {
          tailf:info "Upstream port configuration";

          // interface Cable* / cable upstream balance-scheduling
          leaf balance-scheduling {
            tailf:info "upstream channel balance scheduling on one mac-domain";
            type empty;
          }

          // interface Cable* / cable upstream max-ports
          leaf max-ports {
            tailf:info "Maximum number of upstream ports for this interface";
            type uint8 {
              tailf:info "<0-8>;;Number of upstreams";
              range "0..8";
            }
          }

          // interface Cable* / cable upstream bonding-group *
          list bonding-group {
            tailf:info "Configure upstream bonding group";
            tailf:cli-mode-name "config-upstream-bonding";
            key id;
            leaf id {
              type uint16 {
                tailf:info "<1-65535>;;bonding group id";
                range "1..65535";
              }
            }

            // interface Cable* / cable upstream bonding-group * / description
            uses description-grouping;

            // interface Cable* / cable upstream bonding-group * / upstream *
            list upstream {
              tailf:info "Add an upstream to this bonding group.";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key number;
              leaf number {
                type uint8 {
                  tailf:info "<0-4>;;upstream to add";
                }
              }
            }

            // interface Cable* / cable upstream bonding-group * / attributes
            leaf attributes {
              tailf:info "Configure attributes for this bonding group.";
              type string {
                tailf:info "<0-FFFFFFFF>;;UBG Attribute Value in hex";
              }
            }
          }

          // interface Cable* / cable upstream resiliency
          container resiliency {
            tailf:info "upstream resiliency configuration";
            leaf on-failure {
              tailf:info "ranging retries exceeded error handling";
              type enumeration {
                enum disable-channel {
                  tailf:info "disable channel";
                }
                enum extended-ranging {
                  tailf:info "continue to range";
                }
                enum reset-modem {
                  tailf:info "take modem offline";
                }
              }
              default extended-ranging;
            }
          }

          // interface Cable* / cable upstream *
          list cable-upstream-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key port;
            leaf port {
              type uint8 {
                tailf:info "<0-4>;;Port number";
              }
            }

            // interface Cable* / cable upstream * connector
            leaf connector {
              tailf:info "Physical upstream connector";
              type uint8 {
                tailf:info "<0-19>;;Physical port number";
                range "0..19";
              }
            }

            // interface Cable* / cable upstream * frequency
            leaf frequency {
              tailf:info "Frequency";
              type uint32 {
                tailf:info "<5000000-85000000>;;Upstream Frequency in Hz";
                range "5000000..85000000";
              }
            }

            // interface Cable* / cable upstream * channel-width
            container channel-width {
              tailf:info "Channel width in HZ";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf first-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
              leaf last-choice-width {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "Channel width Hz";
                }
              }
            }

            // interface Cable* / cable upstream * description
            leaf "description" {
              tailf:info "Upstream name/description";
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;Up to 80 characters describing this US port";
              }
            }

            // interface Cable* / cable upstream * docsis-mode
            leaf docsis-mode {
              tailf:info "Upstream channel DOCSIS mode";
              type enumeration {
                enum atdma {
                  tailf:info "DOCSIS 2.0 ATDMA-only channel";
                }
                enum scdma {
                  tailf:info "DOCSIS 2.0 SCDMA-only channel";
                }
                enum tdma {
                  tailf:info "DOCSIS 1.x-only channel";
                }
                enum tdma-atdma {
                  tailf:info "DOCSIS 1.x and DOCSIS 2.0 mixed channel";
                }
              }
            }

            // interface Cable* / cable upstream * minislot-size
            leaf minislot-size {
              tailf:info "Minislot size";
              type uint8 {
                tailf:info "Minislot size in time ticks";
                range "1|2|4|8|16|32|64|128";
              }
            }

            // interface Cable* / cable upstream * power-adjust
            container power-adjust {
              tailf:info "Power adjustment";
              // interface Cable* / cable upstream * power-adjust continue
              leaf "continue" {
                tailf:info "Minimum power adjustment which set CONTINUE "+
                  "ranging status";
                type uint8 {
                  tailf:info "<2-15>;;Power level in dB";
                  range "2..15";
                }
              }
            }

            // interface Cable* / cable upstream * range-backoff
            container range-backoff {
              tailf:info "Change Range Backoff Value";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              choice range-backoff-choice {
                case automatic {
                  leaf automatic {
                    tailf:info "Automatic Change Range Backoff Value";
                    type empty;
                  }
                }
                case numeric {
                  leaf start {
                    tailf:cli-drop-node-name;
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-start";
                    }
                  }
                  leaf end {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<0-15>;;rangebackoff-end";
                    }
                  }
                }
              }
            }

            // interface Cable* / cable upstream * modulation-profile
            container modulation-profile {
              tailf:info "Modulation Profile Number";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf primary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;modulation number";
                }
              }
              leaf secondary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;secondary modulation number";
                }
              }
              leaf tertiary-profile-number {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "VALUE;;tertiary modulation number";
                }
              }
            }

            // interface Cable* / cable upstream * rate-limit
            // interface Cable* / cable upstream * no rate-limit
            leaf rate-limit {
              tailf:info "Enable DOCSIS rate limiting on current upstream";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
            }

            // interface Cable* / cable upstream * equalization-coefficient
            leaf equalization-coefficient {
              tailf:info "Enable equalization coefficient";
              type empty;
            }

            // interface Cable* / no cable upstream * equalization-error-recovery
            leaf equalization-error-recovery {
              tailf:info "Enable equ coeff error recovery";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }

            // interface Cable* / cable upstream * rate-adapt
            container rate-adapt {
              tailf:info "Configure upstream rate-adapt";
              presence true;
            }

            // interface Cable* / cable upstream * attribute-mask
            leaf attribute-mask {
              tailf:info "Upstream Channel Provisioned Attribute Mask";
              type string {
                tailf:info "<0-FFFFFFFF>;;Attribute mask in hex";
              }
            }

            // interface Cable* / cable upstream * chan-class-id
            leaf chan-class-id {
              tailf:info "Channel Class ID";
              type string {
                tailf:info "<0-FFFFFFFF>;;Class ID Extension";
              }
            }

            // interface Cable* / cable upstream * shutdown
            // interface Cable* / cable upstream * no shutdown
            leaf shutdown {
              tailf:info "Shutdown upstream port";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
            }
          }
        }

        // interface Cable* / cable sid-cluster-group
        container sid-cluster-group {
          tailf:info "SID Cluster Group parameters for Upstream "+
            "Channel Bonding";
          // interface Cable* / cable sid-cluster-group dynamic
          leaf dynamic {
            tailf:info "Dynamic algorithm";
            type empty;
          }
          // interface Cable* / cable sid-cluster-group num-of-cluster
          leaf num-of-cluster {
            tailf:info "Number of SID Cluster Group";
            type uint8 {
              tailf:info "<1-8>;;1, 2, 3, 4, 5, 6, 7, 8";
              range "1..8";
            }
          }
          // interface Cable* / cable sid-cluster-group  req-multiplier
          leaf req-multiplier {
            tailf:info "Request Multiplier";
            type uint8 {
              tailf:info "<1-16>;;1, 2, 4, 8, 16";
              range "1|2|4|8|16";
            }
          }
        }

        // interface Cable* / cable sid-cluster-switching
        container sid-cluster-switching {
          tailf:info "SID Cluster Switching parameters for Upstream Channel "+
            "Bonding";
          // interface Cable* / cable sid-cluster-switching max-request
          leaf max-request {
            tailf:info "Max request";
            type uint8 {
              tailf:info "<0-255>;;0 to 255";
            }
          }
          // interface Cable* / cable sid-cluster-switching max-time
          leaf max-time {
            tailf:info "Max time";
            type uint16 {
              tailf:info "<0-65535>;;0 to 65535";
            }
          }
        }

        // interface Cable* / cable divert-rate-limit
        container divert-rate-limit {
          tailf:info "Set divert-rate-limit parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf rate {
            tailf:info "rate in packets/sec";
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-65535>;;rate in packets/second";
            }
          }
          leaf limit {
            tailf:info "limit in packets";
            type uint16 {
              tailf:info "<4-4194>;;limit in packets";
            }
          }
        }

        // interface Cable* / cable privacy
        container privacy {
          tailf:info "Cable Privacy";

          // interface Cable* / cable privacy mandatory
          leaf "mandatory" {
            tailf:info "force privacy be mandatory";
            type empty;
          }

          // interface Cable* / cable privacy bpi-plus-policy
          leaf bpi-plus-policy {
            tailf:info "Privacy requires BPI+";
            type enumeration {
              enum capable-enforcement {
                tailf:info "BPI+ required for all capable modems with BPI+ "+
                  "enabled (policy 1)";
              }
              enum d11-enabled-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems with "+
                  "BPI+ enabled (policy 2)";
              }
              enum d11-enforcement {
                tailf:info "BPI+ required for all D1.1 and later modems "+
                  "(policy 3)";
              }
              enum total-enforcement {
                tailf:info "BPI+ required for all modems (policy 4)";
              }
            }
          }

          // interface Cable* / cable privacy accept-self-signed-certificate
          leaf accept-self-signed-certificate {
            tailf:info "Accept Self signed Manufacturer certificate";
            type empty;
          }

          // interface Cable* / cable privacy eae-policy
          leaf eae-policy {
            tailf:info "Select EAE Policy";
            type enumeration {
              enum capability-enforcement {
                tailf:info "Enforce on EAE capable modems (policy 3)";
                value 3;
              }
              enum disable-enforcement {
                tailf:info "Disable EAE (policy 1)";
                value 1;
              }
              enum ranging-enforcement {
                tailf:info "Enforce on DOCSIS 3.0 modems (policy 2)";
                value 2;
              }
              enum total-enforcement {
                tailf:info "Enforce EAE on all modems (policy 4)";
                value 4;
              }
            }
          }
        }
      }
    }

    // interface Video *
    list Video {
      tailf:info "video service interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Integrated-Cable *
    list Integrated-Cable {
      tailf:info "Integrated Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Integrated-Cable * / cable
      container cable {
        tailf:info "Integrated-Cable interface subcommands";

        // interface Integrated-Cable* / cable bundle [READ-ONLY]
        leaf bundle {
          tailf:info "Bundle number for bundling of IC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Integrated-Cable* / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:info "% of reserved RF channel bandwidth";
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;% bandwidth";
              range "1..100";
            }
          }
        }
      }
    }

    // interface Modular-Cable *
    list Modular-Cable {
      tailf:info "Modular Cable interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Modular-Cable* / cable
      container cable {
        tailf:info "MC Cable interface subcommands";

        // interface Modular-Cable* / cable bundle [READ-ONLY]
        leaf bundle {
          tailf:info "Bundle number for bundling of MC cable interfaces";
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Modular-Cable* / cable rf-bandwidth-percent
        container rf-bandwidth-percent {
          tailf:info "% of RF channel bandwidth reserved for this MC interface";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf percent-value {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-96>;;% bandwidth";
              range "1..96";
            }
          }
          container remaining {
            tailf:info "ratio of the remaining bandwidth";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf ratio {
              tailf:info "ratio for sharing excess bandwidth";
              type uint8 {
                tailf:info "<1-100>;;Ratio";
              }
            }
          }
        }

        // interface Modular-Cable* / cable cm-status
        container cm-status {
          tailf:info "CM-STATUS events";

          // interface Modular-Cable* / no cable cm-status enable
          // interface Modular-Cable* / cable cm-status enable no-list
          container enable {
            tailf:info "enable CM-STATUS events";
            leaf no-list {
              tailf:info "'no  cable cm-status enable' entry";
              tailf:cli-multi-value;
              tailf:cli-preformatted;
              tailf:cli-full-command;
              type string {
                tailf:info "<grouplist>;;CM-STATUS event list to disable";
              }
            }
          }
        }
      }
    }

    // interface Wideband-Cable *
    list Wideband-Cable {
      tailf:info "Wideband CMTS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Wideband-Cable* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface Wideband-Cable* / cable bundle
        leaf bundle {
          tailf:info "Bundle number for bundling of cable interfaces";
          tailf:cli-remove-before-change;
          type uint8 {
            tailf:info "<1-255>;;Bundle number";
            range "1..255";
          }
        }

        // interface Wideband-Cable* / cable privacy
        container privacy {
          tailf:info "Cable Privacy";

          // interface Wideband-Cable* / cable privacy accept-self-signed-certificate
          leaf accept-self-signed-certificate {
            tailf:info "Accept Self signed Manufacturer certificate";
            type empty;
          }
        }

        // interface Wideband-Cable* / cable ds-resiliency
        leaf ds-resiliency {
          tailf:info "Downstream resiliency bonding group";
          type empty;
        }

        // interface  Wideband-Cable* / cable rf-channel *
        container rf-channel {
          tailf:info "RF channel associated with this Wideband interface";

          // interface Wideband-Cable* / cable rf-channel *
          list rf-channel-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key rf-port;
            leaf rf-port {
              type uint8 {
                tailf:info "<0-23>;;RF channel number";
                range "0..23";
              }
            }

            // interface Cable* / cable rf-channel * bandwidth-percent
            leaf bandwidth-percent {
              tailf:info "% bandwidth of RF channel reserved for this "+
                "Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }

            // interface Cable* / cable rf-channel * remaining ratio
            container remaining {
              tailf:info "ratio of the remaining bandwidth";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf ratio {
                tailf:info "ratio for sharing excess bandwidth";
                type uint8 {
                  tailf:info "<1-100>;;Ratio";
                }
              }
            }
          }
        }

        // interface Wideband-Cable* / cable rf-channels
        container rf-channels {
          tailf:info "rf-channels associated with this Wideband interface";

          // interface  Wideband-Cable* / cable rf-channels channel-list *
          list channel-list {
            tailf:info "Configure list of individual rf-channels and ranges of rf-channels";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            key bandwidth-percent;
            leaf bandwidth-percent {
              tailf:cli-expose-key-name;
              tailf:info "% bandwidth of RF channel reserved for this "+
                "Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
            leaf-list group-list {
              // Note: List separated by ',' in NCS, on device by ' '. Java converts.
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              tailf:cli-range-list-syntax;
              type uint8 {
                tailf:info "<grouplist>;;List of individual rf-channels and ranges of rf-channels";
              }
            }
          }

          // interface  Wideband-Cable* / cable rf-channels controller *
          list controller {
            tailf:info "Specify controller for rf-channels";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            key id;
            leaf id {
              type uint8 {
                tailf:info "<0-3>;;Enter controller number";
                range "0..3";
              }
            }
            leaf-list channel-list {
              tailf:info "Configure list of individual rf-channels and ranges of rf-channels";
              // Note: List separated by ',' in NCS, on device by ' '. Java converts.
              tailf:cli-range-list-syntax;
              tailf:cli-incomplete-command;
              tailf:cli-incomplete-no;
              type uint8 {
                tailf:info "<grouplist>;;List of individual rf-channels and ranges of rf-channels";
              }
            }
            leaf bandwidth-percent {
              tailf:info "% bandwidth of RF channel reserved for this "+
                "Wideband interface";
              type uint8 {
                tailf:info "<1-100>;;% bandwidth";
                range "1..100";
              }
            }
          }
        }

        // interface Wideband-Cable* / cable downstream
        container downstream {
          tailf:info "Downstream parameter configuration";

          // interface Wideband-Cable* / cable downstream attribute-mask
          leaf attribute-mask {
            tailf:info "Downstream channel provisioned Attribute Mask";
            type string {
              tailf:info "<0-FFFFFFFF>;;The attribute bitmap in hex";
            }
          }
        }
      }
    }

    // interface Bundle *
    list Bundle {
      tailf:info "Virtual Bundle";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint8 {
          tailf:info "<1-255>;;Bundle interface number";
          range "1..255";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Bundle* / cable
      container cable {
        tailf:info "Cable interface subcommands";

        // interface * / no cable nd
        leaf nd {
          tailf:info "Enable IPv6 ND gleaning";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }

        // interface * / cable arp
        container arp {
          tailf:info "Enable arp request";
          container filter {
            tailf:info "Filter arp packets";
            container request-send {
              tailf:info "send x arp requests every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp request packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
            container reply-accept {
              tailf:info "accept x arp replies every y seconds or none";
              tailf:cli-show-no;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              presence true;
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<0-20>;;number of arp reply packets";
                }
              }
              leaf window-size {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<1-5>;;size of time window in seconds";
                }
              }
            }
          }
        }

        // no cable arp
        container conf {
          tailf:cli-drop-node-name;
          leaf arp {
            tailf:cli-boolean-no;
            tailf:cli-full-command;
            type boolean;
            default true;
          }
        }

        // interface * / cable ipv6
        container ipv6 {
          tailf:info "IPv6 related configuration";

          // interface * / cable ipv6 source-verify
          container source-verify {
            tailf:info "Enable verification of source of IPv6 packets";

            // interface * / cable ipv6 source-verify dhcp
            container dhcp {
              tailf:info "Verify address with the DHCPv6 server";
              presence true;
              leaf server {
                tailf:info "Specify the lease query server where the DHCPv6 "+
                  "lease queries should be sent";
                type inet:ipv6-address {
                  tailf:info "X:X:X:X::X;;IPv6 Address of the lease query "+
                    "server";
                }
              }
            }

            // interface * / cable ipv6 source-verify leasequery-filter upstream
            container leasequery-filter {
              tailf:info "Filter x IPv6 lease query requests every y "+
                "seconds or none";
              container upstream {
                tailf:info "IPv6 Lease query for upstream pkts";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf threshold {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-20>;;Number of IPv6 lease queries per sid";
                    range "0..20";
                  }
                }
                leaf interval {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-5>;;size of time window in seconds for IPv6";
                    range "1..5";
                  }
                }
              }
            }

            // interface * / cable ipv6 leasetimer
            leaf leasetimer {
              tailf:info "Specify the IPv6 lease timer value";
              type uint8 {
                tailf:info "<1-240>;;IPv6 Time in minutes";
                range "1..240";
              }
            }
          }
        }

        // interface * / cable source-verify
        leaf source-verify {
          tailf:info "Enable verification of source of packets";
          tailf:cli-full-command;
          type empty;
        }

        // interface * / cable source-verify X
        container source-verify-conf {
          tailf:cli-drop-node-name;
          container source-verify {
            tailf:info "Enable verification of source of packets";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;

            // interface * / cable source-verify dhcp
            container dhcp {
              tailf:info "Verify address with the DHCPv4 server";
              presence true;
              leaf server {
                tailf:info "Specify the lease query server where the DHCPv4 "+
                  "lease queries should be sent";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 Address of the lease query server";
                }
              }
            }

            // interface * / cable source-verify leasequery-filter upstream
            container leasequery-filter {
              tailf:info "Filter x IPv4 lease query requests every y "+
                "seconds or none";
              container upstream {
                tailf:info "Lease query for upstream pkts";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf threshold {
                  tailf:cli-drop-node-name;
                  tailf:cli-incomplete-command;
                  type uint8 {
                    tailf:info "<0-20>;;Number of IPv4 lease queries per sid";
                    range "0..20";
                  }
                }
                leaf interval {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-5>;;size of time window in seconds for IPv4";
                    range "1..5";
                  }
                }
              }
            }

            // interface * / cable source-verify leasetimer
            leaf leasetimer {
              tailf:info "Specify the IPv4 lease timer value";
              type uint8 {
                tailf:info "<1-240>;;IPv4 Time in minutes";
                range "1..240";
              }
            }
          }
        }

        // interface * / cable dhcp-parse
        container dhcp-parse {
          tailf:info "DHCP parse option";
          leaf option-43 {
            tailf:info "DHCP parse option 43";
            type empty;
          }
          leaf option-60 {
            tailf:info "DHCP parse option 60";
            type empty;
          }
        }

        // interface * / cable dhcp-giaddr
        container dhcp-giaddr {
          tailf:info "Control of giaddr in relayed DHCP requests";
          choice dhcp-giaddr-choice {
            container policy {
              tailf:info "Use primary address for CMs, secondary addresses "+
                "for hosts";
              presence true;
            }
            leaf primary {
              tailf:info "Use primary address for all devices";
              type empty;
            }
          }
        }

        // interface * / cable helper-address *
        list helper-address {
          tailf:info "Specify a destination address for UDP broadcasts";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key IP-address;
          leaf IP-address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
        }
      }
    }

    // interface Cellular*
    list Cellular {
      tailf:info "Cellular WAN interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Qam-red*
    list Qam-red {
      tailf:info "QAM red interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;

      // interface Qam-red* / cable
      container cable {
        tailf:info "cable config for qam subinterfaces";

        // interface Qam-red* / cable carrier-id
        leaf carrier-id {
          tailf:info "QAM carrier id. 1-192 ids are for QAM block 1, "+
            "193-384 for QAM block 2";
          type uint16 {
            tailf:info "<1-384>;;QAM Carrier id per line card";
            range "1..384";
          }
        }

        // interface Qam-red* / cable mode depi
        container mode {
          tailf:info "Setup qam channel mode to DEPI or Video";
          container depi {
            tailf:info "DEPI mode";
            choice depi-choice {
              container local {
                tailf:info "Sessions are configured locally";
              }

              // interface Qam-red* / cable mode depi remote
              container remote {
                tailf:info "Sessions are configured remotely";
                tailf:cli-delete-when-empty;
                presence true;
                // interface Qam-red* / cable mode depi remote learn
                leaf learn {
                  tailf:info "QAM can be configured remotely";
                  type empty;
                }
              }
            }
          }
        }

        // interface Qam-red* / cable downstream
        container downstream {
          tailf:info "downstream port of the line card";

          // interface Qam-red* / cable downstream max-carriers
          leaf max-carriers {
            tailf:info "max carriers per port";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-128>;;max carriers per port";
              range "1..128";
            }
          }

          // interface Qam-red* / cable downstream lqam-group
          leaf lqam-group {
            tailf:info "Logical QAM group";
            type uint8 {
              tailf:info "<1-48>;;QAM Logical group per line card";
              range "1..48";
            }
          }

          // interface Qam-red* / cable downstream tsid
          leaf tsid {
            tailf:info "set the downstream transport stream id";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;transport stream id";
            }
          }
        }
      }

      // interface Qam-red* / depi depi-tunnel
      container depi {
        tailf:info "DEPI Session commands";
        leaf depi-tunnel {
          tailf:info "Name to use for DEPI Tunnel";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Enter DEPI Tunnel Name";
          }
        }
      }
    }

    // interface Asi *
    list Asi {
      tailf:info "ASI interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface Vlan*
    list Vlan {
      tailf:info "Catalyst Vlans";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-diff-dependency "../../vlan/vlan-list";
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;
    }

    // interface Async*
    list Async {
      tailf:info "Async interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Async interface id";
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface Group-Async*
    list Group-Async {
      tailf:info "Async Group interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-64>;;Group-Async interface number";
          range "0..64";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // interface POS*
    list POS {
      tailf:info "POS interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;


      // interface * / aps
      container aps {
        tailf:info "Configure APS";

        // interface * / aps group
        leaf group {
          tailf:info "Group association";
          type uint8 {
            tailf:info "Number of the group. Range is from 1 through 255.";
            range "1..255";
          }
        }

        // interface * / aps protect *
        list protect {
          tailf:info "Protect specified circuit";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "circuit-number ip-address";
          leaf circuit-number {
            type uint32 {
              tailf:info "Number of the circuit to enable as a protect interface.";
            }
          }
          leaf ip-address {
            type inet:ip-address {
              tailf:info "IP address of the router that has the working POS interface.";
            }
          }
        }

        // interface * / aps working
        leaf working {
          tailf:info "Working channel number";
          type uint32 {
            tailf:info "Circuit number associated with this working interface.";
          }
        }
      }

      // interface POS* / pos
      container pos {
        tailf:info "Modify POS parameters";

        // interface POS* / pos ais-shut
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH LAIS when shutdown";
          tailf:cli-full-command;
          type empty;
        }

        // interface POS* / pos framing
        leaf framing {
          tailf:info "specify framing";
          tailf:cli-full-command;
          type enumeration {
            enum sdh {
              tailf:info "Select sdh framing";
            }
            enum sonet {
              tailf:info "Select sonet framing(default)";
            }
          }
          default sonet;
        }

        // interface POS* / pos report
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";

          // interface POS* / pos report rdool
          leaf rdool {
            type empty;
          }

          // interface POS* / pos report lais
          leaf lais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // interface POS* / pos report lrdi
          leaf lrdi {
            type empty;
          }

          // interface POS* / pos report pais
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }

          // controller SONET * / path report prdi
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }

          // controller SONET * / path report sd-ber
          leaf sd-ber {
            type empty;
          }
        }

        // interface POS* / pos scramble-atm
        leaf scramble-atm {
          tailf:info "Enable ATM scrambling";
          tailf:cli-full-command;
          type empty;
        }

        // interface POS* / pos threshold
        container threshold {
          tailf:info "Configure SONET/SDH section/line BER threshold values";

          // interface POS* / pos threshold sf-ber
          leaf sf-ber {
            tailf:info "Set Signal Fail BER threshold";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
              range "3..9";
            }
            default 3;
          }
        }

        // interface POS* / pos flag
        container flag {
          tailf:info "Specify byte value";

          // interface POS* / pos flag c2
          leaf c2 {
            tailf:info "Path overhead byte";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;byte value";
            }
          }

          // interface POS* / pos flag j0
          leaf j0 {
            tailf:info "Section trace byte (default is 0x01)";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;byte value";
            }
          }

          // interface POS* / pos flag s1s0
          leaf s1s0 {
            tailf:info "Specify bit S1 and S0 of H1 (default is 0)";
            type uint8 {
              tailf:info "<0-3>;;S1 & S0 bits (default is 0)";
              range "0..3";
            }
            default 0;
          }
        }

        // interface POS* / pos delay triggers
        container delay {
          tailf:info "Delay POS alarm triggers";
          container triggers {
            tailf:info "Triggers line protocol to go down";

            // interface POS* / pos delay triggers line
            leaf line {
              tailf:info "Specify delay for SONET LINE level triggers "+
                "(S-LOS, S-LOF, L-AIS)";
              type uint16 {
                tailf:info "<0-60000>;;Holdoff time, in msec";
                range "0..60000";
              }
            }

            // interface POS* / pos delay triggers line path
            leaf "path" {
              tailf:info "Enable SONET PATH level triggers "+
                "(P-AIS, P-LOP, P-RDI), with optional delay";
              type uint16 {
                tailf:info "<0-60000>;;Holdoff time, in msec";
                range "0..60000";
              }
            }
          }
        }

      }
    }

    // interface Serial*
    list Serial {
      tailf:info "Serial interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
      uses interface-pointtopoint-grouping;
    }

    // subinterface Serial*
    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../Serial";
          type string {
            pattern '[0-9]+(/[\.0-9]+)*(:[0-9]+)?\.[0-9]+';
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum multipoint {
              tailf:info "Treat as a multipoint link";
            }
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-pre-grouping;
        uses sub-interface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }

    // interface Virtual-Template*
    list Virtual-Template {
      tailf:info "Virtual Template interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-recursive-delete;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-4095>;;Virtual-Template interface number";
          range "1..4095";
        }
      }

      // interface Virtual-Template* type
      leaf "type" {
        tailf:info "type of the virtual-template";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum ethernet {
            tailf:info "Set VT type as ethernet";
          }
          enum serial {
            tailf:info "Set VT type as serial";
          }
          enum tunnel {
            tailf:info "Set VT type as tunnel";
          }
        }
      }

      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-ethernet-grouping;
      uses interface-common-grouping;
      uses interface-ethernet-post-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-tunnel-grouping;
    }

    // interface pseudowire*
    list pseudowire {
      tailf:info "Pseudowire Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint32 {
          tailf:info "<1-231072>;;pseudowire interface number";
          range "1..231072";
        }
      }

      // interface pseudowire* / description
      leaf "description" {
        tailf:info "Interface specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Description string";
          length "0..200";
        }
      }

      // interface pseudowire* / shutdown
      leaf shutdown {
        tailf:info "Shutdown the selected interface";
        tailf:cli-show-no;
        tailf:cli-full-command;
        type empty;
      }

      // interface pseudowire* / source
      container source {
        tailf:info "Get config from another source";
        container template {
          tailf:info "Get config from a template";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf "type" {
            tailf:info "Type of the template";
            type enumeration {
              enum pseudowire {
                tailf:info "Template customized interface pseudowire";
              }
            }
          }
          leaf name {
            tailf:cli-drop-node-name;
            tailf:non-strict-leafref {
              path "../../../../../template/name";
            }
            type string {
              tailf:info "WORD;;Template name";
            }
          }
        }
      }

      // interface pseudowire* / encapsulation
      leaf encapsulation {
        tailf:info "Data encapsulation method";
        tailf:cli-full-command;
        type enumeration {
          enum l2tpv3 {
            tailf:info "Use L2TPv3 encapsulation";
          }
          enum mpls {
            tailf:info "Use MPLS encapsulation";
          }
        }
      }

      // interface pseudowire* / signaling protocol
      container signaling {
        tailf:info "Signaling options";
        leaf protocol {
          tailf:info "Signaling protocol to use";
          type enumeration {
            enum ldp {
              tailf:info "Use LDP signaling";
            }
            enum none {
              tailf:info "No signaling, use manually configured pseudowires";
            }
          }
        }
      }

      // interface pseudowire* / neighbor
      container neighbor {
        tailf:info "Neighbor options";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of the peer PE";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
      }

      // interface pseudowire* / mtu
      leaf mtu {
        tailf:info "set Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<64-65535>;;Maximum Transmission Unit value";
          range "64..65535";
        }
      }

      // interface pseudowire* / control-word
      leaf control-word {
        tailf:info "Control-word options";
        type enumeration {
          enum exclude {
            tailf:info "Exclude control-word in pseudowire packets";
          }
          enum "include" {
            tailf:info "Include control-word in pseudowire packets";
          }
        }
      }

      // interface pseudowire* / label
      container label {
        tailf:info "MPLS local and remote pseudowire static labels";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-diff-dependency "../../../mpls/label/range";
        leaf local-pseudowire-label {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<0-4294967295>;;Local pseudowire label";
          }
        }
        leaf remote-pseudowire-label {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Remote pseudowire label";
            range "16..1048575";
          }
        }
      }

      // interface pseudowire* / pseudowire type
      container pseudowire {
        tailf:info "Pseudowire parameters";
        tailf:cli-diff-dependency "../signaling/protocol";
        leaf "type" {
          tailf:info "Pseudowire type";
          type string {
            tailf:info "XY;;Pseudowire Type in hex format";
          }
        }
      }

      // interface pseudowire* / service-policy
      container service-policy {
        tailf:info "Configure Service Policy";
        uses service-policy-grouping;
      }
    }

    // interface LISP*
    list LISP {
      tailf:info "Locator/ID Separation Protocol Virtual Interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<0-1999>;;LISP interface number";
          range "0..1999";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // subinterface LISP*
    container LISP-subinterface {
      tailf:cli-drop-node-name;
      list LISP {
        tailf:cli-allow-join-with-key {
          tailf:cli-display-joined;
        }
        tailf:cli-mode-name "config-subif";
        tailf:cli-suppress-key-abbreviation;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../LISP";
          type string {
            pattern '[0-9]+\.[0-9]+';
          }
        }
        uses interface-common-pre-grouping;
        uses sub-interface-common-grouping;
      }
    }

    // interface vasileft*
    list vasileft {
      tailf:info "VasiLeft interface";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;vasileft interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface vasiright*
    list vasiright {
      tailf:info "VasiRight interface";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;

      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;vasiright interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface AppNav-Compress*
    list AppNav-Compress {
      tailf:info "Service-Context Virtual Interface Compress";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-diff-dependency "../../service-insertion/service-context";
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;AppNav-Compress interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface AppNav-UnCompress*
    list AppNav-UnCompress {
      tailf:info "Service-Context Virtual interface UnCompress";
      tailf:cli-full-command;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      tailf:cli-diff-dependency "../../service-insertion/service-context";
      key name;
      leaf name {
        type uint16 {
          tailf:info "<1-1000>;;AppNav-UnCompress interface number";
          range "1..1000";
        }
      }
      uses interface-common-pre-grouping;
      uses interface-common-grouping;
    }

    // interface ucse*
    list ucse {
      tailf:info "Cisco ucse server";
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      tailf:cli-mode-name "config-if";
      tailf:cli-suppress-key-abbreviation;
      key name;
      leaf name {
        tailf:cli-suppress-range;
        type string {
          pattern '[0-9]+.*';
        }
      }
      uses interface-common-pre-grouping;
      uses interface-ethernet-pre-grouping;
      uses interface-switch-grouping;
      uses interface-ethernet-switch-grouping;
      uses interface-common-switch-grouping;
      uses interface-ethernet-post-grouping;
    }
  }


  /// ========================================================================
  /// access-list
  /// ========================================================================

  container access-list {
    tailf:info "Add an access list entry";
    tailf:cli-incomplete-command;

    // access-list *
    list access-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:meta-data "replace-list" {
        tailf:meta-value "access-list :: rule :: rule";
      }
      tailf:ned-data "." {
        tailf:transaction to;
      }
      key id;
      leaf id {
        tailf:cli-incomplete-no;
        tailf:cli-suppress-range;
        type union {
          type uint16 {
            tailf:info "<1-99>;;IP standard access list";
            range "1..99";
          }
          type uint16 {
            tailf:info "<100-199>;;IP extended access list";
            range "100..199";
          }
          type uint16 {
            tailf:info "<200-299>;;Protocol type-code access list";
            range "200..299";
          }
          type uint16 {
            tailf:info "<600-699>;;Appletalk access list";
            range "600..699";
          }
          type uint16 {
            tailf:info "<700-799>;;48-bit MAC address access list";
            range "700..799";
          }
          type uint16 {
            tailf:info "<800-899>;;IPX standard access list";
            range "800..899";
          }
          type uint16 {
            tailf:info "<900-999>;;IPX extended access list";
            range "900..999";
          }
          type uint16 {
            tailf:info "<1000-1099>;;IPX SAP access list";
            range "1000..1099";
          }
          type uint16 {
            tailf:info "<1100-1199>;;Extended 48-bit MAC address access list";
            range "1100..1199";
          }
          type uint16 {
            tailf:info "<1200-1299>;;IPX summary address access list";
            range "1200..1299";
          }
          type uint16 {
            tailf:info "<1300-1999>;;IP standard access list (expanded range)";
            range "1300..1999";
          }
          type uint16 {
            tailf:info "<2000-2699>;;IP extended access list (expanded range)";
            range "2000..2699";
          }
          type uint16 {
            tailf:info "<2700-2799>;;MPLS access list";
            range "2700..2799";
          }
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "<RULE>;;deny <options> | permit <options> | remark <comment>";
            pattern "(permit.*)|(deny.*)|(remark.*)|(dynamic.*)";
          }
        }
        leaf seq {
          // note: shown when "ip access-list persistent" is set
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type uint32 {
            tailf:info "<1-2147483647>;;Sequence Number [with ip access-list persistent]";
            range "1..2147483647";
          }
        }
      }
    }

    // access-list dynamic-extended
    leaf dynamic-extended {
      tailf:info "Extend the dynamic ACL absolute timer";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// arp
  /// ========================================================================

  container arp {
    tailf:info "Set a static ARP entry";

    // arp *
    uses arp-grouping;

    // arp vrf *
    list vrf {
      tailf:info "Configure static ARP for a VPN Routing/Forwarding instance";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
      uses arp-grouping;
    }

    // arp access-list *
    list access-list {
      tailf:info "Named access-list";
      tailf:cli-mode-name "config-arp-nacl";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;access-list name";
        }
      }

      // arp access-list * / <rule>
      list access-list-rule {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-show-long-obu-diffs;
        tailf:cli-case-sensitive;
        ordered-by user;
        key rule;
        leaf rule {
          tailf:cli-drop-node-name;
          tailf:cli-multi-word-key;
          type string {
            tailf:info "deny;;Specify packets to reject\n"+
              "permit;;Specify packets to forwards";
            pattern "(deny .*)|(permit .*)";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// virtual-service
  /// ========================================================================

  list virtual-service {
    tailf:info "Configure virtual service";
    tailf:cli-mode-name "config-virt-serv";
    tailf:cli-explicit-exit;
    tailf:cli-recursive-delete;
    tailf:cli-diff-dependency "../interface/VirtualPortGroup";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Virtual service name (up to 63 characters)";
      }
    }

    // virtual-service * / description
    leaf "description" {
      tailf:info "Virtual service description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of this virtual service "+
          "(up to 191 characters)";
        length "0..191";
      }
    }

    // virtual-service * / ip shared host-interface
    container ip {
      tailf:info "Share IP address with a host interface";
      container shared {
        tailf:info "Share IP address with a host interface";
        container host-interface {
          tailf:info "Host interface to share IP address with";
          leaf GigabitEthernet {
            tailf:info "GigabitEthernet IEEE 802.3z";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            tailf:non-strict-leafref {
              path "../../../../../interface/GigabitEthernet/name";
            }
            type string {
              tailf:info "WORD;;GigabitEthernet interface id";
              pattern '[0-9]+.*';
            }
          }
        }
      }
    }

    // virtual-service * / profile
    leaf profile {
      tailf:info "Specify the resource profile for virtual service";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type enumeration {
        enum ISR-WAAS-1300 {
          tailf:info "ISR-WAAS profile for 1300 TCP connections";
        }
        enum ISR-WAAS-750 {
          tailf:info "ISR-WAAS profile for 750 TCP connections";
        }
        enum ISR-WAAS-2500 {
          tailf:info "ISR-WAAS profile for 2500 TCP connections";
        }
        enum high {
          tailf:info "CSR UTD IPS/IDS HIGH profile";
        }
        enum low {
          tailf:info "CSR UTD IPS/IDS LOW profile";
        }
        enum medium {
          tailf:info "CSR UTD IPS/IDS MEDIUM profile";
        }
        enum urlf-low {
          tailf:info "CSR UTD URL Filtering LOW profile";
        }
      }
    }

    // virtual-service * / vnic gateway VirtualPortGroup*
    container vnic {
      tailf:info "Guest vnic configuration";
      container gateway {
        tailf:info "Gateway interface to connect to the guest vnic";
        list VirtualPortGroup {
          tailf:info "Virtual Port Group";
          tailf:cli-allow-join-with-key {
            tailf:cli-display-joined;
          }
          tailf:cli-mode-name "config-virt-serv-vnic";
          tailf:cli-suppress-key-abbreviation;
          key name;
          leaf name {
            tailf:non-strict-leafref {
              path "../../../../../interface/VirtualPortGroup/name";
            }
            type uint8 {
              tailf:info "<0-31>;;VirtualPortGroup interface number";
            }
          }

          // virtual-service * / vnic gateway VirtualPortGroup* / guest
          container guest {
            tailf:info "Configure guest vnic address";

            // virtual-service * / vnic gateway VirtualPortGroup* / guest ip address
            container ip {
              tailf:info "Guest vnic IP address";
              leaf address {
                tailf:info "Set the IP address of virtual interface on guest";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
            }
          }
        }
      }
    }

    // virtual-service * / activate
    leaf activate {
      tailf:info "Activate configured virtual service";
      tailf:cli-diff-dependency "../profile";
      tailf:cli-diff-dependency "../vnic";
      type empty;
    }
  }


  /// ========================================================================
  /// route-map
  /// ========================================================================

  list route-map {
    tailf:info "Route map tag";
    tailf:cli-mode-name "config-route-map";
    tailf:cli-compact-syntax;
    tailf:cli-full-command;
    tailf:cli-diff-dependency "../ip/community-list";
    tailf:cli-diff-dependency "../ip/extcommunity-list";
    key "name sequence";
    leaf name {
      type string {
        tailf:info "WORD;;Route map tag";
      }
    }

    // route-map * #
    leaf sequence {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<0-65535>;;Sequence to insert to/delete from "
          +"existing route-map entry";
        range "0..65535";
      }
    }

    // route-map * permit
    // route-map * deny
    leaf operation {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      type enumeration {
        enum deny {
          tailf:code-name "op_deny";
          tailf:info "Route map denies set operations";
        }
        enum permit {
          tailf:code-name "op_internet";
          tailf:info "Route map permits set operations";
        }
      }
    }

    // route-map * / description
    leaf "description" {
      tailf:info "Route-map comment";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Comment up to 100 characters";
        length "0..100";
      }
    }

    // route-map * / match
    container match {
      tailf:info "Match values from routing table";

      // route-map * / match as-path *
      leaf-list as-path {
        tailf:info "Match BGP AS path list";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Access-list number or name";
        }
      }

      // route-map * / match ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / match ip address
        container address {
          tailf:info "Match address of route or match packet";

          // route-map * / match ip address *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            ordered-by user;
            type exp-ip-acl-type;
          }

          // route-map * / match ip address prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }

        // route-map * / match ip next-hop
        container next-hop {
          tailf:info "Match next-hop address of route";

          // route-map * / match ip next-hop *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            ordered-by user;
            type std-ip-acl-type;
          }

          // route-map * / match ip next-hop prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }

        // route-map * / match ip route-source
        container route-source {
          tailf:info "Match advertising source address of route";

          // route-map * / match ip route-source *
          leaf-list access-list {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-disallow-value "prefix-list";
            ordered-by user;
            type std-ip-acl-type;
          }

          // route-map * / match ip route-source prefix-list *
          leaf-list prefix-list {
            tailf:info "Match entries of prefix-lists";
            tailf:cli-flat-list-syntax;
            tailf:non-strict-leafref {
              path "../../../../../ip/prefix-list/prefixes/name";
            }
            ordered-by user;
            type string {
              tailf:info "WORD;;IP prefix-list name";
            }
          }
        }
      }

      // route-map * / match ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";

        // route-map * / match ipv6 address
        container address {
          tailf:info "Match address of route";

          // route-map * / match ipv6 address
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../prefix-list" {
              tailf:cli-trigger-on-set;
            }
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 address prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:cli-remove-before-change;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../access-list" {
              tailf:cli-trigger-on-set;
            }
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }

        // route-map * / match ipv6 next-hop
        container next-hop {
          tailf:info "Match next-hop address of route";

          // route-map * / match ipv6 next-hop ?
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 next-hop prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }

        // route-map * / match ipv6 route-source
        container route-source {
          tailf:info "Match advertising source address of route";

          // route-map * / match ipv6 route-source ?
          leaf access-list {
            tailf:cli-drop-node-name;
            tailf:cli-disallow-value "prefix-list";
            type string {
              tailf:info "WORD;;IPv6 access-list name";
            }
          }

          // route-map * / match ipv6 route-source prefix-list
          leaf prefix-list {
            tailf:info "IPv6 prefix-list";
            tailf:non-strict-leafref {
              path "../../../../../ipv6/prefix-list/prefixes/name";
            }
            type string {
              tailf:info "WORD;;Name of a IPv6 prefix list";
            }
          }
        }
      }

      // route-map * / match community *
      leaf-list community {
        tailf:info "Match BGP community list";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Community-list number or name";
        }
      }

      // route-map * / match extcommunity *
      leaf-list extcommunity {
        tailf:info "Match BGP/VPN extended community list";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Community-list number or name";
        }
      }

      // route-map * / match tag *
      leaf-list tag {
        tailf:info "Match tag of route";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }

      // route-map * / match clns address *
      container clns {
        tailf:info "CLNS information";
        leaf-list address {
          tailf:info "Match address of route or match packet";
          tailf:cli-flat-list-syntax;
          type string {
            tailf:info "WORD;;OSI filter set";
          }
        }
      }

      // route-map * / match interface *
      leaf-list interface {
        tailf:info "Match first hop interface of route";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // route-map * / match source-protocol *
      leaf-list source-protocol {
        tailf:info "Match source-protocol of route";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type union {
          type enumeration {
            enum bgp {
              tailf:info "Border Gateway Protocol (BGP)";
            }
            enum connected {
              tailf:info "Connected";
            }
            enum eigrp {
              tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
            }
            enum isis {
              tailf:info "ISO IS-IS";
            }
            enum lisp {
              tailf:info "Locator ID Separation Protocol (LISP)";
            }
            enum mobile {
              tailf:info "Mobile routes";
            }
            enum ospf {
              tailf:info "Open Shortest Path First (OSPF)";
            }
            enum ospfv3 {
              tailf:info "OSPFv3";
            }
            enum rip {
              tailf:info "Routing Information Protocol (RIP)";
            }
            enum static {
              tailf:info "Static routes";
            }
          }
          type string {
            tailf:info "WORD;;Router id, e.g. AS number, process id etc.";
          }
        }
      }

      // route-map * / match route-type *
      list route-type {
        tailf:info "Match route-type of route";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key tag;
        leaf tag {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;external|internal|level-1|level-2|local|nssa-external|type-1|type-2";
          }
        }
      }

      // route-map * / match local-preference
      leaf-list local-preference {
        tailf:info "Local preference for route";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type uint32 {
          tailf:info "<0-4294967295>;;Local preference value";
        }
      }
    }

    // Routex-map * / set
    container set {
      tailf:info "Set values in destination routing protocol";

      // route-map * / set global
      leaf global {
        tailf:info "Set to global routing table";
        tailf:cli-full-command;
        type empty;
      }

      // route-map * / set as-path
      container as-path {
        tailf:info "Prepend string for a BGP AS-path attribute";

        // route-map * / set as-path prepend
        container prepend {
          tailf:info "Prepend to the as-path";

          // route-map * / set as-path prepend *
          leaf as-list {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "<1-4294967295>|<1-65535>[.<0-65535>];;AS number";
              pattern '(([0-9]+\.)?([0-9]+) )*(([0-9]+\.)?([0-9]+))';
            }
          }

          // route-map * / set as-path prepend last-as
          leaf last-as {
            tailf:info "Prepend last AS to the as-path";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1..10>;;number of last-AS prepends";
              range "1..10";
            }
          }
        }

        container tag {
          tailf:info "Set the tag as an AS-path attribute";
          tailf:cli-full-command;
          presence true;
        }
      }

      // route-map * / set comm-list
      container comm-list {
        tailf:info "set BGP community list (for deletion)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint16 {
              tailf:info "<1-99>;;Community-list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Community-list number (expanded)";
              range "100..500";
            }
            type string {
              tailf:info "WORD;;Community-list name";
            }
          }
        }
        leaf delete {
          tailf:info "Delete matching communities";
          type empty;
        }
      }

      // route-map * / set community
      container community {
        tailf:info "BGP community attribute";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice set-community-choice {
          // route-map * / set community none
          leaf none {
            tailf:info "No community attribute";
            tailf:cli-full-command;
            type empty;
          }
          leaf-list community-number {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            ordered-by user;
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;community number";
                range "1..4294967295";
              }
              type string {
                tailf:info "aa:nn;;community number in aa:nn format";
                pattern "[0-9]+:[0-9]+";
              }
              type enumeration {
                enum additive {
                  tailf:info "Add to the existing community";
                }
                enum internet {
                  tailf:info "Internet (well-known community)";
                }
                enum local-AS {
                  tailf:info "Do not send outside local AS "
                    +"(well-known community)";
                }
                enum no-advertise {
                  tailf:info "Do not advertise to any peer "
                    +"(well-known community)";
                }
                enum no-export {
                  tailf:info "Do not export to next AS "
                    +"(well-known community)";
                }
              }
            }
          }
        }
      }

      // route-map * / set extcomm-list
      container extcomm-list {
        tailf:info "Set BGP/VPN extended community list (for deletion)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint16 {
              tailf:info "<1-99>;;Extended community-list number (standard)";
              range "1..99";
            }
            type uint16 {
              tailf:info "<100-500>;;Extended community-list number (expanded)";
              range "100..500";
            }
            type string {
              tailf:info "WORD;;extcommunity-list name";
            }
          }
        }
        leaf delete {
          tailf:info "Delete matching extended communities";
          type empty;
        }
      }

      // route-map * / set extcommunity
      container extcommunity {
        tailf:info "BGP extended community attribute";
        tailf:cli-compact-syntax;

        // route-map * / set extcommunity rt
        leaf-list rt {
          tailf:info "Route Target extended community";
          tailf:cli-flat-list-syntax;
          ordered-by user;
          type union {
            type asn-ip-type {
              tailf:info "ASN:nn or IP-address:nn;;VPN extended community";
            }
            type enumeration {
              enum "range" {
                tailf:info "Specify a range of extended community";
              }
              enum "additive" {
                tailf:info "Add to the existing community";
              }
            }
          }
        }
      }

      // route-map * / set ip
      container ip {
        tailf:info "IP specific information";

        // route-map * / set ip next-hop
        container next-hop {
          tailf:info "Next hop address";

          // route-map * / set ip next-hop self
          leaf self {
            tailf:info "Use self address (for BGP only)";
            type empty;
          }

          // route-map * / set ip next-hop verify-availability *
          container verify-availability-conf {
            tailf:cli-drop-node-name;
            list verify-availability {
              tailf:info "Verify if nexthop is reachable";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-incomplete-command;
              key address;
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of next hop";
                }
              }
              leaf sequence {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Sequence to insert into next-hop list";
                  range "1..65535";
                }
              }
              leaf track {
                tailf:info "set the next hop depending on the state of a tracked object";
                type uint16 {
                  tailf:info "<1-1000>;;tracked object number";
                  range "1..1000";
                }
              }
            }
          }

          // route-map * / set ip next-hop peer-address
          leaf peer-address {
            tailf:info "Use peer address (for BGP only)";
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../address" {
              tailf:cli-trigger-on-set;
            }
            type empty;
          }

          // route-map * / set ip next-hop *
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            tailf:cli-full-command;
            tailf:cli-diff-dependency "../peer-address" {
              tailf:cli-trigger-on-set;
            }
            ordered-by user;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP address of next hop";
            }
          }

          // route-map * / set ip next-hop verify-availability
          leaf verify-availability {
            tailf:info "Verify if nexthop is reachable";
            tailf:cli-full-command;
            type empty;
          }

          // route-map * / set ip next-hop dynamic
          container dynamic {
            tailf:info "application dynamically sets next hop";
            leaf dhcp {
              tailf:info "DHCP learned next hop";
              type empty;
            }
          }

          // route-map * / set ip next-hop recursive
          container recursive {
            tailf:info "Recursive next-hop";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            choice global-or-vrf-choice {
              leaf global {
                tailf:info "global routing table";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type empty;
              }
              leaf vrf {
                tailf:info "VRF name";
                tailf:cli-optional-in-sequence;
                tailf:cli-incomplete-command;
                type string {
                  tailf:info "WORD;;VRF name";
                }
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address of recursive next hop";
              }
            }
          }

          // route-map * / set ip next-hop encapsulate
          container encapsulate {
            tailf:info "Encapsulation profile for VPN nexthop";
            leaf l3vpn {
              tailf:info "L3VPN";
              type string {
                tailf:info "WORD;;Encapsulation profile name";
              }
            }
          }
        }

        // route-map * / set ip df
        container df {
          tailf:info "Set DF bit";
          tailf:cli-delete-when-empty;
          presence true;
          leaf "bit" {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-1>;;DF bit";
              range "0..1";
            }
          }
        }

        // route-map * / set ip precedence
        leaf precedence {
          tailf:info "Set precedence field";
          tailf:cli-full-command;
          type precedence-type;
        }

        // route-map * / set ip qos-group
        leaf qos-group {
          tailf:info "Set QOS Group ID";
          type uint8 {
            tailf:info "<0-99>;;QOS Group ID";
            range "0..99";
          }
        }
      }

      // route-map * / set ipv6
      container ipv6 {
        tailf:info "IPv6 specific information";

        // route-map * / set ipv6 next-hop
        container next-hop {
          tailf:info "IPv6 Next hop";
          choice next-hop-choice {
            leaf-list address {
              tailf:cli-drop-node-name;
              tailf:cli-flat-list-syntax;
              type inet:ipv6-address {
                tailf:info "X:X:X:X::X;;Next hop address";
              }
            }
            leaf peer-address {
              tailf:info "Use peer address (for BGP only)";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
      }

      // route-map * / set local-preference
      container local-preference {
        tailf:info "BGP local preference path attribute";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "value" {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Preference value";
          }
        }
      }

      // route-map * / set metric
      leaf-list metric {
        tailf:info "Metric value for destination routing protocol";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type string {
          tailf:info "+/-<metric>;;Add or subtract metric
          <0-4294967295>;;Metric value or Bandwidth in Kbits per second";
          pattern '[+-]?[0-9]*';
        }
      }

      // route-map * / set metric-type
      leaf metric-type {
        tailf:info "Type of metric for destination routing protocol";
        type enumeration {
          enum external {
            tailf:info "IS-IS external metric";
          }
          enum internal {
            tailf:info "IS-IS internal metric or Use IGP metric "
            +"as the MED for BGP";
          }
          enum type-1 {
            tailf:info "OSPF external type 1 metric";
          }
          enum type-2 {
            tailf:info "OSPF external type 2 metric";
          }
        }
      }

      // route-map * / set weight
      leaf weight {
        tailf:info "BGP weight for routing table";
        type uint32 {
          tailf:info "<0-65535>;;Weight value";
          range "0..65535";
        }
      }

      // route-map * / set origin
      container origin {
        tailf:info "BGP origin code";
        choice origin-choice {
          leaf origin-value {
            tailf:cli-drop-node-name;
            type enumeration {
              enum igp {
                tailf:info "local IGP";
              }
              enum incomplete {
                tailf:info "unknown heritage";
              }
            }
          }
          leaf egp {
            tailf:info "remote EGP";
            type uint32 {
              tailf:info "<0-65535>;;remote AS";
              range "0..65535";
            }
          }
        }
      }

      // route-map * / set vrf
      leaf vrf {
        tailf:info "Define VRF name";
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }

      // route-map * / set tag
      leaf tag {
        tailf:info "Tag value for destination routing protocol";
        type uint32 {
          tailf:info "<0-4294967295>;;Tag value";
        }
      }

      // route-map * / set mpls-label
      leaf mpls-label {
        tailf:info "Set MPLS label for prefix";
        type empty;
      }

      // route-map * / set interface
      leaf-list interface {
        tailf:info "Output interface";
        tailf:cli-flat-list-syntax;
        ordered-by user;
        type string {
          tailf:info "WORD;;Interface name";
        }
      }

      // route-map * / set default interface
      container "default" {
        tailf:info "Set default information";
        container interface {
          tailf:info "Default output interface";
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }

    // route-map * / continue
    container "continue" {
      tailf:info "Continue on a different entry within the route-map";
      tailf:cli-delete-when-empty;
      presence true;
      leaf sequence-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-65535>;;Route-map entry sequence number";
        }
      }
    }
  }


  /// ========================================================================
  /// dialer
  /// ========================================================================

  container dialer {
    tailf:info "Dialer commands";

    // dialer watch-list *
    list watch-list {
      tailf:info "Dialer watch list";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-255>;;Dialer watch group number";
          range "1..255";
        }
      }

      // dialer watch-list * ip *
      list ip {
        tailf:info "IP";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Protocol specific address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          tailf:cli-no-value-on-delete;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }

      // dialer watch-list * delay
      container delay {
        tailf:info "Dialer watch delay";
        // dialer watch-list * delay route-check
        container route-check {
          tailf:info "Interval for checking watched route";
          leaf initial {
            tailf:info "Delay for initial check of watched route after boot";
            type uint32 {
              tailf:info "<1-2147483>;;Delay time in seconds";
            }
          }
        }
        // dialer watch-list * delay connect
        leaf connect {
          tailf:info "Interval before dialing the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }
        // dialer watch-list * delay disconnect
        leaf disconnect {
          tailf:info "Interval before disconnecting the secondary route";
          type uint32 {
            tailf:info "<1-2147483>;;Delay time in seconds";
            range "1..2147483";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dialer-list
  /// ========================================================================

  list dialer-list {
    tailf:info "Create a dialer list entry";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key id;
    leaf id {
      type uint16 {
        tailf:info "<1-128>;;Dialer group number";
      }
    }
    container protocol {
      tailf:info "Permit or Deny based on protocols";
      leaf ip {
        tailf:info "IP";
        type enumeration {
          enum deny {
            tailf:info "Deny specified protocol";
          }
          enum "list" {
            tailf:info "Add access list to dialer list";
          }
          enum permit {
            tailf:info "Permit specified protocol";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// authentication
  /// ========================================================================

  container authentication {
    tailf:info "Auth Manager Global Configuration Commands";

    // authentication mac-move
    container mac-move {
      leaf permit {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// banner
  /// ========================================================================

  container banner {
    tailf:info "Define a login banner";

    // banner exec
    leaf exec {
      tailf:info "Set EXEC process creation banner. ";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner login
    leaf login {
      tailf:info "Set login banner.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner lcd
    leaf lcd {
      tailf:info "Set Message for LCD banner";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner prompt-timeout
    leaf prompt-timeout {
      tailf:info "Set Message for login authentication timeout.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // banner motd
    leaf motd {
      tailf:info "Set Message of the Day banner.";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted string. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }
  }


  /// ========================================================================
  /// pseudowire-class
  /// ========================================================================

  list pseudowire-class {
    tailf:info "Pseudowire-class configuration";
    tailf:cli-mode-name "config-pw-class";
    tailf:cli-full-command;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Pseudowire-class name";
      }
    }

    // pseudowire-class * / encapsulation
    leaf encapsulation {
      tailf:info "Data encapsulation method";
      type enumeration {
        enum l2tpv2 {
          tailf:info "Use L2TPv2 encapsulation";
        }
        enum l2tpv3 {
          tailf:info "Use L2TPv3 encapsulation";
        }
        enum mpls {
          tailf:info "Use MPLS encapsulation";
        }
      }
    }

    // pseudowire-class * / interworking
    leaf interworking {
      tailf:info "Interworking options for pseudowire";
      tailf:cli-full-command;
      type enumeration {
        enum ethernet {
          tailf:info "Ethernet interworking";
        }
        enum ip {
          tailf:info "IP interworking";
        }
        enum vlan {
          tailf:info "VLAN interworking";
        }
      }
    }

    // pseudowire-class * / control-word
    leaf control-word {
      tailf:info "Include control-word in pseudowire packets";
      type empty;
    }

    // pseudowire-class * / sequencing
    container sequencing {
      tailf:info "Sequencing options for pseudowire";
      choice sequencing-choice {
        leaf both {
          tailf:info "Transmit and receive sequence numbers";
          type empty;
        }
        leaf receive {
          tailf:info "Receive sequence numbers";
          type empty;
        }
        container resync {
          tailf:info "Enable Rx sequencing out-of-order detection/recovery";
          presence true;
        }
        leaf transmit {
          tailf:info "Transmit sequence numbers";
          type empty;
        }
      }
    }

    // pseudowire-class * / status
    container "status" {
      tailf:info "Pseudowire status capabilities";
      container peer {
        tailf:info "peer status configuration";
        container topology {
          tailf:info "change status behaviour based on peer topology";
          leaf dual-homed {
            tailf:info "Our peer(s) are participating in a redundant "+
              "solution with some form of redundancy protocol running"+
              " between the peer routers";
            type empty;
          }
        }
      }
    }

    // pseudowire-class * / protocol
    container protocol {
      tailf:info "Signaling protocol to use";
      choice protocol-choice {
        leaf none {
          tailf:info "No signaling, use manually configured sessions";
          type empty;
        }
        leaf l2tpv3 {
          tailf:info "Use L2TPv3 signaling";
          tailf:non-strict-leafref {
            path "../../../l2tp-class/l2tp-class-name";
          }
          type string {
            tailf:info "WORD;;l2tp-class name";
          }
        }
      }
    }

    // pseudowire-class * / ip
    container ip {
      tailf:info "Specify IP parameters";

      // pseudowire-class * / ip local interface
      container local {
        tailf:info "Specify local information";
        container interface {
          tailf:info "Source interface for pseudowire";
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }
  }


  /// ========================================================================
  /// control-plane
  /// ========================================================================

  // control-plane host
  container control-plane-host {
    tailf:cli-drop-node-name;
    container control-plane {
      tailf:info "Configure control plane services";
      container host {
        tailf:info "Host traffic control-plane configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-cp-host";
        presence true;

        // control-plane host / management-interface *
        list management-interface {
          tailf:info "Configure interface for receiving network management traffic";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          tailf:cli-diff-dependency "../../../../interface";
          key interface;
          leaf interface {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf-list allow {
            tailf:info "Allowed network management protocols on selected interface";
            tailf:cli-flat-list-syntax;
            type enumeration {
              enum  beep {
                tailf:info "Beep Protocol";
              }
              enum ftp {
                tailf:info "File Transfer Protocol";
              }
              enum http {
                tailf:info "HTTP Protocol";
              }
              enum https {
                tailf:info "HTTPS Protocol";
              }
              enum snmp {
                tailf:info "Simple Network Management Protocol";
              }
              enum ssh {
                tailf:info "Secure Shell Protocol";
              }
              enum telnet {
                tailf:info "Telnet Protocol";
              }
              enum tftp {
                tailf:info "Trivial File Transfer Protocol";
              }
              enum tl1 {
                tailf:info "Transaction Language Session Protocol";
              }
            }
          }
        }
      }
    }
  }

  // control-plane
  container control-plane {
    tailf:info "Configure control plane services";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-cp";
    presence true;

    // control-plane service-policy
    container service-policy {
      tailf:info "Configure QOS Service Policy";
      uses service-policy-grouping;
    }
  }


  /// ========================================================================
  /// cops
  /// ========================================================================

  container cops {
    tailf:info "Common Open Policy Service (COPS)";

    // cops listener access-list
    container listener {
      tailf:info "Incoming connections from policy decision points (PDPs)";
      leaf access-list {
        tailf:info "Rules for PDPs connecting to local COPS listeners";
        type exp-ip-acl-type;
      }
    }

    // cops ip dscp
    container ip {
      tailf:info "IP parameters for COPS connections";
      leaf dscp {
        tailf:info "Differentiated Services Code Point marking for "+
          "COPS messages";
        type dscp-type;
      }
    }
  }


  /// ========================================================================
  /// connect
  /// ========================================================================

  list connect {
    tailf:info "cross-connect two interfaces";
    tailf:cli-mode-name "config-connection";
    tailf:cli-compact-syntax;
    tailf:cli-sequence-commands;

    key "interface1 interface2";
    leaf name {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key;
      //must "../../ip/cef" {
      //error-message "Please enable CEF before configuring connect";
      //tailf:dependency "../../ip/cef";
      //}
      type string {
        tailf:info "WORD;;Name for this connection";
      }
    }
    leaf interface1 {
      type string {
        tailf:info "WORD;;First interface name";
      }
    }
    leaf number1 {
      tailf:cli-drop-node-name;
      tailf:cli-prefix-key {
        tailf:cli-before-key 2;
      }
      tailf:cli-optional-in-sequence;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }
    leaf interface2 {
      type string {
        tailf:info "WORD;;Second interface name";
      }
    }
    leaf number2 {
      tailf:cli-drop-node-name;
      tailf:cli-hide-in-submode;
      type uint16 {
        tailf:info "<1-8184>;;Service Instance Identifier";
        range "1..8184";
      }
    }

    // connect * / backup
    container backup {
      tailf:cli-break-sequence-commands;
      tailf:info "Xconnect backup configuration commands";

      // connect * / backup peer
      container peer {
        tailf:info "Backup pseudowire";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf peer-router-ip-addr {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address of peer";
          }
        }
        leaf vcid {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Peer VC ID value";
            range "1..4294967295";
          }
        }
        leaf pw-class {
          tailf:cli-optional-in-sequence;
          tailf:non-strict-leafref {
            path "../../../../pseudowire-class/name";
          }
          type string {
            tailf:info "Optional Pseudowire-class to use for "+
              "backup pseudowire";
          }
        }
      }
    }

    // connect * / xconnect
    uses xconnect-grouping;
  }


  /// ========================================================================
  /// voice-port
  /// ========================================================================

  list voice-port {
    tailf:info "Configure a specific voice-port";
    tailf:cli-mode-name "config-voiceport";
    key name;
    leaf name {
      type string {
        tailf:info "<0-0>;;Voice interface slot #";
      }
    }

    // voice-port * / timeouts
    container timeouts {
      tailf:info "Configure voice timeout parameters";
      leaf interdigit {
        tailf:info "Interdigit Timeout duration in seconds";
        type uint8 {
          tailf:info "<0-120>;;seconds";
          range "0..120";
        }
      }
    }

    leaf shutdown {
      //FIXME: config not found on device
      tailf:cli-full-command;
      type empty;
    }

    // voice-port * / busyout
    container busyout {
      tailf:info "Configure busyout trigger event & procedure";

      leaf action {
        //FIXME: config not found on device
        tailf:cli-full-command;
        type string;
      }

      // voice-port * / busyout monitor
      container monitor {
        tailf:info "The event of this interface triggers busyout";

        // voice-port * / busyout monitor action<
        container action {
          tailf:info "busyout action when monitoring triggered";
          choice action-choice {
            leaf graceful {
              tailf:info "graceful busyout when monitoring triggered";
              type empty;
            }
            leaf shutdown {
              tailf:info "shutdown D channel when monitoring triggered";
              type empty;
            }
            container alarm {
              tailf:info "Use alarm generation";
              leaf blue {
                tailf:info "Use blue alarm";
                type empty;
              }
            }
          }
        }

        // voice-port * / busyout monitor *
        list state {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface name";
            }
          }
          leaf in-service {
            tailf:info "Inverted logic trigger by interface "+
              "back up or in service";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dial-peer
  /// ========================================================================

  container dial-peer {
    tailf:info "Dial Map (Peer) configuration commands";

    // dial-peer voice *
    list voice {
      tailf:info "Voice type";
      tailf:cli-mode-name "config-dial-peer";
      tailf:cli-incomplete-command;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type uint32 {
          tailf:info "<1-2147483647>;;Voice dial-peer tag";
          range "1..2147483647";
        }
      }
      leaf peer {
        tailf:cli-drop-node-name;
        tailf:cli-hide-in-submode;
        type enumeration {
          enum mmoip {
            tailf:info "Multi Media Over IP";
          }
          enum pots {
            tailf:info "Telephony";
          }
          enum voatm {
            tailf:info "Voice over ATM";
          }
          enum vofr {
            tailf:info "Voice over Frame Relay";
          }
          enum voip {
            tailf:info "Voice over IP";
          }
        }
      }

      // dial-peer voice * / answer-address
      leaf answer-address {
        tailf:cli-break-sequence-commands;
        tailf:info "The Call Destination Number";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A string of digits including wild cards";
        }
      }

      // dial-peer voice * / trunkgroup
      leaf trunkgroup {
        tailf:info "trunk groups associated with this peer";
        tailf:non-strict-leafref {
          path "../../../trunk/group/name";
        }
        type string {
          tailf:info "WORD;;trunkgroup id";
        }
      }

      // dial-peer voice * / description
      leaf "description" {
        tailf:info "Dialpeer specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 64 characters describing this dialpeer";
          length "1..64";
        }
      }

      // dial-peer voice * / translation-profile
      container translation-profile {
        tailf:info "Translation profile";
        leaf incoming {
          tailf:info "Translation Profile for incoming call leg";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
        leaf outgoing {
          tailf:info "Translation Profile for outgoing call leg";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }

      // dial-peer voice * / huntstop
      leaf huntstop {
        tailf:info "Stop hunting on Dial-Peers";
        tailf:cli-full-command;
        type empty;
      }

      // dial-peer voice * / max-conn
      leaf max-conn {
        tailf:info "Sets the maximum connections per peer, "+
          "negation sets to unlimited";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-2147483647>;;Maximum connections, "+
            "negation sets to unlimited";
        }
      }

      // dial-peer voice * / destination-pattern
      leaf destination-pattern {
        tailf:info "A full E.164 telephone number prefix";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;A sequence of digits - "+
            "representing the prefix or full telephone number";
        }
      }

      // dial-peer voice * / modem passthrough
      container modem {
        tailf:info "Modem commands through this peer";
        container passthrough {
          tailf:info "Pass modem traffic via clear channel";
          choice passthrough-choice {
            // dial-peer voice * / no modem passthrough system
            leaf system {
              tailf:info "Use global configuration";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
            container nse {
              tailf:info "Use Named Signaling Events (NSE)";
              tailf:cli-compact-syntax;
              leaf payload-type {
                tailf:info "Configure NSE payload type";
                type uint32 {
                  tailf:info "<98-117>;;Payload type value";
                }
              }
              leaf codec {
                tailf:info "Codec selections for upspeed";
                type enumeration {
                  enum g711ulaw {
                    tailf:info "G.711 u Law 64000 bp";
                  }
                  enum g711alaw {
                    tailf:info "G.711 A Law 64000 bps";
                  }
                }
              }
              leaf redundancy {
                tailf:info "Use Packet Redundancy (RFC2198) for modem traffic";
                type empty;
              }
            }
          }
        }
      }

      // dial-peer voice * / session
      container session {
        tailf:info "The session [ target | protocol | transport ]"+
          " for this peer";
        leaf protocol {
          tailf:info "The session protocol to be used in getting to this peer";
          type enumeration {
            enum aal2-trunk {}
            enum cisco {
              tailf:info "Cisco Session Protocol";
            }
            enum sipv2 {
              tailf:info "IETF Session Initiation Protocol";
            }
            enum smtp {}
            enum multicast {
              tailf:info "Multicast Session Protocol(voice conferencing)";
            }
          }
        }
        leaf target {
          tailf:info "The session target for this peer";
          tailf:cli-multi-value;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;A string specifying the session target";
          }
        }
      }

      // dial-peer voice * / dtmf-relay
      container dtmf-relay {
        tailf:info "Transport DTMF digits across IP link. "+
          "Enter DTMF Relay options in order of preference.";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf cisco-rtp {
          tailf:info "Cisco Proprietary RTP";
          type empty;
        }
        leaf h245-alphanumeric {
          tailf:info "DTMF Relay via H245 Alphanumeric IE";
          type empty;
        }
        leaf h245-signal {
          tailf:info "DTMF Relay via H245 Signal IE";
          type empty;
        }
        leaf rtp-nte {
          tailf:info "RTP Named Telephone Event RFC 2833";
          type empty;
        }
      }

      // dial-peer voice * / incoming called-number
      container incoming {
        tailf:info "Incoming called number";
        leaf called-number {
          tailf:info "An incoming called number pattern";
          type string {
            tailf:info "WORD;;A sequence of digits "+
              "representing a phone number prefix";
          }
        }
      }

      // dial-peer voice * / direct-inward-dial
      leaf direct-inward-dial {
        type empty;
      }

      // dial-peer voice * / forward-digits
      leaf forward-digits {
        type union {
          type uint8 {
          }
          type enumeration {
            enum all {}
            enum extra {}
          }
        }
      }

      // dial-peer voice * / codec
      container codec {
        tailf:info "The codec rate to be attempted in getting to this peer";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Codec name";
          }
        }
        leaf bytes {
          tailf:info "Specify number of voice data bytes per frame";
          tailf:cli-break-sequence-commands;
          type uint32;
        }
        leaf mode {
          tailf:info "Specify the value of the mode";
          type uint32 {
            tailf:info "20 = 15.2 kbps, 30 = 13.33 kbps";
          }
        }
      }

      // dial-peer voice * / fax protocol
      container fax {
        tailf:info "Configure fax";
        container protocol {
          tailf:info "The fax protocol to be attempted in getting "+
            "to this peer";
          choice protocol-option {
            leaf none {
              tailf:info "No FAX protocol";
              type empty;
            }
            leaf cisco {
              tailf:info "Use Cisco proprietary protocol";
              type empty;
            }
            leaf pass-through {
              tailf:info "Use an audio codec for fax transport";
              type enumeration {
                enum g711ulaw {
                  tailf:info "G.711 u Law 64000 bps (for T1)";
                }
                enum g711alaw {
                  tailf:info "G.711 A Law 64000 bps (for E1)";
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / ip qos dscp *
      container ip {
        tailf:info "Set ip packet options";
        container qos {
          tailf:info "Set ip QoS Parameters";
          list dscp {
            tailf:info "Specify ip DSCP";
            tailf:cli-compact-syntax;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              // number | set-af | set-cs | default | ef
              type string {
                tailf:info "WORD;;voice set";
              }
            }
            choice dscp-choice {
              leaf media {
                tailf:info "Apply DSCP to media payload packets";
                type empty;
              }
              leaf signaling {
                tailf:info "Apply DSCP to signaling packets";
                type empty;
              }
              leaf video {
                tailf:info "Apply DSCP to video packets";
                type enumeration {
                  enum rsvp-none {
                    tailf:info "Use this DSCP value if RSVP "+
                      "is not configured";
                  }
                  enum rsvp-pass {
                    tailf:info "Use this DSCP value if RSVP "+
                      "reservation is successful";
                  }
                  enum rsvp-fail {
                    tailf:info "Use this DSCP value if RSVP "+
                      "reservation fails";
                  }
                }
              }
            }
          }
        }
      }

      // dial-peer voice * / no vad
      leaf vad {
        tailf:info "Use VoiceActivityDetection as necessary option";
        tailf:cli-full-command;
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // no dial-peer outbound status-check pots
    container outbound {
      tailf:info "Define the outbound options";
      container status-check {
        tailf:info "Enable or disable status checking";
        leaf pots {
          tailf:info "Telephony";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // dial-peer cor custom
    container cor {
      container custom {
        tailf:cli-add-mode;
        presence true;
        // dial-peer cor custom / name *
        list name {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// config-register
  /// ========================================================================

  leaf config-register {
    tailf:info "Define the configuration register";
    type string {
      tailf:info "<0x0-0xFFFF>;;Config register number";
      pattern "[0-9xXa-fA-F].*";
    }
  }


  /// ========================================================================
  /// network-clock-participate
  /// ========================================================================

  container network-clock-participate {
    tailf:info "Participate in Network Clocking";

    // network-clock-participate wic *
    container wic {
      tailf:info "WIC Module";
      list wic-enabled {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
      list wic-disabled {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key slot;
        leaf slot {
          type uint8 {
            tailf:info "<0-3>;;Slot Number (physical)";
            range "0..3";
          }
        }
      }
    }

    // network-clock-participate T1 *
    list T1 {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          pattern '[0-9]+.*';
        }
      }
    }
  }


  /// ========================================================================
  /// service-routing
  /// ========================================================================

  container service-routing {
    tailf:info "Configure service-routing";

    // no service-routing capabilities-manager
    leaf capabilities-manager {
      tailf:info "Service-Routing Capabilities Manager configuration";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// mgcp
  /// ========================================================================

  container mgcp {
    tailf:info "Enable Media Gateway Control Protocol";

    // mgcp fax t38 ecm
    container fax {
      tailf:info "Configure MGCP Fax Parameters";
      container t38 {
        tailf:info "Configure MGCP Fax T.38 Parameters";
        leaf ecm {
          tailf:info "Enable Error Correction Mode (ECM)";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mgcp behavior *
    list behavior {
      tailf:info "Set MGCP message behavior";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key category;
      leaf category {
        type string {
          tailf:info "WORD;;Set the category for this behavior";
        }
      }
      leaf version {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Set the version for this behavior category";
        }
      }
    }

    // mgcp profile *
    list profile {
      tailf:info "MGCP profile configuration mode";
      tailf:cli-mode-name "config-mgcp-profile";
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type union {
          type enumeration {
            enum "default" {
              tailf:info "Configure MGCP default profile";
            }
          }
          type string {
            tailf:info "Enter the name(is limited to 32 characters) "+
              "of the profile";
            length "0..32";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// gatekeeper
  /// ========================================================================

  container gatekeeper {
    tailf:info "Enter gatekeeper configuration mode";
    tailf:cli-add-mode;
    tailf:cli-mode-name "config-gk";

    // gatekeeper shutdown
    leaf shutdown {
      tailf:info "Shutdown Gatekeeper";
      type empty;
    }
  }


  /// ========================================================================
  /// parser
  /// ========================================================================

  container parser {
    tailf:info "Configure parser";

    // no parser cache
    leaf cache {
      tailf:info "Configure parser cache";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// line
  /// ========================================================================

  container line {
    tailf:info "Configure a terminal line";

    // line con(sole) 0
    list console {
      tailf:info "Primary terminal line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line aux 0
    list aux {
      tailf:info "Auxiliary line";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      max-elements 1;
      leaf first {
        type enumeration {
          enum "0" {
            tailf:info "<0-0>;;First Line number";
          }
        }
      }
      uses line-grouping;
    }

    // line vty *
    container vty-single-conf {
      tailf:cli-drop-node-name;
      list vty {
        tailf:info "Virtual terminal";
        tailf:cli-full-command;
        tailf:cli-mode-name "config-line";
        key first;
        leaf first {
          type uint16 {
            tailf:info "<0-1869>;;First Line number";
            range "0..1869";
          }
        }
        uses line-grouping;
      }
    }

    // line vty * *
    list vty {
      tailf:info "Virtual terminal";
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key "first last";
      leaf first {
        type uint16 {
          tailf:info "<0-1869>;;First Line number";
          range "0..1869";
        }
      }
      leaf last {
        type uint16 {
          tailf:info "<1-1869>;;Last Line number";
          range "1..1869";
        }
      }
      uses line-grouping;
    }

    // line *
    list number-single-list {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key first;
      leaf first {
        tailf:cli-suppress-range;
        tailf:cli-disallow-value "con|console|aux|vty";
        type string {
          tailf:info "Line number";
        }
      }
      uses line-grouping;
    }

    // line * *
    list number-list {
      tailf:cli-drop-node-name;
      tailf:cli-full-command;
      tailf:cli-mode-name "config-line";
      key "first last";
      leaf first {
        type string {
          tailf:info "WORD;;First Line id";
        }
      }
      leaf last {
        type string {
          tailf:info "WORD;;Last Line id";
        }
      }
      uses line-grouping;
    }

  }


  /// ========================================================================
  /// exception
  /// ========================================================================

  container exception {
    tailf:info "Exception handling";

    // exception data-corruption buffer
    container data-corruption {
      tailf:info "Data error exception handling";
      container buffer {
        tailf:info "Set buffer corruption behavior";

        // exception data-corruption buffer truncate
        leaf truncate {
          tailf:info "Truncate buffer overwrites";
          type empty;
        }
      }
    }

    // exception crashinfo
    container crashinfo {
      tailf:info "Crashinfo collection";

      // exception crashinfo file
      leaf file {
        tailf:info "crashinfo file name in bootflash or PCMCIA slot";
        type string {
          tailf:info "<WORD>;;device:file name (up to 38 characters)";
        }
      }

      // exception crashinfo buffersize
      leaf buffersize {
        tailf:info "crashinfo log buffer size";
        type uint16 {
          tailf:info "<32-256>;;buffer size in Kbytes 256K or less "+
            "(default is 32K)";
          range "32..256";
        }
      }
    }
  }

  /// ========================================================================
  /// pnp
  /// ========================================================================

  container pnp {
    tailf:info "Configure PNP";

    // pnp profile *
    list profile {
      tailf:info "PNP profile";
      tailf:cli-mode-name "config-pnp-init";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;PNP Profile name";
        }
      }

      // pnp profile * / transport
      container transport {
        tailf:info "The transport to use";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        leaf protocol {
          tailf:cli-drop-node-name;
          type enumeration {
            enum http {
              tailf:info "Use http (plaintext) transport";
            }
            enum https {
              tailf:info "Use https (encrypted) transport";
            }
            enum xmpp {
              tailf:info "Use XMPP transport";
            }
          }
        }

        leaf over {
          tailf:cli-drop-node-name;
          when "../protocol = 'xmpp'" {
            tailf:dependency "../protocol";
          }
          type enumeration {
            enum socket {
              tailf:info "xmpp over plain socket (no encryption)";
            }
            enum starttls {
              tailf:info "xmpp starttls";
            }
            enum tls {
              tailf:info "xmpp over tls (encrypted)";
            }
          }
        }

        choice address-choice {
          leaf host {
            tailf:info "hostname of server";
            type inet:host {
              tailf:info "WORD;;Hostname of the server";
            }
          }
          leaf ipv4 {
            tailf:info "ipv4 address";
            type inet:ipv4-address {
              tailf:info "WORD;;IP address of the server";
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 address";
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;IPv6 address of server";
            }
          }
        }

        leaf port {
          tailf:info "port number";
          type uint16 {
            tailf:info "<1-65535>;;Port number to use";
          }
        }

        leaf vrf {
          tailf:info "Bind port to VRF";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;VRF name";
          }
        }

        container source {
          tailf:info "Bind port to interface";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }

        leaf localcert {
          tailf:info "Local certificate";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Trustpoint name";
          }
        }

        leaf remotecert {
          tailf:info "Remote certificate validation";
          type string {
            tailf:info "WORD;;Trustpoint name";
          }
        }
      }

      // pnp profile * / reconnect
      container reconnect {
        tailf:info "Pause to wait before reconnecting";
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-2000000>;;Pause in seconds";
            range "1..2000000";
          }
        }
      }
    }

    // pnp startup-vlan
    leaf startup-vlan {
      tailf:info "PNP startup-vlan";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "PNP vlan id;default vlan is 1";
        range "2..4094";
      }
    }

    // pnp tag
    leaf tag {
      tailf:info "PNP tag";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;PNP tag name";
      }
    }
  }


  /// ========================================================================
  /// onep
  /// ========================================================================

  container onep {
    tailf:info "ONEP functionality";
    tailf:cli-add-mode;

    // onep start
    leaf start {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
    }

    // onep transport tipc
    container transport {
      tailf:info "Transport type";
      container tipc {
        tailf:info "tipc transport";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// logging
  /// ========================================================================

  container logging {
    tailf:info "Modify message logging facilities";

    // logging discriminator *
    list discriminator {
      tailf:info "Create or modify a message discriminator";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key discr-name;
      leaf discr-name {
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }

      // logging discriminator * mnemonics
      container mnemonics {
        tailf:info "Mnemonics pattern for messsage filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice mnemonics-choice {
          leaf drops {
            tailf:info "To drop messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
          leaf includes {
            tailf:info "To deliver messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
        }
      }

      // logging discriminator * msg-body
      container msg-body {
        tailf:info "Msg-body pattern for messsage filtering";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        choice msg-body-choice {
          leaf drops {
            tailf:info "To drop messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
          leaf includes {
            tailf:info "To deliver messages including the specified regexp "+
              "string";
            type string {
              tailf:info "WORD;;Specify a regular expression string for "+
                "message filtering";
            }
          }
        }
      }
    }

    // logging cmts
    container cmts {
      tailf:info "CMTS config commands";
      container ipc-cable {
        tailf:info "Cable IPC config commands";
        // logging cmts ipc-cable log-level
        leaf log-level {
          tailf:info "cable ipc log level config commands";
          type logging-level-type;
        }
      }
      container sea {
        tailf:info "SEA config commands";
        // logging cmts sea syslog-level
        leaf syslog-level {
          tailf:info "Specify syslog loggging level";
          type logging-level-type;
        }
      }
    }

    // logging alarm
    leaf alarm {
      tailf:info "Configure syslog for alarms";
      tailf:cli-full-command;
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm Logging severity level";
          range "1..4";
        }
        type enumeration {
          enum critical {
            tailf:info "Service affecting Condition       (severity=1)";
          }
          enum informational {
            tailf:info "Informational messages            (severity=4)";
          }
          enum major {
            tailf:info "Immediate action needed           (severity=2)";
          }
          enum minor {
            tailf:info "Minor warning conditions          (severity=3)";
          }
        }
      }
    }

    // logging message-counter
    container message-counter {
      tailf:info "Configure log message to include certain counter value";

      // logging message-counter log
      leaf log {
        tailf:info "counter of accumulated logging messages received by logger";
        tailf:cli-full-command;
        type empty;
      }

      // logging message-counter debug
      leaf debug {
        tailf:info "counter of accumulated buginf messages received by logger";
        tailf:cli-full-command;
        type empty;
      }

      // no logging message-counter syslog
      leaf syslog {
        tailf:info "counter of current lines of syslog messages sent";
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
    }

    // logging buffered
    container buffered {
      tailf:info "Set buffered logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        when "not(../xxml)" {
          tailf:dependency "../xxml";
        }
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "../../../logging/discriminator/discr-name";
        }
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf buffer-size {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<4096-2147483647>;;Logging buffer size";
          range "4096..2147483647";
        }
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging persistent
    container persistent {
      tailf:info "Set persistent logging parameters";
      tailf:cli-compact-syntax;

      // logging persistent url
      leaf url {
        tailf:info "URL to store logging messages";
        type string {
          tailf:info "WORD;;Filesystem name";
        }
      }

      // logging persistent size
      leaf size {
        tailf:info "Set disk space for writing log messages";
        type uint32 {
          tailf:info "<16384-256503808>;;Logging filesystem size";
          range "16384..256503808";
        }
      }

      // logging persistent filesize
      leaf filesize {
        tailf:info "Set size of individual log files";
        type uint32 {
          tailf:info "<8192-256503808>;;Logging file size";
          range "8192..256503808";
        }
      }
    }

    // logging queue-limit
    container queue-limit {
      tailf:info "Set logger message queue size";
      leaf queuesize {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<100-2147483647>;;Set new queue size";
          range "100..2147483647";
        }
      }
    }

    // logging console
    // logging monitor
    grouping logging-common-grouping {
      leaf xxml {
        tailf:alt-name xml;
        tailf:info "Enable logging in XML to XML logging buffer";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf discriminator {
        when "not(../xxml)" {
          tailf:dependency "../xxml";
        }
        tailf:info "Establish MD-Console association";
        tailf:cli-optional-in-sequence;
        tailf:non-strict-leafref {
          path "../../../logging/discriminator/discr-name";
        }
        type string {
          tailf:info "WORD;;discriminator name; string; max. 8 characters";
        }
      }
      leaf filtered {
        tailf:info "Enable filtered logging";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging console
    container console {
      tailf:info "Set console logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses logging-common-grouping;
    }

    // logging monitor
    container monitor {
      tailf:info "Set terminal line (monitor) logging parameters";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      uses logging-common-grouping;
    }


    // logging snmp-trap
    container snmp-trap {
      tailf:info "Set syslog level for sending snmp trap";

      // logging snmp-trap emergencies
      leaf emergencies {
        tailf:info "System is not stable               (severity=0)";
        type empty;
      }

      // logging snmp-trap critical
      leaf critical {
        tailf:info "Critical conditions               (severity=2)";
        type empty;
      }

      // logging snmp-trap errors
      leaf errors {
        tailf:info "Error conditions                  (severity=3)";
        type empty;
      }

      // logging snmp-trap informational
      leaf informational {
        tailf:info "Informational messages            (severity=6)";
        type empty;
      }

      // logging snmp-trap alerts
      leaf alerts {
        tailf:info "Immediate action needed           (severity=1)";
        type empty;
      }

      // logging snmp-trap warnings
      leaf warnings {
        tailf:info "Warning conditions                (severity=4)";
        type empty;
      }

      // logging snmp-trap notifications
      leaf  notifications {
        tailf:info "Normal but significant conditions (severity=5)";
        type empty;
      }

      // logging snmp-trap debugging
      leaf debugging {
        tailf:info "Debugging messages                (severity=7)";
        type empty;
      }
    }

    // logging snmp-authfail
    leaf snmp-authfail {
      tailf:cli-full-command;
      type empty;
    }

    // logging event
    container event {
      tailf:info "Global interface events";

      // logging event link-status
      container link-status {
        tailf:info "Globally enable/disable link UPDOWN message";
        leaf boot {
          tailf:info "Supress/Allow link UPDOWN messages during boot";
          type empty;
        }
        leaf global {
          type empty;
        }
        leaf "default" {
          tailf:info "Link UPDOWN messages for all interfaces";
          type empty;
        }
      }

      // logging event trunk-status global
      container trunk-status {
        tailf:info "trunk status logging event";
        leaf global {
          tailf:info "global trunk status logging event";
          type empty;
        }
      }
    }

    // logging esm config
    container esm {
      tailf:info "Set ESM filter restrictions";
      leaf "config" {
        tailf:info "Permit/Deny configuration changes from ESM filters";
        type empty;
      }
    }

    // logging facility
    leaf facility {
      tailf:info "Facility parameter for syslog messages";
      tailf:cli-full-command;
      type enumeration {
        enum auth {
          tailf:info "Authorization system";
        }
        enum cron {
          tailf:info "Cron/at facility";
        }
        enum daemon {
          tailf:info "System daemons";
        }
        enum kern {
          tailf:info "Kernel";
        }
        enum local0 {
          tailf:info "Local use";
        }
        enum local1 {
          tailf:info "Local use";
        }
        enum local2 {
          tailf:info "Local use";
        }
        enum local3 {
          tailf:info "Local use";
        }
        enum local4 {
          tailf:info "Local use";
        }
        enum local5 {
          tailf:info "Local use";
        }
        enum local6 {
          tailf:info "Local use";
        }
        enum local7 {
          tailf:info "Local use";
        }
        enum lpr {
          tailf:info "Line printer system";
        }
        enum mail {
          tailf:info "Mail system";
        }
        enum news {
          tailf:info "USENET news";
        }
        enum sys10 {
          tailf:info "System use";
        }
        enum sys11 {
          tailf:info "System use";
        }
        enum sys12 {
          tailf:info "System use";
        }
        enum sys13 {
          tailf:info "System use";
        }
        enum sys14 {
          tailf:info "System use";
        }
        enum sys9 {
          tailf:info "System use";
        }
        enum syslog {
          tailf:info "Syslog itself";
        }
        enum user {
          tailf:info "User process";
        }
        enum uucp {
          tailf:info "Unix-to-Unix copy system";
        }
      }
      default local7;
    }

    // logging history
    container history {
      tailf:info "Configure syslog history table";

      // logging history size
      leaf size {
        tailf:info "Set history table size";
        type uint16 {
          tailf:info "<0-500>;History size";
        }
      }

      // logging history ?
      leaf severity-level {
        tailf:cli-drop-node-name;
        type logging-level-type;
      }
    }

    // logging *
    list hostname {
      tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key host;
      leaf host {
        tailf:cli-disallow-value "esm|alarm|buffered|facility"+
          "|history|rate-limit|source-interface|host|console";
        tailf:cli-full-command;
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of the logging host";
        }
      }
    }

    // logging host
    container host {
      tailf:info "Set syslog server IP address and parameters";

      // logging host *
      list ipv4 {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key host;
        leaf host {
          tailf:cli-disallow-value "ipv6";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address of the syslog server";
          }
        }
        uses logging-host-grouping;
      }

      // logging host * vrf
      list ipv4-vrf {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key "host vrf";
        leaf host {
          tailf:cli-disallow-value "ipv6";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address of the syslog server";
          }
        }
        leaf vrf {
          tailf:info "Set VRF option";
          tailf:cli-expose-key-name;
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses logging-host-grouping;
      }

      // logging host ipv6 *
      list ipv6 {
        tailf:info "Configure IPv6 syslog server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key host;
        leaf host {
          type inet:host {
            tailf:info "Hostname or X:X:X:X::X;;IPv6 address of the "+
              "syslog server";
          }
        }
        uses logging-host-grouping;
      }

      // logging host ipv6 * vrf
      container ipv6-vrf {
        tailf:cli-drop-node-name;
        list ipv6 {
          tailf:info "Configure IPv6 syslog server";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "host vrf";
          leaf host {
            type inet:host {
              tailf:info "Hostname or X:X:X:X::X;;IPv6 address of the "+
                "syslog server";
            }
          }
          leaf vrf {
            tailf:info "Set VRF option";
            tailf:cli-expose-key-name;
            tailf:cli-diff-dependency "../../../../../vrf/definition";
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          uses logging-host-grouping;
        }
      }
    }

    choice rate-limit-choice {
      // no logging rate-limit
      leaf rate-limit {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }
      // logging rate-limit
      container rate-limit-conf {
        tailf:cli-drop-node-name;
        container rate-limit {
          tailf:info "Set messages per second limit";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          leaf console {
            tailf:info "Rate limit only console messages";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf all {
            tailf:info "Rate limit all messages, including debug messages";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf rate {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-10000>;;Messages per second";
              range "1..10000";
            }
          }
          leaf except {
            tailf:info "Messages of this severity or higher";
            type logging-level-type;
          }
        }
      }
    }

    // logging source-interface *
    list source-interface {
      tailf:info "Specify interface for source address in logging transactions";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../../interface";
        type string {
          tailf:info "WORD;;Interface name";
        }
      }
      leaf vrf {
        tailf:info "Specify the vrf of source interface for logging "+
          "transactions";
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }

    // logging trap
    leaf trap {
      tailf:info "Set syslog server logging level";
      tailf:cli-full-command;
      type logging-level-type;
      default informational;
    }

    // logging origin-id
    container origin-id {
      tailf:info "Add origin ID to syslog messages";
      choice origin-id-choice {
        leaf hostname {
          tailf:info "Use origin hostname as ID";
          type empty;
        }
        leaf ip {
          tailf:info "Use origin IP address as ID";
          type empty;
        }
        leaf ipv6 {
          tailf:info "Use origin IPv6 address as ID";
          type empty;
        }
        leaf string {
          tailf:info "Define a unique text string as ID";
          type string {
            tailf:info "WORD;;Text string";
          }
        }
      }
    }

    // logging linecard
    container linecard {
      tailf:info "specify logging parameters for a linecard messages";
      leaf size {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<4096-65536>;;number of bytes of message log per slot";
          range "4096..65535";
        }
        default 8192;
      }
      leaf level {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type logging-level-type;
      }
    }
  }


  /// ========================================================================
  /// firewall
  /// ========================================================================

  container firewall {
    tailf:info "Specify secure VLANs groups and tie them to firewall modules";

    // firewall multiple-vlan-interfaces
    leaf multiple-vlan-interfaces {
      tailf:info "Enable multiple vlan interfaces mode for firewall modules";
      type empty;
    }

    // firewall vlan-group *
    list vlan-group {
      tailf:info "Secure group which VLANs will be tied to";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        type uint16 {
          tailf:info "<1-65535>;;group-number";
          range "1..65535";
        }
      }
      leaf-list vlan {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        type uint16 {
          tailf:info "WORD;;vlan range (2-1001,1006-4094) ex: 2-65,72,300-320";
        }
      }
    }
  }


  /// ========================================================================
  /// cpd
  /// ========================================================================

  container cpd {
    tailf:info "Global Control Point Discovery Configuration";
    tailf:cli-display-separated;
    presence true;

    // cpd cr-id
    leaf cr-id {
      tailf:info "Control Relationship Identifier";
      type uint16 {
        tailf:info "<1-65535>;;Control Relationship Identifier Value";
        range "1..65535";
      }
    }
  }


  /// ========================================================================
  /// nls
  /// ========================================================================

  container nls {
    tailf:info "Global Network Layer Signaling Configuration";
    tailf:cli-display-separated;
    presence true;

    // nls resp-timeout
    leaf resp-timeout {
      tailf:info "NLS Response Timeout";
      type uint8 {
        tailf:info "<1-60>;;NLS Response Timeout Value";
        range "1..60";
      }
    }
  }


  /// ========================================================================
  /// flow-sampler-map
  /// ========================================================================

  list flow-sampler-map {
    tailf:info "Flow sampler configuration";
    tailf:cli-mode-name "config-sampler";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of the flow sampler";
      }
    }

    // flow-sampler-map * / mode
    container mode {
      tailf:info "Mode of packet sampling for netflow processing";
      container random {
        tailf:info "Random mode of sampling";
        leaf one-out-of {
          tailf:info "Select one packet out of";
          type uint16 {
            tailf:info "<1-65535>;number of sequential packets to "+
              "select one packet from";
            range "1..65535";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// frame-relay
  /// ========================================================================

  container frame-relay {
    tailf:info "global frame relay configuration commands";

    // frame-relay switching
    leaf switching {
      tailf:info "enable frame relay pvc switching";
      type empty;
    }
  }


  /// ========================================================================
  /// scheduler
  /// ========================================================================

  container scheduler {
    tailf:info "Scheduler parameters";

    // scheduler allocate
    container allocate {
      tailf:info "Guarantee CPU time for processes";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf interrupt-time {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<400-60000>;;Microseconds handling network interrupts";
          range "400..60000";
        }
      }
      leaf process-time {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<100-4000>;;Microseconds running processes";
          range "100..4000";
        }
      }
    }

    // scheduler isr-watchdog
    leaf isr-watchdog {
      tailf:info "Detect ISR Hang";
      type empty;
    }

    // scheduler runtime netinput
    container runtime {
      tailf:info "Process runtime controls";
      leaf netinput {
        tailf:info "Enable packet process-switching run time";
        type uint16 {
          tailf:info "<100-40000>;;Process-switching run time (in milliseconds)";
          range "100..40000";
        }
      }
    }
  }


  /// ========================================================================
  /// wsma
  /// ========================================================================

  container wsma {
    tailf:info "Configure Web Services Management Agents";

    // wsma agent *
    list agent {
      tailf:info "Configure WSMA agents";
      key name;
      leaf name {
        type enumeration {
          enum "config" {
            tailf:info "Start WSMA config agent";
          }
          enum exec {
            tailf:info "Start WSMA exec agent";
          }
          enum filesys {
            tailf:info "Start WSMA file system agent";
          }
          enum notify {
            tailf:info "Start WSMA notify agent";
          }
        }
      }
      list profile {
        tailf:info "Profile to use";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Profile name";
          }
        }
      }
    }

    // wsma profile
    container profile {
      tailf:info "Configure WSMA profil";

      // wsma profile listener *
      list listener {
        tailf:cli-mode-name "config-wsma-listen";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Listener profile name";
          }
        }

        // wsma profile listener * / transport
        container transport {
          tailf:info "The transport to use";
          choice transport-choice {
            container http {
              tailf:info "Use http (plaintext) transport";
              presence true;
            }
            container https {
              tailf:info "Use https (encrypted) transport";
              presence true;
            }
            container ssh {
              tailf:info "Use SSH V2";
              presence true;
            }
          }
        }
      }

      // wsma profile initiator *
      list initiator {
        tailf:cli-mode-name "config-wsma-init";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Initiator profile name";
          }
        }

        // wsma profile initiator * / transport
        container transport {
          tailf:info "The transport to use";
          choice transport-choice {
            container http {
              tailf:info "Use http (plaintext) transport";
              presence true;
            }
            container https {
              tailf:info "Use https (encrypted) transport";
              presence true;
            }
            container ssh {
              tailf:info "Use SSH V2";
              presence true;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// process
  /// ========================================================================

  container process {
    tailf:info "Configure process";

    // process cpu
    container cpu {
      tailf:info "Configure cpu parameters";

      // process cpu threshold
      container threshold {
        tailf:info "cpu threshold parameters";
        container "type" {
          tailf:info "cpu threshold type";
          tailf:cli-compact-syntax;

          // process cpu threshold type total
          container total {
            tailf:info "total cpu utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type interrupt
          container interrupt {
            tailf:info "interrupt level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }

          // process cpu threshold type process
          container process {
            tailf:info "process level utilization";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses process-cpu-threshold-grouping;
          }
        }
      }

      // process cpu statistics limit
      container statistics {
        tailf:info "cpu statistics";
        container limit {
          tailf:info "cpu utilization history";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf entry-percentage {
            tailf:info "cpu history entry percentage";
            type uint8 {
              tailf:info "<1-100>";
              range "1..100";
            }
          }
          leaf size {
            tailf:info "cpu history size in seconds";
            type uint32 {
              tailf:info "<5-86400>";
              range "5..86400";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// ntp
  /// ========================================================================

  container ntp {
    tailf:info "Configure NTP";

    // ntp max-associations
    leaf max-associations {
      tailf:info "Set maximum number of associations";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;Number of associations";
      }
    }

    // ntp clock-period
    // NOT MODELLED BECAUSE VALUE CHANGE RUNTIME

    // ntp passive
    leaf passive {
      tailf:info "NTP passive mode";
      tailf:cli-full-command;
      type empty;
    }

    // ntp logging
    leaf logging {
      tailf:info "Enable NTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // ntp panic
    container panic {
      tailf:info "Reject time updates > panic threshold (default 1000Sec)";
      leaf update {
        tailf:info "Reject time updates > panic threshold (default 1000Sec)";
        type empty;
      }
    }

    // ntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      container md5 {
        tailf:info "MD5 authentication";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          tailf:meta-data "secret-password";
          type string {
            tailf:info "WORD;;Authentication key";
          }
        }
        leaf "type" {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Authentication key encryption type";
          }
        }
      }
    }

    // ntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // ntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf "hyphen" {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // ntp orphan
    leaf orphan {
      tailf:info "Threshold Stratum for orphan mode";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Orphan stratum";
        range "1..16";
      }
    }

    // ntp mindistance
    leaf mindistance {
      tailf:info "Minimum distance to consider for clockhop";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-500>;;Minimum distance to consider for clockhop";
        range "1..500";
      }
    }

    // ntp maxdistance
    leaf maxdistance {
      tailf:info "Maximum Distance for synchronization";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-16>;;Maximum distance for synchronization";
        range "1..16";
      }
    }

    // ntp broadcastdelay
    leaf broadcastdelay {
      tailf:info "Estimated round-trip delay";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<1-999999>;;Round-trip delay in microseconds";
        range "1..999999";
      }
    }

    // ntp source
    container source {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

    // ntp access-group
    container access-group {
      tailf:info "Control NTP access";

      // ntp access-group peer
      container peer {
        tailf:info "Provide full access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group query-only
      container query-only {
        tailf:info "Allow only control queries";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group serve
      container serve {
        tailf:info "Provide server and query access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group server-only
      container serve-only {
        tailf:info "Provide only server access";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf access-list {
          tailf:cli-drop-node-name;
          type std-ip-acl-type;
        }
        leaf kod {
          tailf:info "Send a Kiss-o-Death packet for failing peers";
          type empty;
        }
      }

      // ntp access-group ipv6
      container ipv6 {
        tailf:info "ipv6 access lists";

        // ntp access-group ipv6 peer
        container peer {
          tailf:info "Provide full access";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf access-list {
            tailf:cli-drop-node-name;
            type std-ip-acl-type;
          }
          leaf kod {
            tailf:info "Send a Kiss-o-Death packet for failing peers";
            type empty;
          }
        }
      }
    }

    // ntp master
    container master {
      tailf:info "Act as NTP master clock";
      tailf:cli-delete-when-empty;
      presence true;
      leaf stratum {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-15>;;Stratum number";
          range "1..15";
        }
      }
    }

    // ntp peer
    container peer {
      tailf:info "Configure NTP peer";
      uses ntp-peer-grouping;
      // ntp peer ip
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer ipv6
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp peer vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp server *
    container server {
      tailf:info "Configure NTP server";
      uses ntp-peer-grouping;
      // ntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses ntp-peer-grouping;
      }
      // ntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses ntp-peer-grouping;
      }
    }

    // ntp allow mode private
    container allow {
      tailf:info "Allow processing of packets";
      container mode {
        tailf:info "Allow processing of particular mode packets";
        leaf private {
          tailf:info "Allow processing private mode packets";
          type empty;
        }
      }
    }

    // ntp update-calender
    leaf update-calendar {
      tailf:info "Periodically update calendar with NTP time";
      type empty;
    }

  }


  /// ========================================================================
  /// sntp
  /// ========================================================================

  container sntp {
    tailf:info "Configure SNTP";
    tailf:cli-incomplete-no;

    // sntp logging
    leaf logging {
      tailf:info "Enable SNTP message logging";
      tailf:cli-full-command;
      type empty;
    }

    // sntp authentication-key *
    list authentication-key {
      tailf:info "Authentication key for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key number;
      leaf number {
        type uint32 {
          tailf:info "<1-4294967295>;;Key number";
          range "1..4294967295";
        }
      }
      leaf md5 {
        tailf:info "MD5 authentication";
        type string {
          tailf:info "WORD;;Authentication key";
        }
      }
      leaf encryption-type {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-4294967295>;;Authentication key encryption type";
        }
      }
    }

    // sntp authenticate
    leaf authenticate {
      tailf:info "Authenticate time sources";
      tailf:cli-full-command;
      type empty;
    }

    // sntp trusted-key *
    list trusted-key {
      tailf:info "Key numbers for trusted time sources";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      key key-number;
      leaf key-number {
        type uint16 {
          tailf:info "<1-65535>;;Key number";
          range "1..65535";
        }
      }
      leaf "hyphen" {
        tailf:info "hyphen";
        tailf:alt-name "-";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf end-key-number {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-65535>;;End Key range";
          range "1..65535";
        }
      }
    }

    // sntp server *
    container server {
      tailf:info "Configure SNTP server";
      uses sntp-server-grouping;
      // sntp server ip *
      container ip {
        tailf:info "Use IP for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server ipv6 *
      container ipv6 {
        tailf:info "Use IPv6 for DNS resolution";
        tailf:cli-compact-syntax;
        uses sntp-server-grouping;
      }
      // sntp server vrf *
      list vrf {
        tailf:info "VPN Routing/Forwarding Information";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses sntp-server-grouping;
      }
    }

    // sntp broadcast
    container broadcast {
      tailf:info "Configure SNTP broadcast services";
      leaf client {
        tailf:info "Enable SNTP broadcast client mode";
        type empty;
      }
    }

    // sntp multicast client
    container multicast {
      tailf:info "Configure SNTP multicast services";
      container client {
        tailf:info "Enable SNTP multicast client mode";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf address {
          tailf:cli-drop-node-name;
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Multicast client IP address";
            }
            type inet:ipv6-address {
              tailf:info "X:X:X:X::X;;Multicast client IPv6 address";
            }
          }
        }
      }
    }

    // sntp source-interface
    container source-interface {
      tailf:info "Configure interface for source address";
      uses interface-name-grouping;
    }

  }


  /// ========================================================================
  /// ptp
  /// ========================================================================

  container ptp {
    tailf:info "Precision Time Protocol";
    container clock {
      tailf:info "Configure PTP clock";

      // ptp clock profile *
      list profile {
        tailf:info "Create a PTP Clock Profile";
        tailf:cli-mode-name "config-ptp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-63>;;RPD PTP Ds Domain Number";
            range "0..63";
          }
        }

        // ptp clock profile * / clock-source1
        container clock-source1 {
          tailf:info "Clock Source";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf address {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source IP addr";
            }
          }
          leaf gw {
            tailf:info "Clock Source Gateway";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source Gateway addr";
            }
          }
        }
      }

      // ptp clock ordinary domain *
      container ordinary {
        tailf:info "Configure PTP Ordinary clock";
        list domain {
          tailf:info "PTP domain";
          tailf:cli-mode-name "config-ptp-clk";
          key id;
          max-elements 1;
          leaf id {
            type uint8 {
              tailf:info "<0-127>;;Domain number";
              range "0..127";
            }
          }
          leaf hybrid {
            tailf:info "Hybrid Mode";
            tailf:cli-hide-in-submode;
            type empty;
          }

          // ptp clock ordinary domain * / priority1
          leaf priority1 {
            tailf:info "Set priority1";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;Priority1";
              range "0..255";
            }
          }

          // ptp clock ordinary domain * / priority2
          leaf priority2 {
            tailf:info "Set priority2";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;Priority2";
              range "0..255";
            }
          }

          // ptp clock ordinary domain * / time-properties
          container time-properties {
            tailf:info "Set the PTP timePropertiesDS";
            container gps {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf timeScale {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum timeScaleFALSE {
                    tailf:info "Set the timepropertiesDS.timeScale to FALSE";
                  }
                  enum timeScaleTRUE {
                    tailf:info "Set the timepropertiesDS.timeScale to TRUE";
                  }
                }
              }
              leaf currentUtcOffsetValid {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum currentUtcOffsetValidFALSE {
                    tailf:info "Set the timepropertiesDS.currentUtcOffsetValid"+
                    "to FALSE";
                  }
                  enum currentUtcOffsetValidTRUE {
                    tailf:info "Set the timepropertiesDS.currentUtcOffsetValid"+
                    "to TRUE";
                  }
                }
              }
              leaf leap59 {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum leap59FALSE {
                    tailf:info "Set the timepropertiesDS.leap59 to FALSE";
                  }
                  enum leap59TRUE {
                    tailf:info "Set the timepropertiesDS.leap59 to TRUE";
                  }
                }
              }
              leaf leap61 {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum leap61FALSE {
                    tailf:info "Set the timepropertiesDS.leap61 to FALSE";
                  }
                  enum leap61TRUE {
                    tailf:info "Set the timepropertiesDS.leap61 to TRUE";
                  }
                }
              }
              leaf currentUtcOffset {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-1000>;;Set the "+
                    "timepropertiesDS.currentUtcOffset (in seconds)";
                  range "0..1000";
                }
              }
            }
          }

          // ptp clock ordinary domain * / clock-port *
          list clock-port {
            tailf:info "Configure clock port";
            tailf:cli-mode-name "config-ptp-port";
            key "name mode";
            leaf name {
              type string {
                tailf:info "WORD;;Port name";
              }
            }
            leaf mode {
              type enumeration {
                enum master {
                  tailf:info "Configure as Master";
                }
                enum slave {
                  tailf:info "Configure as Slave";
                }
              }
            }

            // ptp clock ordinary domain * / clock-port * profile
            leaf profile {
              tailf:info "PTP profile";
              tailf:cli-hide-in-submode;
              type enumeration {
                enum "g8265.1" {
                  tailf:info "Telecom Profile ITU-T G.8265.1";
                }
              }
            }

            // ptp clock ordinary domain * / clock-port * / transport
            container transport {
              tailf:info "Set port transport parameters";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf proto {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum ethernet {
                    tailf:info "Use Ethernet encapsulation";
                  }
                  enum ipv4 {
                    tailf:info "Use IPv4 encapsulation";
                  }
                }
              }
              leaf unicast {
                tailf:info "Use unicast communication channel";
                type empty;
              }
              leaf interface {
                tailf:info "Transport interface";
                when "../proto = 'ipv4'" {
                  tailf:dependency "../proto";
                }
                type string {
                  tailf:info "WORD;;Abbreviated interface name";
                }
              }
              leaf negotiation {
                tailf:info "Enable unicast negotiation";
                type empty;
              }
            }

            // ptp clock ordinary domain * / clock-port * / clock
            container clock {
              tailf:info "Set clock parameters";
              leaf source {
                tailf:info "Local clock address";
                type string {
                  tailf:info "WORD;;MAC/IP address";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mac-address-table
  /// ========================================================================

  container mac-address-table {
    tailf:info "Configure the MAC address table";

    // mac-address-table notification mac-move
    container "notification" {
      tailf:info "Enable a Notification feature";
      leaf mac-move {
        tailf:info "Enable Mac Move Notification";
        type empty;
      }
    }

    // mac-address-table move update
    container move {
      tailf:info "Move keyword";
      container update {
        tailf:info "Notification keyword";
        // mac-address-table move update transmit
        leaf transmit {
          tailf:info "Transmit keyword";
          type empty;
        }
        // mac-address-table move update receive
        leaf receive {
          tailf:info "Receive keyword";
          type empty;
        }
      }
    }

    // mac-address-table synchronize
    container synchronize {
      tailf:info "Synchronize MAC address table entries in the system";
      tailf:cli-display-separated;
      presence true;
      leaf activity-time {
        tailf:info "Set activity time for MAC entry synchronization";
        type uint16 {
          tailf:info "<0-1275>;;Enter time in seconds <160, 320, 640>";
        }
      }
    }

    // no mac-address-table aging-type routed-mac
    container aging-type {
      tailf:info "Enable routed MAC entries aging";
      leaf routed-mac {
        tailf:info "Enable routed MAC entries aging";
        tailf:cli-boolean-no;
        type boolean;
        default true;
      }
    }

    // mac-address-table aging-time
    leaf aging-time {
      tailf:info "Set MAC address table entry maximum age";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<0-0>;;Enter 0 to disable aging";
          range "0";
        }
        type uint32 {
          tailf:info "<10-1000000>;;Aging time in seconds";
          range "10..1000000";
        }
      }
    }

    // mac-address-table aging-time ? routed-mac
    container againg-time-routed-mac {
      tailf:cli-drop-node-name;
      container aging-time {
        tailf:info "Set MAC address table entry maximum age";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf speed {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          type union {
            type uint32 {
              tailf:info "<0-0>;;Enter 0 to disable aging";
              range "0";
            }
            type uint32 {
              tailf:info "<10-1000000>;;Aging time in seconds";
              range "10..1000000";
            }
          }
        }
        leaf routed-mac {
          tailf:info "Set RM Aging interval";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // mac-address-table limit
    container limit {
      tailf:info "Enter parameters for mac limit feature";

      // mac-address-table limit vlan *
      list vlan {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;Enter VLAN Number";
            range "1..4094";
          }
        }
        // mac-address-table limit vlan * maximum
        leaf maximum {
          tailf:info "Enter max allowed entries";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type uint16 {
            tailf:info "<5-16000>;;Max allowed entries";
          }
        }
        // mac-address-table limit vlan * action
        leaf action {
          tailf:info "Enter action";
          tailf:cli-no-name-on-delete;
          tailf:cli-no-value-on-delete;
          type enumeration {
            enum warning {}
            enum limit {}
            enum shutdown {}
          }
        }
        // mac-address-table limit vlan * flood
        leaf flood {
          tailf:info "Disable flooding on this vlan";
          tailf:cli-no-name-on-delete;
          type empty;
        }
      }

      // mac-address-table limit bdomain *
      list bdomain {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type uint16 {
          }
        }
        // mac-address-table limit bdomain * maximum
        leaf maximum {
          tailf:info "Enter max allowed entries";
          type uint16 {
            tailf:info "<5-16000>;;Max allowed entries";
          }
        }
        // mac-address-table limit bdomain * action
        leaf action {
          tailf:info "Enter action";
          type enumeration {
            enum warning {}
            enum limit {}
            enum shutdown {}
          }
        }
        // mac-address-table limit bdomain * flood
        leaf flood {
          tailf:info "Disable flooding on this vlan";
          type empty;
        }
      }
    }

    // no mac-address-table learning vlan *
    // mac-address-table learning vlan no-list *
    container learning {
      tailf:info "Enable a MAC table learning feature";
      container vlan {
        tailf:info "Layer 2 table learning per VLAN";
        list no-list {
          tailf:info "'no mac-address-table learning vlan' entry";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-4094>;;VLAN ID";
              range "1..4094";
            }
          }
          leaf "module" {
            tailf:info "Layer 2 table learning per VLAN per module";
            type uint8 {
              tailf:info "<1-9>;;Module";
              range "1..9";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// mac
  /// ========================================================================

  container mac {
    tailf:info "Global MAC configuration subcommands";

    // mac access-list
    container access-list {
      tailf:info "Named access-list";

      // mac access-list extended *
      list extended {
        tailf:info "Extended Access List";
        tailf:cli-mode-name "config-ext-macl";
        tailf:cli-full-command;
        tailf:cli-explicit-exit;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        list entry {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          ordered-by user;
          key rule;
          leaf rule {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "deny;;Specify packets to reject\n"+
                "permit;;Specify packets to forwards";
              pattern "(permit .*)|(deny .*)";
            }
          }
        }
      }
    }

    // mac address-table
    container address-table {
      tailf:info "Configure the MAC address table";

      // mac address-table aging-time
      leaf aging-time {
        tailf:info "Set MAC address table entry maximum age";
        type union {
          type uint32 {
            tailf:info "<0-0>;;Enter 0 to disable aging";
            range "0";
          }
          type uint32 {
            tailf:info "<10-1000000>;;Aging time in seconds";
            range "10..1000000";
          }
        }
      }

      // mac address-table notification
      container "notification" {
        tailf:info "Enable/Disable MAC Notification on the switch";
        leaf change {
          tailf:info "Enable/Disable MAC Notification feature on the switch";
          type empty;
        }
        leaf mac-move {
          tailf:info "Enable Mac Move Notification";
          type empty;
        }
      }

      // mac address-table move update
      container move {
        tailf:info "Move keyword";
        container update {
          tailf:info "Notification keyword";
          leaf transmit {
            tailf:info "Transmit keyword";
            type empty;
          }
          leaf receive {
            tailf:info "Receive keyword";
            type empty;
          }
        }
      }
    }
  }


  /// ========================================================================
  /// privilege
  /// ========================================================================

  container privilege {
    tailf:info "Command privilege parameters";

    // privilege exec
    container exec {
      tailf:info "Exec mode";

      // privilege exec level *
      list level {
        tailf:info "Set privilege level of command";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-no-key-completion;
        key privilege;
        leaf privilege {
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          tailf:cli-suppress-range;
          type uint8 {
            tailf:info "<0-15>;;Privilege level";
          }
        }
        list command-list {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-show-long-obu-diffs;
          tailf:cli-no-key-completion;
          tailf:cli-suppress-key-abbreviation;
          tailf:cli-no-match-completion;
          ordered-by user;
          key command;
          leaf command {
            tailf:cli-drop-node-name;
            tailf:cli-multi-word-key;
            type string {
              tailf:info "LINE;;Initial keywords of the command to modify";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// spanning-tree
  /// ========================================================================

  container spanning-tree {
    tailf:info "Spanning Tree Subsystem";

    // spanning-tree etherchannel
    container etherchannel {
      tailf:info "Spanning tree etherchannel specific configuration";
      container guard {
        tailf:info "Configure guard features for etherchannel";
        leaf misconfig {
          tailf:info "Enable guard to protect against etherchannel "
            +"misconfiguration";
          type empty;
        }
      }
    }

    // spanning-tree extend
    container extend {
      tailf:info "Spanning Tree 802.1t extensions";
      leaf system-id {
        tailf:info "Extend system-id into priority portion of the bridge id ("
          +"PVST & Rapid PVST only)";
        type empty;
      }
    }

    // spanning-tree loopguard
    container loopguard {
      tailf:info "Spanning tree loopguard options";
      leaf "default" {
        tailf:info "Enable loopguard by default on all ports";
        type empty;
      }
    }

    // spanning-tree mst
    container mst {
      tailf:info "Multiple spanning tree configuration";

      // spanning-tree mst *
      list instance-range {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-range-list-syntax;
        tailf:meta-data "range-list-syntax" {
          tailf:meta-value "spanning-tree mst <ID> $3";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "<0-4094>;;MST instance id";
            range "0..4094";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-61440>;;bridge priority in increments of 4096";
            range "0..61440";
          }
        }
      }

      // spanning-tree mst configuration
      container configuration {
        tailf:info "Enter MST configuration submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-mst";

        // spanning-tree mst configuration / revision
        leaf "revision" {
          tailf:info "Set configuration revision number";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Configuration revision number";
          }
        }

        // spanning-tree mst configuration / name
        leaf name {
          tailf:info "Set configuration name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Configuration name";
          }
        }

        // spanning-tree mst configuration / instance *
        list instance {
          tailf:info "Map vlans to an MST instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<0-4094>;;MST instance id";
              range "0..4094";
            }
          }
          leaf-list vlan {
            tailf:info "Range of vlans to add to the instance mapping";
            tailf:cli-range-list-syntax;
            type uint16 {
              tailf:info "LINE;;vlan range ex: 1-65, 72, 300 -200";
            }
          }
        }
      }

      // spanning-tree mst forward-time
      leaf forward-time {
        tailf:info "Set the forward delay for the spanning tree";
        type uint8 {
          tailf:info "<4-30>;;number of seconds for the forward delay timer";
          range "4..30";
        }
      }
    }

    // no spanning-tree optimize bpdu transmission
    container optimize {
      container bpdu {
        tailf:info "Optimize BPDU Handling";
        leaf transmission {
          tailf:info "Optimize transmission of BPDUs";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // spanning-tree portfast
    container portfast {
      tailf:info "Spanning tree portfast options";
      uses spanning-tree-portfast-grouping;
      container edge {
        uses spanning-tree-portfast-grouping;
      }
    }

    // spanning-tree uplinkfast max-update-rate
    container uplinkfast-conf {
      tailf:cli-drop-node-name;
      container uplinkfast {
        tailf:info "Enable UplinkFast Feature";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf max-update-rate {
          tailf:info "Rate at which station address updates are sent";
          type uint16 {
            tailf:info "<0-32000>;;Maximum number of update packets per second";
            range "0..32000";
          }
        }
      }
    }

    // spanning-tree uplinkfast
    leaf uplinkfast {
      tailf:info "Enable UplinkFast Feature";
      tailf:cli-full-command;
      type empty;
    }

    // spanning-tree pathcost method
    container pathcost {
      tailf:info "Spanning tree pathcost options";
      leaf method {
        tailf:info "Method to calculate default port path cost";
        type enumeration {
          enum long {
            tailf:info "Use 32 bit based values for default port path costs";
          }
          enum short {
            tailf:info "Use 16 bit based values for default port path costs";
          }
        }
        default short;
      }
    }

    // spanning-tree mode
    leaf mode {
      tailf:info "Spanning tree operating mode";
      tailf:cli-full-command;
      type enumeration {
        enum mst {
          tailf:info "Multiple spanning tree mode";
        }
        enum pvst {
          tailf:info "Per-Vlan spanning tree mode";
        }
        enum rapid-pvst {
          tailf:info "Per-Vlan rapid spanning tree mode";
        }
      }
    }

    // spanning-tree vlan
    container vlan {
      tailf:info "VLAN Switch Spanning Tree";

      // no spanning-tree vlan *
      list no-list {
        tailf:info "'no spanning-tree vlan' list entry";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        tailf:meta-data "range-list-syntax" {
          tailf:meta-value "spanning-tree vlan no-list <ID>";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-4094>;;Spanning tree VLAN id";
            range "1..4094";
          }
        }
      }

      // spanning-tree vlan * hello-time
      // spanning-tree vlan * priority
      // spanning-tree vlan * forward-time
      // spanning-tree vlan * max-age
      list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-range-list-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        tailf:meta-data "range-list-syntax" {
          tailf:meta-value "spanning-tree vlan <ID> $3 $4";
        }
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;vlan range, example: 1,3-5,7,9-11";
            range "1..4096";
          }
        }
        leaf hello-time {
          tailf:info "Set the hello interval for the spanning tree";
          type uint8 {
            tailf:info "<1-10>;;number of seconds between generation of "+
              "config BPDUs";
            range "1..10";
          }
        }
        leaf priority {
          tailf:info "Set the bridge priority for the spanning tree";
          type uint16 {
            tailf:info "<0-65535>;;bridge priority";
          }
        }
        leaf forward-time {
          tailf:info "Set the forward delay for the spanning tree";
          type uint8 {
            tailf:info "<4-30>;;number of seconds for the forward delay timer";
            range "4..30";
          }
        }
        leaf max-age {
          tailf:info "Set the max age interval for the spanning tree";
          type uint8 {
            tailf:info "<6-40>;;maximum number of seconds the information "+
              "in a BPDU is valid";
            range "6..40";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// dot1x
  /// ========================================================================

  container dot1x {
    tailf:info "IEEE 802.1X Global Configuration Commands";

    // dot1x critical
    container critical {
      tailf:info "Set 802.1x Critical Authentication parameters";
      leaf eapol {
        tailf:info "Send EAPOL-Success on successful Critical Authentication";
        type empty;
      }
      container recovery {
        tailf:info "Set 802.1x Critical Authentication Recovery parameters";
        leaf delay {
          tailf:info "Set 802.1x Critical Authentication Recovery Delay period";
          type uint16 {
            tailf:info "<1-10000>;;802.1x Critical Authentication Recovery "
              +"delay in milliseconds";
            range "1..10000";
          }
        }
      }
    }

    // dot1x system-auth-control
    leaf system-auth-control {
      tailf:info "Enable or Disable SysAuthControl";
      type empty;
    }
  }


  /// ========================================================================
  /// power
  /// ========================================================================

  container power {
    tailf:info "Power configure";

    // power redundancy-mode
    leaf redundancy-mode {
      tailf:info "set power supply redundancy mode";
      type enumeration {
        enum combined {
          tailf:info "combine power supply outputs (no redundancy)";
        }
        enum redundant {
          tailf:info "either power supply can operate system (redundancy)";
        }
      }
    }
  }


  /// ========================================================================
  /// power-supply
  /// ========================================================================

  container power-supply {

    // power-supply dual
    container dual {
      tailf:cli-delete-when-empty;
      presence true;
      // power-supply dual dc-feed
      leaf dc-feed {
        type empty;
      }
    }
  }


  /// ========================================================================
  /// parameter-map
  /// ========================================================================

  container parameter-map {
    tailf:info "parameter map";

    // parameter-map type
    container "type" {
      tailf:info "parameter map type";

      // parameter-map type inspect-global
      container inspect-global {
        tailf:info "Global Parameter Map Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-profile";
        uses parameter-map-grouping;
      }

      // parameter-map type inspect *
      list inspect {
        tailf:info "inspect parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type inspect-vrf *
      list inspect-vrf {
        tailf:info "inspect vrf parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type inspect-zone *
      list inspect-zone {
        tailf:info "inspect zone parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }
        uses parameter-map-grouping;
      }

      // parameter-map type regex *
      list regex {
        tailf:info "regex parameter-map";
        tailf:cli-mode-name "config-profile";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;parameter-map name";
          }
        }

        // parameter-map type regexp * / pattern *
        list "pattern" {
          tailf:info "Configure pattern to match";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key regexp;
          leaf regexp {
            type string {
              tailf:info "WORD;;Specify the regex pattern";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn
  /// ========================================================================

  container vpdn {
    tailf:info "Virtual Private Dialup Network";

    // vpdn authen-before-forward
    leaf authen-before-forward {
      tailf:info "Authenticate a user locally before tunnelling";
      type empty;
    }

    // vpdn enable
    leaf enable {
      tailf:info "Enable VPDN";
      type empty;
    }

    // vpdn search-order
    leaf-list search-order {
      ordered-by user;
      tailf:info "Configure the order to search different VPDN tunnel types";
      type enumeration {
        enum dnis {
          tailf:info "Tunnel based on DNIS";
        }
        enum domain {
          tailf:info "Tunnel based on domain";
        }
        enum multihop-hostname {
          tailf:info "Tunnel based on peer hostname from ingress tunnel";
        }
      }
    }
  }


  /// ========================================================================
  /// vpdn-group
  /// ========================================================================

  // vpdn-group *
  list vpdn-group {
    tailf:info "VPDN group configuration";
    key name;
    leaf name {
      tailf:cli-diff-dependency "../../vpdn/enable";
      type string {
        tailf:info "WORD;;VPDN Group name";
      }
    }

    // vpdn-group * / accept-dialin
    container accept-dialin {
      tailf:info "VPDN accept-dialin group configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-vpdn-acc-in";

      // vpdn-group * / accept-dialin protocol
      leaf protocol {
        tailf:info "Tunneling protocol to be used";
        tailf:cli-no-value-on-delete;
        tailf:cli-remove-before-change;
        type enumeration {
          enum "any" {
            tailf:info "Use any protocol";
          }
          enum "l2tp" {
            tailf:info "Use L2TP";
          }
          enum "pptp" {
            tailf:info "Use PPTP";
          }
        }
      }

      // vpdn-group * / accept-dialin virtual-template
      leaf virtual-template {
        tailf:info "Virtual template to clone from";
        tailf:non-strict-leafref {
          path "../../../interface/Virtual-Template/name";
        }
        type uint16 {
          range "1..4095";
        }
      }
    }

    // vpdn-group * / description
    leaf "description" {
      tailf:info "Description for this VPDN group";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description of vpdn-group (up to 60 characters)";
        length "1..60";
      }
    }

    // vpdn-group * / dsl-line-info-forwarding
    leaf dsl-line-info-forwarding {
      tailf:info "Forward DSL Line Info attributes";
      type empty;
    }

    // vpdn-group * / force-local-chap
    leaf force-local-chap {
      tailf:info "Force a CHAP challenge to be instigated locally";
      type empty;
    }

    // vpdn-group * / ip
    container ip {
      tailf:info "IP settings for tunnel";

      // vpdn-group * / ip mtu
      leaf mtu {
        tailf:info "Set IP MTU settings";
        tailf:cli-full-command;
        type enumeration {
          enum "adjust" {
            tailf:info "Automatically adjust IP MTU for virtual-access";
          }
        }
      }

      // vpdn-group * / ip pmtu
      leaf pmtu {
        tailf:info "Enable PMTU for tunnel";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / ip precedence
      leaf precedence {
        tailf:info "Set IP Precedence value for tunneled traffic";
        tailf:cli-full-command;
        type enumeration {
          enum "critical" {
            tailf:info "Set critical precedence (5)";
          }
          enum "flash" {
            tailf:info "Set flash precedence (3)";
          }
          enum "flash-override" {
            tailf:info "Set flash override precedence (4)";
          }
          enum "immediate" {
            tailf:info "Set immediate precedence (2)";
          }
          enum "internet" {
            tailf:info "Set internetwork control precedence (6)";
          }
          enum "network" {
            tailf:info "Set network control precedence (7)";
          }
          enum "priority" {
            tailf:info "Set priority precedence (1)";
          }
          enum "routine" {
            tailf:info "Set routine precedence (0)";
          }
        }
        default "routine";
      }

      // vpdn-group * / ip tos
      leaf tos {
        tailf:info "Set IP ToS value for tunneled traffic";
        tailf:cli-full-command;
        type union {
          type uint8 {
            range "3|5|9..15";
          }
          type enumeration {
            enum "max-reliability" {
              tailf:info "Set max reliable ToS (2)";
            }
            enum "max-throughput" {
              tailf:info "Set max throughput ToS (4)";
            }
            enum "min-delay" {
              tailf:info "Set min delay ToS (8)";
            }
            enum "min-monetary-cost" {
              tailf:info "Set min monetary cost ToS (1)";
            }
            enum "normal" {
              tailf:info "Set normal ToS (0)";
            }
            enum "reflect" {
              tailf:info "Reflect IP payload ToS on tunnel";
            }
          }
        }
        default "normal";
      }
    }

    // vpdn-group * / l2tp
    container l2tp {
      tailf:info "L2TP specific commands";
      //tailf:cli-diff-dependency "../pptp" {
      //    tailf:cli-trigger-on-set;
      //}
      tailf:cli-diff-dependency "../accept-dialin/protocol";
      when "not(../accept-dialin/protocol='pptp')" {
        tailf:dependency "../accept-dialin/protocol";
      }
      container attribute {
        tailf:info "Configure AVP options";
        container clid {
          tailf:info "Options to apply on Calling Station Id";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }

          // vpdn-group * / l2tp attribute clid mask-method
          container mask-method {
            tailf:info "Mask characters by method";

            // vpdn-group * / l2tp attribute clid mask-method remove
            container remove {
              tailf:info "Remove CLID";
              presence true;

              // vpdn-group * / l2tp attribute clid mask-method remove match
              leaf match {
                tailf:info "Apply options only on substring match of username";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Substring of username";
                }
              }
            }

            // vpdn-group * / l2tp attribute clid mask-method right
            container right {
              tailf:info "Mask from the right side";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }

              // vpdn-group * / l2tp attribute clid mask-method right character
              leaf character {
                tailf:info "CHAR;;Character used for masking";
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type string {
                  length "1";
                }
              }

              // vpdn-group * / l2tp attribute clid mask-method right bytes
              leaf bytes {
                tailf:info "<0-255>;;Number of bytes to mask";
                tailf:cli-drop-node-name;
                type uint8;
              }

              // vpdn-group * / l2tp attribute clid mask-method right match
              leaf match {
                tailf:info "Apply options only on substring match of username";
                type string {
                  tailf:info "WORD;;Substring of username";
                }
              }
            }
          }
        }
      }

      // vpdn-group * / l2tp drop
      leaf drop {
        tailf:info "Drop packets under certain conditions";
        tailf:cli-full-command;
        type enumeration {
          enum "out-of-order" {
            tailf:info "Drop out of order data packets";
          }
        }
      }

      // vpdn-group * / l2tp hidden
      leaf hidden {
        tailf:info "Allow AVPs to be hidden";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / l2tp ignore
      leaf ignore {
        tailf:info "Ignore certain AVP values";
        tailf:cli-full-command;
        type enumeration {
          enum "tx-speed" {
            tailf:info "L2TPv2 AVP#24: Connect Speed";
          }
        }
      }

      // vpdn-group * / l2tp ip
      container ip {
        tailf:info "IP specific commands";

        // vpdn-group * / l2tp ip udp
        leaf udp {
          tailf:info "udp;;UDP specific commands";
          type enumeration {
            enum "checksum" {
              tailf:info "perform checksum on data packets";
            }
          }
        }
      }

      // vpdn-group * / l2tp rx-speed
      container rx-speed {
        tailf:info "l2tp receive speed";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        // vpdn-group * / l2tp rx-speed ANCP
        leaf ANCP {
          tailf:info "rx-speed source ANCP";
          tailf:cli-optional-in-sequence;
          type empty;
        }

        // vpdn-group * / l2tp rx-speed RAM-min
        leaf RAM-min {
          tailf:info "rx-speed source Rate Adaptive Mode - Minimum";
          tailf:cli-optional-in-sequence;
          when "not(../ANCP)" {
            tailf:dependency "../ANCP";
          }
          type empty;
        }

        // vpdn-group * / l2tp rx-speed rx-speed
        leaf rx-speed {
          tailf:info "<0-2147483>;;value of rx-speed in kbps";
          tailf:cli-drop-node-name;
          type uint32 {
            range "0..2147483";
          }
        }
      }

      // vpdn-group * / l2tp sequencing
      leaf sequencing {
        tailf:info "Enable sequencing";
        tailf:cli-full-command;
        type empty;
      }

      // vpdn-group * / l2tp tunnel
      container tunnel {
        tailf:info "L2TP tunnel commands";

        // vpdn-group * / l2tp tunnel authentication
        leaf authentication {
          tailf:info "Authenticate tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // vpdn-group * / l2tp tunnel bearer
        container bearer {
          tailf:info "Bearer attributes";

          // vpdn-group * / l2tp tunnel bearer capabilities
          leaf capabilities {
            tailf:info "AVP#4 : Bearer capabilities";
            type enumeration {
              enum "all" {
                tailf:info "All bearer types";
              }
              enum "analog" {
                tailf:info "Analog bearer type";
              }
              enum "digital" {
                tailf:info "Digital bearer type";
              }
              enum "none" {
                tailf:info "No bearer type";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel busy
        container busy {
          tailf:info "Busy list commands";

          // vpdn-group * / l2tp tunnel busy timeout
          leaf timeout {
            tailf:info "Busy list timeout length";
            type uint16 {
              tailf:info "<5-6000>;;Seconds";
              range "5..6000";
            }
          }
        }

        // vpdn-group * / l2tp tunnel framing
        container framing {
          tailf:info "Framing attributes";

          // vpdn-group * / l2tp tunnel framing capabilities
          leaf capabilities {
            tailf:info "AVP#3: Framing capabilities";
            type enumeration {
              enum "all" {
                tailf:info "All framing types";
              }
              enum "asynchronous" {
                tailf:info "Asynchronous framing";
              }
              enum "none" {
                tailf:info "No framing";
              }
              enum "synchronous" {
                tailf:info "Synchronous framing";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel hello
        leaf hello {
          tailf:info "Hello packet interval";
          type uint16 {
            tailf:info "<0-1000>;;seconds, default is 60";
            range "0..1000";
          }
          default 60;
        }

        // vpdn-group * / l2tp tunnel password
        container password {
          tailf:info "Tunnel password for authentication and/or AVP hiding";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }

        // vpdn-group * / l2tp tunnel receive-window
        leaf receive-window {
          tailf:info "Receive window size for control channel";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-8192>;;Number of packets";
            range "1..8192";
          }
        }

        // vpdn-group * / l2tp tunnel resync
        leaf resync {
          tailf:info "Number of unacknowledged packets sent to the peer for SSO";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1024>;;Number of packets";
            range "1..1024";
          }
        }

        // vpdn-group * / l2tp tunnel retransmit
        container retransmit {
          tailf:info "Control packet retransmission parameters";

          // vpdn-group * / l2tp tunnel retransmit initial
          container initial {
            tailf:info "SCCRQ control retries/timeout settings";

            // vpdn-group * / l2tp tunnel retransmit initial retries
            leaf retries {
              tailf:info "Number of initial retries before placing"
                + " LNS on busy list";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-1000>;;Maximum SCCRQ retransmissions";
                range "1..1000";
              }
            }

            // vpdn-group * / l2tp tunnel retransmit initial timeout
            container timeout {
              tailf:info "SCCRQ retransmission timeout parameters";
              leaf max {
                tailf:info "Maximum timeout";
                tailf:cli-full-command;
                type uint8 {
                  range "0..8";
                }
              }
              leaf min {
                tailf:info "Minimum timeout";
                tailf:cli-full-command;
                type uint8 {
                  range "0..8";
                }
              }
            }
          }

          // vpdn-group * / l2tp tunnel retransmit retries
          leaf retries {
            tailf:info "Number of retries before tearing down a tunnel";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-1000>;;Maximum retransmissions";
              range "5..1000";
            }
          }

          // vpdn-group * / l2tp tunnel retransmit timeout
          container timeout {
            tailf:info "Control packet retransmission timeout parameters";
            leaf max {
              tailf:info "Maximum timeout";
              tailf:cli-full-command;
              type uint8 {
                range "0..8";
              }
            }
            leaf min {
              tailf:info "Minimum timeout";
              tailf:cli-full-command;
              type uint8 {
                range "0..8";
              }
            }
          }
        }

        // vpdn-group * / l2tp tunnel timeout
        container timeout {
          tailf:info "Tunnel timeout values";

          // vpdn-group * / l2tp tunnel timeout no-session
          leaf no-session {
            tailf:info "No-session timeout for tunnel";
            tailf:cli-full-command;
            type union {
              type uint32 {
                tailf:info "<0-86400>;;Timeout in seconds";
                range "0..86400";
              }
              type enumeration {
                enum "never" {
                  tailf:info "Never timeout";
                }
              }
            }
          }

          // vpdn-group * / l2tp tunnel timeout setup
          leaf setup {
            tailf:info "Time permitted to setup a tunnel";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<60-6000>;;Timeout in seconds";
              range "60..6000";
            }
          }
        }

        // vpdn-group * / l2tp tunnel zlb
        container zlb {
          tailf:info "Tunnel ZLB options";
          leaf delay {
            tailf:info "<1-5>;;Delay in seconds";
            type uint8 {
              range "1..5";
            }
          }
        }
      }

      // vpdn-group * / l2tp tx-speed
      container tx-speed {
        tailf:info "l2tp transmit speed";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }

        // vpdn-group * / l2tp tx-speed ANCP
        leaf ANCP {
          tailf:info "tx-speed source ANCP";
          tailf:cli-optional-in-sequence;
          type empty;
        }

        // vpdn-group * / l2tp tx-speed RAM-min
        leaf RAM-min {
          tailf:info "tx-speed source Rate Adaptive Mode - Minimum";
          tailf:cli-optional-in-sequence;
          when "not(../ANCP)" {
            tailf:dependency "../ANCP";
          }
          type empty;
        }

        // vpdn-group * / l2tp tx-speed tx-speed
        leaf tx-speed {
          tailf:info "<0-2147483>;;value of tx-speed in kbps";
          tailf:cli-drop-node-name;
          type uint32 {
            range "0..2147483";
          }
        }
      }
    }

    // vpdn-group * / lcp
    container lcp {
      tailf:info "LCP specific commands";

      // vpdn-group * / lcp renegotiation
      leaf renegotiation {
        tailf:info "LNS/HGW renegotiates LCP";
        type enumeration {
          enum "always" {
            tailf:info "Always renegotiate";
          }
          enum "on-mismatch" {
            tailf:info "Renego only when config mismatch between"
              + " LNS/HGW and LAC/NAS";
          }
        }
      }
    }

    // vpdn-group * / local
    container local {
      tailf:info "Local information";
      leaf name {
        type string {
          tailf:info "name;;Local name used for group authentication";
        }
      }
    }

    // vpdn-group * / pptp
    container pptp {
      tailf:info "PPTP specific commands";
      //tailf:cli-diff-dependency "../l2tp" {
      //    tailf:cli-trigger-on-set;
      //}
      tailf:cli-diff-dependency "../accept-dialin/protocol";
      when "not(../accept-dialin/protocol='l2tp')" {
        tailf:dependency "../accept-dialin/protocol";
      }

      // vpdn-group * / pptp flow-control
      container flow-control {
        tailf:info "PPTP flow control commands";

        // vpdn-group * / pptp flow-control receive-window
        leaf receive-window {
          tailf:info "Receive window for incoming packets";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;packets";
            range "1..64";
          }
        }

        // vpdn-group * / pptp flow-control static-rtt
        leaf static-rtt {
          tailf:info "Static round trip time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<100-5000>;;milliseconds";
            range "100..5000";
          }
        }
      }

      // vpdn-group * / relay
      container relay {
        tailf:info "Relay options configuration";

        // vpdn-group * / relay ppoe
        container pppoe {
          tailf:info "PPPoE relay options";

          // vpdn-group * / relay ppoe bba-group
          leaf bba-group {
            tailf:info "WORD;;bba-group name for protocol PPPoE";
            type string;
          }
        }
      }

      // vpdn-group * / pptp tunnel
      container tunnel {
        tailf:info "PPTP tunnel commands";

        // vpdn-group * / pptp tunnel echo
        leaf echo {
          tailf:info "Echo packet interval";
          type uint16 {
            tailf:info "<0-1000>;;seconds, default is 60";
            range "0..1000";
          }
          default 60;
        }
      }
    }

    // vpdn-group * / redirect
    container redirect {
      tailf:info "Call redirection options";

      // vpdn-group * / redirect identifier
      leaf identifier {
        tailf:info "WORD;;Redirect identifier name (31 chars max)";
        type string {
          length "1..31";
        }
      }
    }

    // vpdn-group * / source
    container source {
      tailf:info "Configuration source for this vpdn-group";

      // vpdn-group * / source vpdn-template
      leaf vpdn-template {
        tailf:info "Use vpdn-template";
        type string;
      }
    }

    // vpdn-group * / source-ip
    leaf source-ip {
      tailf:info "Set source IP address for this vpdn-group";
      type inet:ipv4-address;
    }

    // vpdn-group * / terminate-from
    container terminate-from {
      tailf:info "";

      // vpdn-group * / terminate-from hostname
      leaf hostname {
        tailf:info "";
        tailf:cli-full-command;
        type string;
      }
    }

    // vpdn-group * / vpn
    container vpn {
      tailf:info "VPN ID/VRF name";

      // vpdn-group * / id
      leaf id {
        tailf:info "VPN ID";
        tailf:cli-full-command;
        type string;
      }

      // vpdn-group * / vrf
      leaf vrf {
        tailf:info "VPN Routing/Forwarding instance name";
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding instance name";
        }
      }
    }
  }


  /// ========================================================================
  /// bba-group
  /// ========================================================================

  container bba-group {
    tailf:info "Configure BBA Group";

    // bba-group pppoe *
    list pppoe {
      tailf:info "PPPoE type";
      key id;
      leaf id {
        type union {
          type string {
            tailf:info "WORD;;BBA Group name";
          }
          type enumeration {
            enum global {
              tailf:info "PPPoE global group";
            }
          }
        }
      }
      container vendor-tag {
        tailf:info "PPPoE Vendor Specific Tag";
        container circuit-id {
          tailf:info "Circuit-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container dsl-sync-rate {
          tailf:info "DSL-Sync-Rate";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        container remote-id {
          tailf:info "Remote-Id";
          leaf service {
            tailf:info "Enable processing";
            type empty;
          }
        }
        leaf strip {
          tailf:info "Strip all vendor tags";
          type empty;
        }
      }
      leaf virtual-template {
        tailf:info "BBA virtual template command";
        type uint16 {
          tailf:info "<1-4095>;;Virtual Template interface number";
          range "1..4095";
        }
      }
    }
  }


  /// ========================================================================
  /// tacacs-server
  /// ========================================================================

  container tacacs-server {
    tailf:info "Modify TACACS query parameters";
    tailf:cli-diff-dependency "../aaa/new-model";

    // tacacs-server administration
    leaf administration {
      tailf:info "Start tacacs+ deamon handling administrative messages";
      type empty;
    }

    // tacacs-server host *
    list host {
      tailf:info "Specify a TACACS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key name;
      leaf name {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of TACACS server";
        }
      }

      // tacacs-server host * port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
      }

      // tacacs-server host * timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply (overrides default)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // tacacs-server host * key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }
    }

    // tacacs-server timeout
    leaf timeout {
      tailf:info "Time to wait for a TACACS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // tacacs-server directed-request
    container directed-request {
      tailf:info "Allow user to specify tacacs server to use with `@server'";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      presence true;
      leaf restricted {
        tailf:info "restrict queries to directed request servers only";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf no-truncate {
        tailf:info "Do not truncate the @hostname from username.";
        type empty;
      }
    }

    // tacacs-server key
    container "key" {
      tailf:info "Set TACACS+ encryption key.";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }

    // tacacs-server last-resort
    leaf last-resort {
      tailf:info "Define TACACS action if no server responds";
      type enumeration {
        enum password {
          tailf:info "The 'enable' password must be provided";
        }
        enum succeed {
          tailf:info "Access to privileged level is granted";
        }
      }
    }
  }


  /// ========================================================================
  /// tacacs
  /// ========================================================================

  container tacacs {
    tailf:info "TACACS server configuration command";
    tailf:cli-diff-dependency "../aaa/new-model";

    // tacacs server *
    list server {
      tailf:info "Server configuration";
      tailf:cli-mode-name "config-server-tacacs";
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name for the tacacs server configuration";
        }
      }

      // tacacs server * / address
      container address {
        tailf:info "Specify ip address for tacacs server";
        choice address-choice {
          leaf ipv4 {
            tailf:info "Configure ipv4 address for tacacs server";
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IP address of tacacs server";
            }
          }
          leaf ipv6 {
            tailf:info "Configure ipv6 address for tacacs server";
            tailf:cli-case-insensitive;
            type inet:host {
              tailf:info "Hostname or X:X:X:X::X;;IP address of tacacs server";
            }
          }
        }
      }

      // tacacs server * / key
      container "key" {
        tailf:info "per-server encryption key (overrides default)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses password-grouping;
      }

      // tacacs server * / port
      leaf port {
        tailf:info "TCP port for TACACS+ server (default is 49)";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Port number";
          range "1..65535";
        }
        default 49;
      }

      // tacacs server * / timeout
      leaf timeout {
        tailf:info "Time to wait for this TACACS server to reply (overrides default)";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
          range "1..1000";
        }
      }

      // tacacs server * / single-connection
      leaf single-connection {
        tailf:info "Multiplex all packets over a single tcp connection to "+
          "server (for CiscoSecure)";
        type empty;
      }

      // tacacs server * / send-nat-address
      leaf send-nat-address {
        tailf:info "To send client's post NAT address to tacacs+ server";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// udld
  /// ========================================================================

  container udld {
    tailf:info "Configure global UDLD setting";

    // udld enable
    leaf enable {
      tailf:info "Enable UDLD protocol on fiber ports except where locally configured";
      type empty;
    }

    // udld aggressive
    leaf aggressive {
      tailf:info "Enable UDLD protocol in aggressive mode on fiber ports "+
        "except where locally configured";
      type empty;
    }

    // udld message time
    container message {
      tailf:info "Set UDLD message parameters";
      leaf time {
        tailf:info "Set UDLD message time period";
        type uint8 {
          tailf:info "<1-90>;;Time in seconds between sending of messages in steady state";
          range "1..90";
        }
      }
    }
  }


  /// ========================================================================
  /// rep
  /// ========================================================================

  container rep {
    tailf:info "Resilient Ethernet Protocol characteristics";

    // rep admin
    container admin {
      tailf:info "administrative configuration";

      // rep admin vlan *
      list vlan {
        tailf:info "VLAN";
        key name;
        leaf name {
          type uint16 {
            tailf:info "<2-4094>;;between 2 and 4094";
            range "2..4094";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// xconnect
  /// ========================================================================

  // xconnect logging
  container xconnect {
    tailf:info "Xconnect config commands";
    container logging {
      tailf:info "Configure logging flags";

      // xconnect logging pseudowire status
      container pseudowire {
        tailf:info "pseudowire status transition logging";
        leaf "status" {
          tailf:info "pseudowire status up/down logging";
          tailf:cli-full-command;
          type empty;
        }
      }

      // xconnect logging redundancy
      leaf redundancy {
        tailf:info "xconnect redundancy events";
        tailf:cli-full-command;
        type empty;
      }
    }
  }


  /// ========================================================================
  /// template
  /// ========================================================================

  list template {
    tailf:info "Select a template to configure";
    tailf:cli-mode-name "config-template";
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Template name";
      }
    }

    // template type pseudowire *
    leaf "type" {
      tailf:info "Type of the template";
      tailf:cli-prefix-key;
      type enumeration {
        enum pseudowire {
          tailf:info "Template customized interface pseudowire";
        }
      }
    }

    // template * / encapsulation
    leaf encapsulation {
      tailf:info "Data encapsulation method";
      type enumeration {
        enum l2tpv3 {
          tailf:info "Use L2TPv3 encapsulation";
        }
        enum mpls {
          tailf:info "Use MPLS encapsulation";
        }
      }
    }

    // template * / mtu
    leaf mtu {
      tailf:info "set Maximum Transmission Unit";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;Maximum Transmission Unit value";
        range "64..65535";
      }
    }

    // template * / control-word
    leaf control-word {
      tailf:info "Control-word options";
      type enumeration {
        enum "exclude" {
          tailf:info "Exclude control-word in pseudowire packets";
        }
        enum "include" {
          tailf:info "Include control-word in pseudowire packets";
        }
      }
    }

    // template * / preferred-path
    container preferred-path {
      tailf:info "Preferred path";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice interface-or-peer {
        leaf interface {
          tailf:info "Output Interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf peer {
          tailf:info "Peer Address";
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address or host name of Peer PE";
          }
        }
      }
      leaf disable-fallback {
        tailf:info "disable fall back to alternative route";
        type empty;
      }
    }

    // template * / signaling protocol
    container signaling {
      tailf:info "Signaling options";
      leaf protocol {
        tailf:info "Signaling protocol to use";
        type enumeration {
          enum ldp {
            tailf:info "Use LDP signaling";
          }
          enum none {
            tailf:info "No signaling, use manually configured pseudowires";
          }
        }
      }
    }

    // dot1x pae authenticator pae
    container dot1x {
      tailf:info "Interface Config Commands for IEEE 802.1X";
      leaf pae {
        tailf:info "Set 802.1x interface pae type";
        type enumeration {
          enum authenticator {
            tailf:info "Set pae type as Authenticator";
          }
          enum supplicant {
            tailf:info "Set pae type as Supplicant";
          }
        }
      }
    }

    // spanning-tree
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";

      // spanning-tree portfast
      container portfast {
        tailf:info "Spanning tree portfast options";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        choice portfast-choice {
          leaf disable {
            tailf:info "Disable portfast for this interface";
            type empty;
          }
          leaf network {
            tailf:info "Enable portfast network on the interface";
            type empty;
          }
          case trunk-mode {
            leaf edge {
              tailf:info "Enable portfast edge on the interface";
              type empty;
            }
            leaf trunk {
              tailf:info "Enable portfast edge on the interface "+
                "even in trunk mode";
              type empty;
            }
          }
        }
      }

      // spanning-tree guard root
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
    }

    // mab
    container mab {
      tailf:info "MAC Authentication Bypass Interface Config Commands";
      tailf:cli-reset-container;
      presence true;
      // mab eap
      leaf eap {
        tailf:info "Use EAP authentication for MAC Auth Bypass";
        type empty;
      }
    }

    // access-session
    container access-session {
      tailf:info "Access Session specific Interface Configuration Commands";

      // access-session port-control
      leaf port-control {
        tailf:info "Set the port-control value";
        type enumeration {
          enum auto {
            tailf:info "PortState set to automatic";
          }
          enum force-authorized {
            tailf:info "PortState set to AUTHORIZED";
          }
          enum force-unauthorized {
            tailf:info "PortState set to UnAuthorized";
          }
        }
      }
    }

    // authentication
    container authentication {
      tailf:info "Auth Manager Interface Configuration Commands";

      // authentication periodic
      leaf periodic {
        tailf:info "Enable or Disable Reauthentication for this port";
        type empty;
      }

      // authentication timer reauthenticate
      container timer {
        tailf:info "Set authentication timer values";
        leaf reauthenticate {
          tailf:info "Time in seconds after which an automatic "+
            "re-authentication should be initiated (default 1 hour)";
          type union {
            type enumeration {
              enum server {
                tailf:info "Obtain re-authentication timeout value from the server";
              }
            }
            type uint16 {
              tailf:info "<1-65535>;;Enter a value between 1 and 65535";
              range "1..65535";
            }
          }
          default 3600;
        }
      }
    }

    // service-policy type control subscriber
    container service-policy {
      tailf:info "Configure CPL Service Policy";
      container "type" {
        tailf:info "Configure CPL Service Policy";
        container control {
          tailf:info "Apply a control policy to the interface";
          leaf subscriber {
            tailf:info "Apply a subscriber control policy to the interfac";
            tailf:non-strict-leafref {
              path "../../../../../policy-map-event-control/policy-map/name";
            }
            type string {
              tailf:info "WORD;;policy-map name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// fabric
  /// ========================================================================

  container fabric {
    tailf:info "Catalyst 6000 crossbar fabric configuration commands";

    // fabric switching-mode
    container switching-mode {
      tailf:info "Switching mode settings";
      container allow {
        tailf:info "Allow settings";
        choice allow-choice {
          leaf bus-mode {
            tailf:info "Allow switching in bus mode for modules";
            type empty;
          }
          container truncated {
            tailf:info "Truncated switching mode";
            presence true;
            leaf threshold {
              tailf:info "Number of SFM-capable modules for truncated "
                +"switching mode. Switch applies the threshold only when the "
                +"mode is disallowed. Switch ignores the threshold when the "
                +"truncated mode is allowed";
              type uint8 {
                tailf:info "<1-9>;;Threshold for truncated switching mode.";
                range "1..9";
              }
            }
          }
        }
      }
      container force {
        tailf:info "Force modules to different switching modes";
        leaf bus-mode {
          tailf:info "Switching mode of service modules will be forced to bus-"
            +"mode by powercycling it.";
          type empty;
        }
      }
    }

    // fabric buffer-reserve
    container buffer-reserve {
      tailf:info "Reserve FIFO buffer";

      // fabric buffer-reserve queue
      leaf queue {
        tailf:info "Queue setting for buffer reserve";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// port-channel
  /// ========================================================================

  container port-channel {
    tailf:info "EtherChannel configuration";

    // port-channel per-module load-balance
    container per-module {
      tailf:info "per-module configuration";
      leaf load-balance {
        tailf:info "Load Balance Enable";
        type empty;
      }
    }

    // port-channel load-balance
    leaf load-balance {
      tailf:info "Load Balancing method";
      type enumeration {
        enum dst-ip {
          tailf:info "Dst IP Addr";
        }
        enum dst-mac {
          tailf:info "Dst Mac Addr";
        }
        enum dst-mixed-ip-port {
          tailf:info "Dst IP Addr and TCP/UDP Port";
        }
        enum dst-port {
          tailf:info "Dst TCP/UDP Port";
        }
        enum mpls {
          tailf:info "Load Balancing for MPLS packets";
        }
        enum src-dst-ip {
          tailf:info "Src XOR Dst IP Addr";
        }
        enum src-dst-mac {
          tailf:info "Src XOR Dst Mac Addr";
        }
        enum src-dst-mixed-ip-port {
          tailf:info "Src XOR Dst IP Addr and TCP/UDP Port";
        }
        enum src-dst-port {
          tailf:info "Src XOR Dst TCP/UDP Port";
        }
        enum src-ip {
          tailf:info "Src IP Addr";
        }
        enum src-mac {
          tailf:info "Src Mac Addr";
        }
        enum src-mixed-ip-port {
          tailf:info "Src IP Addr and TCP/UDP Port";
        }
        enum src-port {
          tailf:info "Src TCP/UDP Port";
        }
      }
    }

    // port-channel load-balance-hash-algo
    leaf load-balance-hash-algo {
      tailf:info "Algorithm selection for FBLB";
      type string;
    }
  }


  /// ========================================================================
  /// l2protocol-tunnel
  /// ========================================================================

  container l2protocol-tunnel {
    tailf:info "Tunnel Layer2 protocols";

    // l2protocol-tunnel cos
    leaf cos {
      tailf:info "Class of Service";
      type uint8 {
        tailf:info "<0-7>;;priority value";
        range "0..7";
      }
    }

    // l2protocol-tunnel global
    container global {
      tailf:info "Global settings";
      leaf drop-threshold {
        tailf:info "L2PT packets drop threshold";
        type uint16 {
          tailf:info "<100-20000>;;Packets per second";
          range "100..20000";
        }
      }
    }
  }


  /// ========================================================================
  /// l2vpn
  /// ========================================================================

  // l2vpn
  container l2vpn {
    tailf:info "Layer2 VPN commands";
    tailf:cli-add-mode;
    tailf:cli-full-command;
    presence true;
  }

  // l2vpn vfi
  container l2vpn-vfi {
    tailf:cli-drop-node-name;
    container l2vpn {
      container vfi {
        tailf:info "Configure a Virtual Forwarding Instance (VFI)";

        // l2vpn vfi context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-vfi";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Virtual Forwarding Instance (VFI) name";
            }
          }

          // l2vpn vfi context * / vpn id
          container vpn {
            tailf:info "VPN configuration";
            leaf id {
              tailf:info "VPN id";
              type uint32 {
                tailf:info "<1-4294967295>;;VPN id value";
                range "1..4294967295";
              }
            }
          }

          // l2vpn vfi context * / autodiscovery bgp signaling
          container autodiscovery {
            tailf:info "Auto Discovery mode";
            container bgp {
              tailf:info "Use BGP for neighbor discovery";
              container signaling {
                tailf:info "Signaling protocol to use";
                tailf:cli-add-mode;
                tailf:cli-mode-name "config-vfi-autodiscovery";
                presence true;
                choice protocol-choice {
                  // l2vpn vfi context * / autodiscovery bgp signaling bgp
                  leaf bgp {
                    tailf:info "Use BGP signaling";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                  // l2vpn vfi context * / autodiscovery bgp signaling ldp
                  leaf ldp {
                    tailf:info "Use LDP signaling";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                }
                // l2vpn vfi context * / autodiscovery bgp signaling * template
                leaf template {
                  tailf:info "Template to be used for autodiscovered pseudowires";
                  tailf:cli-hide-in-submode;
                  tailf:non-strict-leafref {
                    path "../../../../../../../../template/name";
                  }
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / ve
                container ve {
                  tailf:info "Specify VPLS Edge device parameters";
                  leaf id {
                    tailf:info "Specify VPLS Edge device ID";
                    type uint16 {
                      tailf:info "<1-16384>;;VPLS Edge device ID value";
                      range "1..16384";
                    }
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling ldp / vpls-id
                leaf vpls-id {
                  tailf:info "Specify VPLS-ID Extendended Community";
                  tailf:cli-full-command;
                  type asn-ip-type {
                    tailf:info "ASN:nn or IP-address:nn;;Specify VPLS-ID Extendended Community";
                  }
                }

                // l2vpn vfi context * / autodiscovery bgp signaling bgp / route-target
                container route-target {
                  tailf:info "Specify Route Target VPN Extended Communities";
                  uses route-target-grouping;
                }
              }
            }
          }

          // l2vpn vfi context * / member
          container member {
            tailf:info "Configure the cross connect member";

            // l2vpn vfi context * / member *
            list ip-address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key ip-address;
              leaf ip-address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }

            // l2vpn vfi context * / member *
            list ip-address-vc-id-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip-address vc-id";
              leaf ip-address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }

            // l2vpn vfi context * / member pseudowire *
            list pseudowire {
              tailf:info "Pseudowire interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              key name;
              leaf name {
                tailf:non-strict-leafref {
                  path "../../../../../../../interface/pseudowire/name";
                }
                type uint32 {
                  tailf:info "<1-231072>;;Pseudowire interface number";
                  range "1..231072";
                }
              }
              leaf ip-address {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vc-id {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                }
              }
              choice encapsulation-template-choice {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "Template to use for encapsulation and protocol configuration";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }
            }
          }

          // l2vpn vfi context * / mtu
          leaf mtu {
            type uint16 {
              tailf:info "<1500-9180>;;Maximum Transmission Unit value";
              range "1500..9180";
            }
          }
        }
      }
    }
  }

  // l2vpn xconnect
  container l2vpn-xconnect {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container xconnect {
        tailf:info "Configure a cross connect";

        // l2vpn xconnect context *
        list context {
          tailf:info "Layer2 VPN Context";
          tailf:cli-mode-name "config-xconnect";
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Configure the cross connect name";
            }
          }

          // l2vpn xconnect context * / no remote link failure notification
          container remote {
            tailf:info "L2VPN remote peer configuration commands";
            container link {
              tailf:info "Link information";
              container failure {
                tailf:info "Failure information";
                leaf "notification" {
                  tailf:info "Notify in case of remote link failure";
                  tailf:cli-boolean-no;
                  type boolean;
                  default true;
                }
              }
            }
          }

          // l2vpn xconnect context * / interworking
          leaf interworking {
            tailf:info "Interworking options for the cross connect";
            tailf:cli-full-command;
            type enumeration {
              enum ethernet {
                tailf:info "Ethernet interworking";
              }
              enum ip {
                tailf:info "IP interworking";
              }
              enum vlan {
                tailf:info "VLAN interworking";
              }
            }
          }

          // l2vpn xconnect context * / member
          container member {
            tailf:info "Configure the cross connect member";

            // l2vpn xconnect context * / member <ifname> *
            list member-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface name";
                  pattern "(GigabitEthernet.*)|(Port-channel.*)"+
                    "|(TenGigabitEthernet.*)|(Vlan.*)|(Ethernet.*)"+
                    "|(FastEthernet.*)|(HundredGigE.*)";
                }
              }
              leaf service-instance {
                tailf:info "Ethernet Service Instance";
                tailf:cli-optional-in-sequence;
                tailf:cli-diff-dependency "../../../../../../../interface/Ethernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/FastEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/GigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/TenGigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/FortyGigabitEthernet/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/HundredGigE/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/Port-channel/service/instance";
                tailf:cli-diff-dependency "../../../../../../../interface/Vlan/service/instance";
                type uint32 {
                  tailf:info "<1-4000>;;Service Instance ID";
                }
              }
              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member "+
                    "(0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }

            // l2vpn xconnect context * / member pseudowire *
            list pseudowire {
              tailf:info "Pseudowire Interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-allow-join-with-key {
                tailf:cli-display-joined;
              }
              key name;
              leaf name {
                type uint32 {
                  tailf:info "<1-231072>;;Pseudowire interface number";
                  range "1..231072";
                }
              }
            }

            // l2vpn xconnect context * / member A.B.C.D *
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              key name;
              leaf name {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address of the peer";
                }
              }
              leaf vcid {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter VC ID value";
                  range "1..4294967295";
                }
              }

              choice encap-or-termplate {
                leaf encapsulation {
                  tailf:info "Data encapsulation method";
                  type enumeration {
                    enum mpls {
                      tailf:info "Use MPLS encapsulation";
                    }
                  }
                }
                leaf template {
                  tailf:info "template to use for encapsulation and protocol configuration";
                  type string {
                    tailf:info "WORD;;template name (Max size 32)";
                  }
                }
              }

              leaf group {
                tailf:info "Configure the cross connect member redundancy group";
                type string {
                  tailf:info "WORD;;Enter redundancy group name";
                }
              }
              leaf priority {
                tailf:info "Configure the cross connect member priority";
                type uint8 {
                  tailf:info "<0-16>;;Enter priority number of the member "+
                    "(0: Highest, 16: Lowest)";
                  range "0..16";
                }
              }
            }
          }

          // l2vpn xconnect context * / redundancy
          container redundancy {
            tailf:info "Xconnect redundancy information";

            // l2vpn xconnect context * / redundancy predictive
            leaf predictive {
              tailf:info "Switch over to backup member without waiting "+
                "for UP status";
              type enumeration {
                enum disabled {
                  tailf:info "Disable predictive switchover capability "+
                  "for this xconnect";
                }
                enum enabled {
                  tailf:info "Enable predictive switchover capability "+
                  "for this xconnect";
                }
              }
            }

            // l2vpn xconnect context * / redundancy delay
            list delay {
              tailf:info "Xconnect redundancy delay parameters";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key group;
              leaf group {
                tailf:info "Redundancy group name";
                tailf:cli-expose-key-name;
                type string {
                  tailf:info "Redundancy group name";
                }
              }
              leaf enable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type uint8 {
                  tailf:info "<0-180>;;Enable delay";
                  range "0..180";
                }
              }
              leaf disable-delay {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type union {
                  type uint8 {
                    tailf:info "<0-180>;;Disable delay";
                    range "0..180";
                  }
                  type enumeration {
                    enum never {
                      tailf:info "Disallow disable";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // l2vpn evpn
  container l2vpn-evpn {
    tailf:cli-drop-node-name;
    container l2vpn {
      tailf:info "Layer2 VPN commands";
      container evpn {
        tailf:info "Ethernet Virtual Private Network (EVPN) configuration";

        // l2vpn evpn instance * point-to-point
        list instance {
          tailf:info "EVPN instance (EVI)";
          tailf:cli-incomplete-command;
          tailf:cli-mode-name "config-evpn-evi";
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-65535>;;EVPN instance identifier value";
              range "1..65535";
            }
          }
          leaf point-to-point {
            tailf:info "EVPN Virtual Private Wire Service (EVPN VPWS)";
            tailf:cli-hide-in-submode;
            type empty;
          }

          // l2vpn evpn instance * point-to-point / vpws context *
          container vpws {
            tailf:info "EVPN Virtual Private Wire Service configuration";
            list context {
              tailf:info "EVPN VPWS context";
              tailf:cli-mode-name "config-evpn-vpws";
              tailf:cli-full-command;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;EVPN VPWS context name";
                }
              }

              // l2vpn evpn instance * point-to-point / vpws context * / service
              container service {
                tailf:info "VPWS Service Instance";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf target {
                  tailf:info "Target (remote) VPWS Service Instance identifier";
                  tailf:cli-incomplete-command;
                  type uint32 {
                    tailf:info "<1-16777215>;;Target VPWS Service Instance identifier value";
                    range "1..16777215";
                  }
                }
                leaf source {
                  tailf:info "Source (local) VPWS Service Instance identifier";
                  type uint32 {
                    tailf:info "<1-16777215>;;Source VPWS Service Instance identifier value";
                    range "1..16777215";
                  }
                }
              }

              // l2vpn evpn instance * point-to-point / vpws context * / member
              container member {
                tailf:info "EVPN member configuration";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf interface {
                  tailf:cli-drop-node-name;
                  tailf:cli-remove-before-change;
                  type string {
                    tailf:info "WORD;;Interface name";
                  }
                }
                leaf service-instance {
                  tailf:info "Ethernet Service Instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Ethernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/FastEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/GigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/TenGigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/FortyGigabitEthernet/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/HundredGigE/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Port-channel/service/instance";
                  tailf:cli-diff-dependency "../../../../../../../../interface/Vlan/service/instance";
                  type uint16 {
                    tailf:info "<1-4000>;;Service Instance ID";
                    range "1..4000";
                  }
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// segment-routing
  /// ========================================================================

  // segment-routing mpls
  container segment-routing {
    tailf:info "Enter Segment Routing Mode";
    container mpls {
      tailf:info "Segment Routing MPLS Mode";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-srmpls";
      presence true;

      // segment-routing mpls / shutdown
      leaf shutdown {
        tailf:info "SR Shutdown";
        type empty;
      }

      // segment-routing mpls / global-block
      container global-block {
        tailf:info "SR Global Block Config";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf start {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-remove-before-change;
          type uint16 {
            tailf:info "<16-32767>;;SR GB Label Range Start";
            range "16..32767";
          }
        }
        leaf end {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<16-32767>;;SR GB Label Range End";
            range "16..32767";
          }
        }
      }

      // segment-routing mpls / connected-prefix-sid-map
      container connected-prefix-sid-map {
        tailf:info "Enter Connected Prefix Sid Map  Mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-srmpls-conn";

        // segment-routing mpls / connected-prefix-sid-map / address-family ipv4
        container address-family {
          tailf:info "Enter Address Family command mode";
          container ipv4 {
            tailf:info "Address Family";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-srmpls-conn-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family command mode";
            }

            // segment-routing mpls / connected-prefix-sid-map / address-family ipv4 / *
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              tailf:cli-incomplete-command;
              key "prefix";
              leaf "prefix" {
                type ios:ipv4-prefix {
                  tailf:info "A.B.C.D/nn;;Starting Prefix";
                }
              }
              choice absolute-or-index {
                leaf absolute {
                  tailf:info "SID Absolute";
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID";
                    range "0..1048575";
                  }
                }
                leaf index {
                  tailf:info "SID Index";
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID";
                    range "0..1048575";
                  }
                }
              }
              leaf "range" {
                tailf:info "Set # of SIDs in range";
                type uint32 {
                  tailf:info "<1-1048575>;;Range value";
                  range "1..1048575";
                }
              }
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// system
  /// ========================================================================

  container system {
    tailf:info "Set the system configuration";

    // system env
    container env {
      tailf:info "Set the system environment settings";
      container temperature {
        tailf:info "Set the system temperature settings";
        container threshold {
          tailf:info "Set the system temperature thresholds";
          leaf yellow {
            tailf:info "Set the yellow threshold";
            type uint8 {
              tailf:info "<0-25>;;Delta value from Red threshold in Degree "
                +"Celsius";
              range "0..25";
            }
          }
        }
      }
    }

    // system mtu
    container mtu {
      tailf:info "Set the system Maximum Transmission Unit (MTU)";
      leaf size {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1500-1998>;;MTU size in bytes";
          range "1500..1998";

        }
      }

      // system mtu jumbo
      leaf jumbo {
        tailf:info "Set Jumbo MTU value for GigabitEthernet or TenGigabitEthernet interfaces";
        type uint16 {
          tailf:info "<1500-9000>;;Jumbo MTU size in bytes";
          range "1500..9000";
        }
      }

      // system mtu routing
      leaf routing {
        tailf:info "Set the Routing MTU for the system";
        type uint16 {
          tailf:info "<NUM>;;MTU size in bytes";
        }
      }
    }

    // system flowcontrol bus auto
    container flowcontrol {
      container bus {
        leaf auto {
          type empty;
        }
      }
    }

    // system jumbomtu
    leaf jumbomtu {
      tailf:info "Configure system jumbo mtu size";
      type uint16 {
        tailf:info "<1500-9216>;;Jumbo mtu size in Bytes, default is 9216";
        range "1500..9216";
      }
    }
  }


  /// ========================================================================
  /// stackmaker
  /// ========================================================================

  container stackmaker {
    tailf:info "Specify stack name and add its member";

    // stackmaker name
    leaf name {
      tailf:info "Specify stack name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the stack";
      }
    }
  }


  /// ========================================================================
  /// diagnostic
  /// ========================================================================

  container diagnostic {
    tailf:info "Configure diagnostic information";

    // diagnostic bootup level
    container bootup {
      tailf:info "Configure diagnostic for bootup";
      leaf level {
        tailf:info "Select diagnostic level";
        type enumeration {
          enum complete {
            tailf:info "Complete level";
          }
          enum minimal {
            tailf:info "Minimal level";
          }
        }
      }
    }

    // diagnostic cns
    container cns {
      tailf:info "Configure diagnostic cns information";
      leaf publish {
        tailf:info "Configure diagnostic cns publish";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
      leaf subscribe {
        tailf:info "Configure diagnostic cns subscribe";
        type string {
          tailf:info "WORD;;Diagnostic cns subject";
        }
      }
    }

    // diagnostic monitor syslog
    container monitor {
      tailf:info "Configure diagnostic monitoring tests";
      leaf syslog {
        tailf:info "Configure diagnostic monitoring syslog";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// errdisable
  /// ========================================================================

  container errdisable {
    tailf:info "Error disable";

    // errdisable detect cause
    container detect {
      tailf:info "Error disable detection";
      container cause {
        tailf:info "Enable error disable detection for application";
        leaf all {
          tailf:info "Enable error detection on all cases";
          tailf:cli-full-command;
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable error detection for arp inspection";
          tailf:cli-full-command;
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable error detection on bpdu-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable error detection on dhcp-rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable error detection on dtp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable error detection on gbic-invalid";
          tailf:cli-full-command;
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable error detection for inline-power";
          tailf:cli-full-command;
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "+
            "disable state";
          tailf:cli-full-command;
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable error detection on linkstate-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf loopback {
          tailf:info "Enable error detection on loopback";
          tailf:cli-full-command;
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        leaf pagp-flap {
          tailf:info "Enable error detection on pagp-flapping";
          tailf:cli-full-command;
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable error detection on PPPoE IA rate-limit";
          tailf:cli-full-command;
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable error detection on 802.1x-guard";
          tailf:cli-full-command;
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable error detection on SFP config mismatch";
          tailf:cli-full-command;
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable error detection on small_frame";
          tailf:cli-full-command;
          type empty;
        }
      }
    }

    // errdisable flap-setting
    container flap-setting {
      tailf:info "Error disable flap detection setting";
      container cause {
        tailf:info "Set error disable flap parameters for application";
        container dtp-flap {
          tailf:info "Set the variables related to detection of dtp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container link-flap {
          tailf:info "Set the variables related to detection of link flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
        container pagp-flap {
          tailf:info "Set the variables related to detection of pagp flaps";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf max-flaps {
            tailf:info "maximum flaps allowed before setting to errdisable";
            type uint8 {
              tailf:info "<1-100>;;flap count";
              range "1..100";
            }
          }
          leaf time {
            tailf:info "time period the flaps are counted";
            type uint8 {
              tailf:info "<1-120>;;flap count time";
              range "1..120";
            }
          }
        }
      }
    }

    // errdisable recovery
    container recovery {
      tailf:info "Error disable recovery";
      // errdisable recovery cause
      container cause {
        tailf:info "Enable error disable recovery for application";
        leaf all {
          tailf:info "Enable timer to recover from all error causes";
          type empty;
        }
        leaf arp-inspection {
          tailf:info "Enable timer to recover from arp inspection error "
            +"disable state";
          type empty;
        }
        leaf bpduguard {
          tailf:info "Enable timer to recover from BPDU Guard error";
          type empty;
        }
        leaf channel-misconfig {
          tailf:info "(STP)  Enable timer to recover from channel misconfig "
            +"error";
          type empty;
        }
        leaf dhcp-rate-limit {
          tailf:info "Enable timer to recover from dhcp-rate-limit error";
          type empty;
        }
        leaf dtp-flap {
          tailf:info "Enable timer to recover from dtp-flap error";
          type empty;
        }
        leaf gbic-invalid {
          tailf:info "Enable timer to recover from invalid GBIC error";
          type empty;
        }
        leaf inline-power {
          tailf:info "Enable timer to recover from inline-power error";
          type empty;
        }
        leaf l2ptguard {
          tailf:info "Enable timer to recover from l2protocol-tunnel error "
            +"disable state";
          type empty;
        }
        leaf link-flap {
          tailf:info "Enable timer to recover from link-flap error";
          type empty;
        }
        leaf link-monitor-failure {
          type empty;
        }
        leaf loopback {
          tailf:info "Enable timer to recover from loopback error";
          type empty;
        }
        leaf mac-limit {
          tailf:info "Enable timer to recover from mac limit disable state";
          type empty;
        }
        leaf mlacp-minlink {
          tailf:cli-full-command;
          type empty;
        }
        container oam-remote-failure {
          tailf:cli-display-separated;
          presence true;
          leaf critical-event {
            tailf:cli-full-command;
            type empty;
          }
          leaf dying-gasp {
            tailf:cli-full-command;
            type empty;
          }
          leaf link-fault {
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf pagp-flap {
          tailf:info "Enable timer to recover from pagp-flap error";
          type empty;
        }
        leaf port-mode-failure {
          tailf:info "Enable timer to recover from port mode change failure";
          type empty;
        }
        leaf pppoe-ia-rate-limit {
          tailf:info "Enable timer to recover from PPPoE IA rate-limit error";
          type empty;
        }
        leaf psp {
          type empty;
        }
        leaf psecure-violation {
          tailf:info "Enable timer to recover from psecure violation error";
          type empty;
        }
        leaf security-violation {
          tailf:info "Enable timer to recover from 802.1x violation error";
          type empty;
        }
        leaf sfp-config-mismatch {
          tailf:info "Enable timer to recover from SFP config mismatch error";
          type empty;
        }
        leaf small-frame {
          tailf:info "Enable timer to recover from small frame error";
          type empty;
        }
        leaf storm-control {
          tailf:info "Enable timer to recover from storm-control error";
          type empty;
        }
        leaf udld {
          tailf:info "Enable timer to recover from udld error";
          type empty;
        }
        leaf unicast-flood {
          //fixme tailf:info
          type empty;
        }
        leaf vmps {
          tailf:info "Enable timer to recover from vmps shutdown error";
          type empty;
        }
      }
      leaf interval {
        tailf:info "Error disable recovery timer value";
        type uint32 {
          tailf:info "<30-86400>;;timer-interval(sec)";
          range "30..86400";
        }
      }
    }
  }


  /// ========================================================================
  /// monitor
  /// ========================================================================

  container monitor {
    tailf:info "Monitoring different system events";

    // monitor session *
    list session {
      tailf:info "Configure a SPAN session";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-1024>;;SPAN session number";
          range "1..1024";
        }
      }

      // monitor session * destination *
      list destination {
        tailf:info "SPAN destination interface or VLAN";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;monitor session string";
          }
        }
      }

      // monitor session * source *
      list source {
        tailf:info "SPAN source interface, VLAN ";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;monitor session string";
          }
        }
      }

      // monitor session * filter
      container filter {
        tailf:info "SPAN filter";

        // monitor session * filter vlan *
        leaf-list vlan {
          tailf:info "SPAN filter VLAN";
          tailf:cli-range-list-syntax;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-4094>;;SPAN source VLAN";
            range "1..4094";
          }
        }

        // monitor session * filter packet-type
        container packet-type {
          tailf:info "SPAN filter packet-type";

          // monitor session * filter packet-type good rx
          container good {
            tailf:info "Monitor the good packets only";
            tailf:cli-diff-dependency "../bad" {
              tailf:cli-trigger-on-set;
            }
            leaf rx {
              tailf:info "Monitor received traffic only";
              type empty;
            }
          }

          // monitor session * filter packet-type bad rx
          container bad {
            tailf:info "Monitor the bad packets only";
            tailf:cli-diff-dependency "../good" {
              tailf:cli-trigger-on-set;
            }
            leaf rx {
              tailf:info "Monitor received traffic only";
              type empty;
            }
          }
        }

        // monitor session * filter ip access-group
        container ip {
          tailf:info "Specify IP Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type exp-ip-acl-type;
          }
        }

        // monitor session * filter mac access-group
        container mac {
          tailf:info "Specify MAC Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type string {
              tailf:info "WORD;;ACL name";
            }
          }
        }

        // monitor session * filter ipv6 access-group
        container ipv6 {
          tailf:info "Specify IPv6 Access control rules";
          leaf access-group {
            tailf:info "Specify access control group";
            type string {
              tailf:info "WORD;;ACL name";
            }
          }
        }
      }
    }

    // monitor session * type local
    container session-local {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-mode-name "config-mon-local";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1>;;SPAN session number";
            range "1";
          }
        }
        leaf "type" {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum local {
              tailf:info "Local SPAN Session";
            }
          }
        }

        // monitor session * type local / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type local / source interface
        container source {
          tailf:info "SPAN source";
          container interface {
            tailf:info "SPAN destination interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-name-grouping;
            leaf "hyphen" {
              tailf:alt-name "-";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Last port number in range";
                range "1..65535";
              }
            }
          }
        }

        // monitor session * type local / destination interface
        container destination {
          tailf:info "SPAN destination";
          container interface {
            tailf:info "SPAN destination interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-name-grouping;
            leaf "hyphen" {
              tailf:alt-name "-";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Last port number in range";
                range "1..65535";
              }
            }
          }
        }
      }
    }

    // monitor session * type erspan-source
    container session-erspan-source {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-mode-name "config-mon-erspan-src";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf "type" {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum erspan-source {
              tailf:info "Encapsulated RSPAN Source Session";
            }
          }
        }

        // monitor session * type erspan-source / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type erspan-source / source interface
        container source {
          tailf:info "SPAN source";
          container interface {
            tailf:info "SPAN destination interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses interface-name-grouping;
            leaf "hyphen" {
              tailf:alt-name "-";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf port {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1-65535>;;Last port number in range";
                range "1..65535";
              }
            }
          }
        }

        // monitor session * type erspan-source / destination
        container destination {
          tailf:info "Specify Destination and their properties";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mon-erspan-src-dst";
          tailf:cli-full-command;

          // monitor session * type erspan-source / destination / erspan-id
          leaf erspan-id {
            tailf:info "Enter ERSPAN Identifier";
            type uint16 {
              tailf:info "<1-1023>;;Erspan ID";
              range "1..1023";
            }
          }

          // monitor session * type erspan-source / destination / mtu
          leaf mtu {
            tailf:info "Set the limitation size of ERSPAN encapsulation";
            type uint16 {
              tailf:info "<64-9180>;;MTU size in bytes";
              range "64..9180";
            }
          }

          // monitor session * type erspan-source / destination / ip
          container ip {
            tailf:info "IP Properties";

            // monitor session * type erspan-source / destination / ip address
            leaf address {
              tailf:info "Enter IP Address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
          }

          // monitor session * type erspan-source / destination / origin ip address
          container origin {
            tailf:info "Origin IP Properties";
            container ip {
              tailf:info "Origin IP Properties";
              leaf address {
                tailf:info "Enter IP Address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
            }
          }
        }
      }
    }

    // monitor session * type erspan-destination
    container session-erspan-destination {
      tailf:cli-drop-node-name;
      list session {
        tailf:info "Configure a SPAN session";
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-mode-name "config-mon-erspan-src";
        key id;
        leaf id {
          tailf:cli-suppress-range;
          type uint16 {
            tailf:info "<1-1024>;;SPAN session number";
            range "1..1024";
          }
        }
        leaf "type" {
          tailf:info "Type of monitor session";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum erspan-destination {
              tailf:info "Encapsulated RSPAN Destination Session";
            }
          }
        }

        // monitor session * type erspan-destination / shutdown
        leaf shutdown {
          tailf:info "Shutdown this session";
          type empty;
        }

        // monitor session * type erspan-destination / source
        container source {
          tailf:info "Specify Source and their properties";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-mon-erspan-dst-src";
          tailf:cli-full-command;

          // monitor session * type erspan-destination / destination / erspan-id
          leaf erspan-id {
            tailf:info "Enter ERSPAN Identifier";
            type uint16 {
              tailf:info "<1-1023>;;Erspan ID";
              range "1..1023";
            }
          }

          // monitor session * type erspan-destination / destination / ip address
          container ip {
            tailf:info "IP Properties";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf address {
              tailf:info "Enter IP Address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf force {
              tailf:info "Change source IP Address for all ERSPAN Destination Sessions";
              type empty;
            }
          }
        }
      }
    }

    // monitor session
    container session-conf {
      tailf:cli-drop-node-name;
      container session {
        tailf:info "Configure a SPAN session";

        // no monitor session servicemodule
        leaf servicemodule {
          tailf:info "Use SPAN to enable service module";
          tailf:cli-boolean-no;
          tailf:cli-full-command;
          type boolean;
          default true;
        }
      }
    }

    // monitor event-trace *
    container event-trace {
      tailf:info "Tracing of system events";
      list event-trace-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;event trace entry";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// network-clock
  /// ========================================================================

  container network-clock {
    tailf:info "Network clock config commands";

    // network-clock revertive
    leaf revertive {
      tailf:info "Reference clock reverts to the highest QL/priority after "+
        "failure";
      tailf:cli-full-command;
      type empty;
    }

    // network-clock synchronization
    container synchronization {
      tailf:info "Network clock synchronization selection process";

      // network-clock synchronization automatic
      leaf automatic {
        tailf:info "ITU-T G.781/Telcordia standard based synchronization "+
          "selection process";
        type empty;
      }

      // network-clock synchronization mode
      container mode {
        tailf:info "synchronization networking mode";
        leaf QL-enabled {
          tailf:info "QL-enabled mode";
          type empty;
        }
      }
    }

    // network-clock input-source *
    list input-source {
      tailf:info "Synchronization Input Source";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key priority;
      leaf priority {
        type uint8 {
          tailf:info "<1-250>;;Priority";
          range "1..250";
        }
      }

      // network-clock input-source * interface
      container interface {
        tailf:info "Specify Ethernet, Sonet or ToP Interface";
        uses interface-name-grouping;
      }

      // network-clock input-source * ptp domain
      container ptp {
        tailf:info "Select a PTP Clock as a Frequency Clock Source";
        leaf domain {
          tailf:info "Domain Number for the PTP Clock Source";
          type uint8 {
            tailf:info "<0-127>;;PTP Clock Domain Number";
            range "0..127";
          }
        }
      }
    }

    // network-clock output-source system *
    container output-source {
      tailf:info "Synchronization output Source";
      list system {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key priority;
        leaf priority {
          type uint8 {
            tailf:info "<1-250>;;Priority";
            range "1..250";
          }
        }

        // network-clock output-source system * External *
        list External {
          tailf:info "External Interface (BITS/SSU/GPS)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type union {
              type string {
                tailf:info "<slot>/<card>/<port>;;Enter 0 if card or port "+
                  "parameter is not valid";
              }
              type enumeration {
                enum "R0" {
                  tailf:info "netsync RP0 bits source slot";
                }
                enum "R1" {
                  tailf:info "netsync RP1 bits source slot";
                }
              }
            }
          }

          // network-clock output-source system * External * e1
          leaf e1 {
            tailf:info "E1 Signal Mode";
            type enumeration {
              enum cas {
                tailf:info "E1 Channel Associated Signal Mode";
              }
              enum crc4 {
                tailf:info "E1 With CRC4 Signal Mode";
              }
              enum fas {
                tailf:info "E1 Frame Alignment Signal Mode";
              }
            }
          }

          // network-clock output-source system * External * ohms
          leaf ohms {
            tailf:cli-drop-node-name;
            type enumeration {
              enum "120ohms" {
                tailf:info "120 ohms";
              }
              enum "75ohms" {
                tailf:info "75 ohms";
              }
            }
          }

          // network-clock output-source system * External * linecode
          leaf linecode {
            tailf:info "linecode option";
            type enumeration {
              enum ami {
                tailf:info "linecode ami";
              }
              enum hdb3 {
                tailf:info "linecode hdb3";
              }
            }
          }
        }
      }
    }

    // network-clock wait-to-restore
    container wait-to-restore {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-86400>;;sec (default 300 seconds)";
          range "0..86400";
        }
      }
      leaf global {
        tailf:info "Global";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// esmc
  /// ========================================================================

  container esmc {
    tailf:info "Ethernet Synchronization Messaging Channel";

    // esmc process
    leaf process {
      tailf:info "process";
      type empty;
    }
  }


  /// ========================================================================
  /// netconf-yang
  /// ========================================================================

  container netconf-yang {
    tailf:info "Enable netconf-yang";

    // netconf-yang / cisco-ia
    container cisco-ia {
      tailf:info "Configure cisco-ia parameters";

      // netconf-yang / cisco-ia snmp-trap-control
      container snmp-trap-control {
        tailf:info "Configuration parameters for SNMP trap to NetConf notification processing";

        // netconf-yang / cisco-ia snmp-trap-control trap-list
        leaf trap-list {
          tailf:info "Configure translation of SNMP Traps to NetConf notifications";
          type string {
            tailf:info "WORD;;Enter SNMP trap OID string";
          }
        }
      }
    }

    // netconf-yang / cisco-odm
    container cisco-odm {
      tailf:info "Configure cisco-odm parameters";

      // netconf-yang / cisco-odm actions
      leaf actions {
        tailf:info "Configure cisco-odm actions";
        type string {
          tailf:info "WORD;;Enter action string";
        }
      }
    }
  }


  /// ========================================================================
  /// tftp-server
  /// ========================================================================

  list tftp-server {
    tailf:info "Provide TFTP service for netload requests";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-compact-syntax;
    key name;
    leaf name {
      type string {
        tailf:info "Allow URL file TFTP load requests";
      }
    }
    leaf alias {
      tailf:info "file alias";
      type string {
        tailf:info "WORD;;file alias";
      }
    }
    leaf access-list {
      tailf:cli-drop-node-name;
      tailf:cli-disallow-value "alias";
      type std-ip-acl-type;
    }
  }


  /// ========================================================================
  /// radius-server
  /// ========================================================================

  container radius-server {
    tailf:info "Modify RADIUS query parameters";

    // radius-server load-balance method least-outstanding
    container load-balance {
      tailf:info "Radius load-balancing options.";
      container method {
        tailf:info "Method by which the next host will be picked.";
        container least-outstanding {
          tailf:info "Pick the server with the least transactions outstanding.";
          presence true;
        }
      }
    }

    // radius-server attribute *
    container attribute {
      tailf:info "Customize selected radius attributes";
      list attribute-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "NUM;;attribute id";
          }
        }

        // radius-server attribute * on-for-login-auth
        leaf on-for-login-auth {
          tailf:info "Send attribute 6 in authentication packet";
          type empty;
        }

        // radius-server attribute * support-multiple
        leaf support-multiple {
          tailf:info "Support multiple Service-Type values per Radius profile";
          type empty;
        }

        // radius-server attribute * mandatory
        leaf "mandatory" {
          tailf:info "Enforce Service-Type attribute in Access-Accep";
          type empty;
        }

        // radius-server attribute * include-in-access-req
        leaf include-in-access-req {
          tailf:info "Send attribute 8 in access-req packet";
          type empty;
        }

        // radius-server attribute * access-request
        container access-request {
          tailf:info "Access-Request packet";
          leaf "include" {
            tailf:info "Include attribute";
            type empty;
          }
        }
      }
    }

    // radius-server dead-criteria
    container dead-criteria {
      tailf:info "Set the criteria used to decide when a radius server is"+
        "marked dead";
      tailf:cli-compact-syntax;
      leaf time {
        tailf:info "The time during which no properly formed response must "+
          "be recieved from the RADIUS server";
        type uint8 {
          tailf:info "<1-120>;;Time in seconds during which no response must "+
            "be recieved from the RADIUS server in order to consider it dead";
          range "1..120";
        }
      }
      leaf tries {
        tailf:info "The number of times the router must fail to recieve a "+
          "response from the radius server to mark it as dead";
        type uint8 {
          tailf:info "<1-100>;;Number of transmits to radius server without "+
            "responses before marking server as dead";
          range "1..100";
        }
      }
    }

    // radius-server deadtime
    leaf deadtime {
      tailf:info "Time to stop using a server that doesn't respond";
      type uint16 {
        tailf:info "<1-1440>;;time in minutes";
        range "1..1440";
      }
    }

    // radius-server host *
    list host {
      tailf:info "Specify a RADIUS server";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key id;
      leaf id {
        type inet:host {
          tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
        }
      }
      uses radius-server-grouping;
    }

    // radius-server retransmit
    leaf retransmit {
      tailf:info "Specify the number of retries to active server";
      type uint8 {
        tailf:info "<0-100>;;Number of retries for a transaction "+
          "(default is 3)";
        range "0..100";
      }
      default 3;
    }

    // radius-server timeout
    leaf timeout {
      tailf:info "Time to wait for a RADIUS server to reply";
      type uint16 {
        tailf:info "<1-1000>;;Wait time (default 5 seconds)";
        range "1..1000";
      }
      default 5;
    }

    // radius-server vsa
    container vsa {
      tailf:info "Vendor specific attribute configuration";

      // radius-server vsa send
      container send {
        tailf:info "Send vendor-specific attributes in requests";
        leaf accounting {
          tailf:info "Send in accounting requests";
          type empty;
        }
        leaf authentication {
          tailf:info "Send in access requests";
          type empty;
        }
      }
    }

    // radius-server key
    container "key" {
      tailf:info "encryption key shared with the RADIUS servers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      uses password-grouping;
    }
  }


  /// ========================================================================
  /// radius
  /// ========================================================================

  container radius {
    tailf:info "RADIUS server configuration command";

    // radius filter *
    list filter {
      tailf:info "Packet filter configuration";
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the filter (max 31 characters, longer will "
            +"be rejected";
        }
      }
      leaf match {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Filter if all of the attributes matches";
          }
          enum match-any {
            tailf:info "Filter if any of the attributes matches";
          }
        }
      }
    }

    // radius server *
    list server {
      tailf:info "Server configuration";
      key "id";
      leaf id {
        type string {
          tailf:info "WORD;;Name for the radius server configuration";
        }
      }

      // radius server * address
      container address {
        tailf:info "Specify the radius server address";
        container ipv4 {
          tailf:info "IPv4 Address";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf host {
            tailf:cli-drop-node-name;
            type inet:host {
              tailf:info "Hostname or A.B.C.D;;IPv4 Address of radius server";
            }
          }
          // alias      1-8 aliases for this server (max. 8)
          leaf auth-port {
            tailf:info "UDP port for RADIUS authentication server (default is "
              +"1645)";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
          leaf acct-port {
            tailf:info "UDP port for RADIUS accounting server (default is "
              +"1646)";
            type uint16 {
              tailf:info "<0-65535>;;Port number";
              range "0..65535";
            }
          }
        }
      }

      // radius server * backoff
      container backoff {
        tailf:info "Retry backoff pattern(Default is retransmits with constant "
          +"delay)";
        container exponential {
          tailf:info "Exponential retransmit backoff";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          presence true;
          leaf max-delay {
            tailf:cli-optional-in-sequence;
            tailf:info "Max delay between retransmits(default is 3 min)";
            type uint8 {
              tailf:info "<1-120>;;Max time (in minutes) to delay between "
                +"retransmits";
              range "1..120";
            }
          }
          leaf backoff-retry {
            tailf:info "Exponential backoff retry number(default is 8)";
            type uint8 {
              tailf:info "<1-50>;;Number of retransmits in the exponential "
                +"backoff mode";
              range "1..50";
            }
          }
        }
      }

      // radius server * key
      container "key" {
        tailf:info "Per-server encryption key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf "type" {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type enumeration {
            enum "0" {
              tailf:info "Specifies an UNENCRYPTED key will follow";
            }
            enum "5" {
              tailf:info "Specifies a HIDDEN key will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          tailf:cli-reset-container;
          tailf:cli-full-command;
          tailf:cli-disallow-value "0|5";
          tailf:meta-data "secret-password";
          type string {
            tailf:info "LINE;;The UNCRYPTED (cleartext) shared key";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// zone
  /// ========================================================================

  container zone {
    tailf:info "FW with zoning";

    // zone security *
    list security {
      tailf:info "Security zone";
      tailf:cli-mode-name "config-sec-zone";
      tailf:cli-full-command;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of security zone";
        }
      }

      // zone security * / description
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
        }
      }

      // zone security * / protection
      leaf protection {
        tailf:info "config syn cookie protection against sync flood";
        tailf:cli-diff-dependency "../../../parameter-map";
        type string {
          tailf:info "WORD;;parameter map name";
        }
      }
    }
  }


  /// ========================================================================
  /// zone-pair
  /// ========================================================================

  container zone-pair {
    tailf:info "Zone pair command";

    // zone-pair security *
    list security {
      tailf:info "Zone-pair name";
      tailf:cli-mode-name "config-sec-zone-pair";
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of zone-pair";
        }
      }

      // zone-pair security * source
      leaf source {
        tailf:info "Source zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "../../../zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of source zone";
        }
      }

      // zone-pair security * destination
      leaf destination {
        tailf:info "Destination zone";
        tailf:cli-hide-in-submode;
        tailf:non-strict-leafref {
          path "../../../zone/security/id";
        }
        type string {
          tailf:info "WORD;;Name of destination zone";
        }
      }

      // zone-pair security * / description
      leaf "description" {
        tailf:info "Zone description";
        tailf:cli-break-sequence-commands;
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of zone (up to 200 characters)";
          length "1..200";
        }
      }

      // zone-pair security * / service-policy
      container service-policy {
        tailf:info "Configure CBAC Service Policy";
        container "type" {
          tailf:info "Service Policy type";
          leaf inspect {
            tailf:info "Configure CBAC Service Policy type inspect";
            tailf:cli-remove-before-change;
            tailf:non-strict-leafref {
              path "../../../../../policy-map/name";
            }
            type string {
              tailf:info "WORD;;output Policy-map name";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alarm-contact
  /// ========================================================================

  list alarm-contact {
    tailf:info "Configure the system alarm contact settings";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    tailf:cli-incomplete-command;
    key name;
    leaf name {
      type union {
        type uint8 {
          tailf:info "<1-4>;;Alarm contact number";
          range "1..4";
        }
        type enumeration {
          enum all {
            tailf:info "Configure all alarm contacts";
          }
        }
      }
    }

    // alarm-contact * description
    leaf "description" {
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
        length "1..80";
      }
    }

    // alarm-contact * severity
    leaf severity {
      tailf:info "Set the severity level reported";
      type enumeration {
        enum critical {
          tailf:info "Critical alarm severity";
        }
        enum major {
          tailf:info "Major alarm severity";
        }
        enum minor {
          tailf:info "Minor alarm severity";
        }
      }
    }

    // alarm-contact * trigger
    leaf trigger {
      tailf:info "Set the alarm trigger";
      type enumeration {
        enum closed {
          tailf:info "Assert alarm when contact is closed";
        }
        enum open {
          tailf:info "Assert alarm when contact is open";
        }
      }
    }
  }


  /// ========================================================================
  /// mpls
  /// ========================================================================

  container mpls {
    tailf:info "Configure MPLS parameters";

    // mpls atm
    container atm {
      tailf:info "Configure ATM options";
      leaf disable-headend-vc {
        tailf:info "Dedicated lsc capability: In this mode "
          +"headend Tag VCs are disabled.";
        type empty;
      }
    }

    // mpls cos-map
    leaf cos-map {
      tailf:info "Configure MPLS CoS ATM Multi-VC CoS Map";
      tailf:cli-full-command;
      type uint8 {
        range "1..255" {
          tailf:info "<1-255>;;cos-map number";
        }
      }
    }

    // no mpls ip
    leaf ip {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // mpls ip
    container mpls-ip-conf {
      tailf:cli-drop-node-name;
      container ip {
        tailf:info "Dynamic MPLS forwarding for IP";
        tailf:cli-incomplete-no;
        tailf:cli-incomplete-command;

        // mpls ip default-route
        leaf default-route {
          tailf:info "Allow MPLS forwarding for ip default route";
          tailf:cli-full-command;
          type empty;
        }

        choice propagate-ttl-choice {
          // no mpls ip propagate-ttl
          container propagate-ttl-conf {
            tailf:cli-drop-node-name;
            leaf propagate-ttl {
              tailf:info "Propagate IP TTL into the label stack";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
          // no mpls ip propagate-ttl forwarded
          container propagate-ttl {
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf forwarded {
              tailf:info "Propagate IP TTL for forwarded traffic";
              tailf:cli-boolean-no;
              tailf:cli-full-command;
              type boolean;
              default true;
            }
          }
        }

        // mpls ip ttl-exp
        container ttl-expiration {
          tailf:info "Control MPLS TTL expiration behavior";
          leaf pop {
            tailf:info "Popping labels on TTL expiration";
            type uint8 {
              tailf:info "<1-6>;;Popping all labels if original "
                +"packet has less than N labels";
              range "1..6";
            }
          }
        }
      }
    }

    // mpls label
    container label {
      tailf:info "Label properties";

      // mpls label atm
      container atm {
        tailf:info "Configure ATM options";
        leaf disable-headend-vc {
          tailf:info "Dedicated lsc capability: In this mode "
            +"headend Tag VCs are disabled.";
          type empty;
        }
      }

      // mpls label protocol
      leaf protocol {
        tailf:info "Set platform default label distribution protocol";
        tailf:cli-full-command;
        type enumeration {
          enum ldp {
            tailf:info "Use LDP (default)";
          }
          enum tdp {
            tailf:info "Use TDP";
          }
        }
      }

      // mpls label range
      container "range" {
        tailf:info "Label range";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16-1048575>;;Minimum label value";
            range "16..1048575";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-1048575>;;Maximum label value";
            range "16..1048575";
          }
        }
        leaf static {
          tailf:info "Specify block of labels for static bindings";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf static-min {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "NUM;;Upper minimum static label value";
          }
        }
        leaf static-max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "NUM;;Maximum static label value";
          }
        }
      }
    }

    // mpls ldp
    container ldp {
      tailf:info "Label Distribution Protocol";

      // no mpls ldp advertise-labels
      leaf advertise-labels {
        tailf:cli-boolean-no;
        tailf:cli-full-command;
        type boolean;
        default true;
      }

      // mpls ldp nsr
      leaf nsr {
        tailf:info "Enable Non Stop Routing for LDP";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp advertise-labels
      container advertise-labels-conf {
        tailf:cli-drop-node-name;
        container advertise-labels {
          tailf:info "Label advertisements";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;

          // mpls ldp advertise-labels for
          container "for" {
            tailf:info "Access-list specifying controls on "
              +"destination prefixes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf from {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;IP access-list for destination"+
                  " prefixes; name or number (1-99)";
              }
            }
            leaf to {
              tailf:info "Access-list specifying controls on LDP peers";
              type string {
                tailf:info "WORD;;IP access-list for LDP peers;"
                  +" name or number (1-99)";
              }
            }
          }

          // mpls ldp advertise-labels interface
          container interface {
            tailf:info "Advertise /32 interface address";
            uses interface-name-grouping;
          }

          // mpls ldp advertise-labels oldstyle
          leaf oldstyle {
            tailf:info "Use old style (TDP) method for matching prefix acl";
            tailf:cli-full-command;
            type empty;
          }
        }
      }

      // mpls ldp password
      container password {
        tailf:info "Configure LDP MD5 password";

        // mpls ldp password required
        container required {
          tailf:info "MD5 password is required for the peer";
          presence true;
        }

        // mpls ldp password fallback
        container fallback  {
          tailf:info "Specifies a fallback password will follow";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          choice fallback-choice {
            // mpls ldp password fallback key-chain
            leaf key-chain {
              tailf:info "Specifies a key-chain name will follow";
              tailf:cli-full-command;
              type string {
                tailf:info "LINE;;name of key-chain";
              }
              tailf:non-strict-leafref {
                path "../../../../../key/chain/name";
              }
            }
            // mpls ldp password fallback [0|7] <secret>
            case password-case {
              uses password-grouping;
            }
          }
        }
      }

      // mpls ldp atm
      container atm {
        tailf:info "Configure ATM MPLS options";

        // mpls ldp atm control-mode
        leaf control-mode {
          tailf:info "Select LSP setup control mode for MPLS VCs";
          tailf:cli-full-command;
          type enumeration {
            enum independent {
              tailf:info "Independent Downstream on Demand Label VC setup";
            }
            enum ordered {
              tailf:info "Ordered Dowstream on Demand Label VC setup";
            }
          }
          //default "ordered";
        }

        // no mpls ldp atm vc-merge
        leaf vc-merge {
          tailf:info "Select VC merge capability";
          tailf:cli-full-command;
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }

      // mpls ldp backoff
      container backoff {
        tailf:info "Set LDP session backoff parameters";
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        leaf initial {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<5-2147483>;;Initial session backoff time (seconds)";
            range "5..2147483";
          }
        }
        leaf max {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<5-2147483>;;Maximum session backoff time (seconds)";
            range "5..2147483";
          }
        }
      }

      // mpls ldp discovery
      container discovery {
        tailf:info "LDP discovery";
        container hello {
          tailf:info "LDP discovery Hello";
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds";
              range "1..65535";
            }
          }
        }
        container targeted-hello {
          tailf:info "LDP discovery Targeted Hello";
          container accept {
            tailf:info "Accept targeted hellos";
            tailf:cli-delete-when-empty;
            presence "Accept targeted hellos";
            leaf from {
              tailf:info "Access list to specify acceptable "
                +"targeted hello sources";
              type string {
                tailf:info "WORD;;IP access-list for "
                  +"acceptable targeted hello sources";
              }
            }
          }
          leaf holdtime {
            tailf:info "LDP discovery Hello holdtime";
            type uint16 {
              tailf:info "<1-65535>;;Holdtime in seconds";
              range "1..65535";
            }
          }
          leaf interval {
            tailf:info "LDP discovery Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;Hello interval in seconds";
              range "1..65535";
            }
          }
        }
      }

      // mpls ldp explicit-null
      container explicit-null {
        tailf:info "Advertise Explicit Null label in place of Implicit Null";
        tailf:cli-delete-when-empty;
        presence true;
        leaf "for" {
          tailf:info "Access-list specifying controls on destination prefixes";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
        leaf "to" {
          tailf:info "Access-list specifying controls on LDP peers";
          type string {
            tailf:info "WORD;;IP access-list for LDP "
              +"peers; name or number (1-99)";
          }
        }
      }

      // mpls ldp loop-detection
      leaf loop-detection {
        tailf:info "Enable LDP Loop Detection";
        tailf:cli-full-command;
        type empty;
      }

      // mpls ldp graceful-restart
      container graceful-restart {
        tailf:info "Configure Graceful Restart timers";
        presence "Configure Graceful Restart timers";
        container timers {
          tailf:info "Configure Graceful Restart timers";
          leaf forwarding-holding {
            tailf:info "Forwarding State Holding time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<30-600>;;seconds";
              range "30..600";
            }
          }
          leaf max-recovery {
            tailf:info "Max-Recovery time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-600>;;seconds";
              range "15..600";
            }
          }
          leaf neighbor-liveness {
            tailf:info "Neighbor-Liveness time";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<5-300>;;seconds";
              range "5..600";
            }
          }
        }
      }

      // mpls ldp holdtime
      leaf holdtime {
        tailf:info "LDP session holdtime";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<15-2147483>;;Holdtime in seconds";
          range "15..2147483";
        }
      }

      // mpls ldp logging
      container logging {
        tailf:info "Enable LDP logging";
        leaf neighbor-changes {
          tailf:info "Log LDP neighbor state changes";
          type empty;
        }
      }

      // mpls ldp maxhops
      leaf maxhops {
        tailf:info "Limit hop count for LDP LSP setup";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-255>;;Maximum hop count value";
        }
      }

      // mpls ldp neighbor *
      list neighbor {
        tailf:info "Configure neighbor parameters";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address for LDP neighbor";
          }
        }

        // mpls ldp neighbor * implicit-withdraw
        leaf implicit-withdraw {
          tailf:info "Enable LDP Implicit Withdraw Label";
          tailf:cli-full-command;
          type empty;
        }

        // mpls ldp neighbor * labels accept
        container labels {
          tailf:info "Configure label binding exchange controls";
          leaf accept {
            tailf:info "Specify label bindings to accept";
            type string {
              tailf:info "WORD;;IP access-list for LDP "
                +"peers; name or number (1-99)";
            }
          }
        }

        // mpls ldp neighbor * password
        container password {
          tailf:info "Set a password";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses password-grouping;
        }

        // mpls ldp neighbor * targeted
        container targeted {
          tailf:info "Establish targeted session";
          tailf:cli-delete-when-empty;
          presence "Establish targeted session";
          leaf protocol {
            tailf:cli-drop-node-name;
            type enumeration {
              // mpls ldp neighbor * targeted ldp
              enum ldp {
                tailf:info "User LDP";
              }
              // mpls ldp neighbor * targeted tdp
              enum tdp {
                tailf:info "Use TDP";
              }
            }
          }
        }
      }

      // mpls ldp request-labels for
      container request-labels {
        tailf:info "Access list to specify valid downstream "
          +"on demand destinations.";
        leaf "for" {
          tailf:info "Access list to specify acceptable "
            +"downstream on demand destinations";
          type string {
            tailf:info "WORD;;IP access-list for destination "
              +"prefixes; name or number (1-99)";
          }
        }
      }

      // mpls ldp router-id
      container router-id {
        tailf:info "Select interface to prefer for LDP "
          +"identifier address";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf interface {
          tailf:cli-drop-node-name;
          tailf:cli-diff-dependency "../../../../interface";
          type string {
            tailf:info "WORD;;intrace name";
          }
        }
        leaf force {
          tailf:info "Forcibly change the LDP router id";
          type empty;
        }
      }

      // mpls ldp session protection
      container session {
        tailf:info "Configure session parameters";
        container protection {
          tailf:info "Configure session protection parameters";
          tailf:cli-compact-syntax;
          presence true;
          // mpls ldp session protection duration
          leaf duration {
            tailf:info "Period to sustain session protection after loss of "+
              "link discovery";
            type union {
              type enumeration {
                enum "infinite" {
                  tailf:info "Protect session forever after loss of "+
                    "link discovery";
                }
              }
              type uint32 {
                tailf:info "<30-2147483>;;Holdup time in seconds";
                range "30..2147483";
              }
            }
          }
        }
      }

      // mpls ldp label
      container label {
        tailf:info "LDP label mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ldp-lbl";
        container allocate {
          tailf:info "Allocate local labels for specified destination prefixes";
          container global {
            tailf:info "Specify global Routing/Forwarding instance";
            tailf:cli-delete-when-empty;
            presence true;
            choice global-choice {
              leaf host-routes {
                tailf:info "allocate local label for host routes only";
                type empty;
              }
              leaf prefix-list {
                tailf:info "Specify a prefix list for local label filtering";
                type string {
                  tailf:info "WORD;;IP prefix-list for destination prefixes; "+
                    "name or number (1-99)";
                }
              }
            }
          }
        }
      }

      // mpls ldp igp sync holddown
      container igp {
        tailf:info "Configure IGP-related LDP parameters";
        container sync {
          tailf:info "Configure LDP-IGP Synchronization parameters";
          leaf holddown {
            tailf:info "Configure the LDP-IGP Synchronization holddown time";
            type uint32 {
              tailf:info "<1-2147483647>;;Hold down time in milliseconds";
            }
          }
        }
      }
    }

    // mpls prefix-map
    container prefix-map {
      tailf:info "Configure MPLS CoS Tag-VC Multi-VC Prefix Map";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf nr {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;prefix-map number";
          range "1..255";
        }
      }
      leaf access-list {
        tailf:info "Configure access-list for this prefix-map";
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-255>;;access-list number";
          range "1..255";
        }
      }
      leaf cos-map {
        tailf:info "Configure cos-map for this prefix-map";
        type uint8 {
          tailf:info "<1-255>;;cos-map number";
          range "1..255";
        }
      }
    }

    // mpls traffic-eng
    container traffic-eng {
      tailf:info "Configure Traffic Engineering parameters";

      // mpls traffic-eng auto-bw timers
      container auto-bw {
        tailf:info "auto-bw parameters";
        container timers {
          tailf:info "Enable auto-bw Timers Collection and "
            +"Application";
          presence "Enable auto-bw Timers Collection and Application";
          leaf frequency {
            tailf:info "Interval between auto-bw data collection";
            type uint32 {
              tailf:info "<1-604800>;;seconds between auto-bw";
              range "1..604800";
            }
          }
        }
      }

      // mpls traffic-eng link-management timers
      container link-management {
        tailf:info "Link Management configuration";
        container timers {
          tailf:info "Link Management timers configuration";
          leaf bandwidth-hold {
            tailf:info "Link Management bandwidth hold timer";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-300>;;seconds";
              range "1..300";
            }
          }
          leaf periodic-flooding {
            tailf:info "Link Management periodic flooding interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<0-3600>;;seconds";
              range "0..3600";
            }
          }
        }
      }

      // mpls traffic-eng logging
      container logging {
        tailf:info "Trap logging configuration";

        // mpls traffic-eng logging lsp
        container lsp {
          tailf:info "LSP-specific traps logging configuration";
          container path-errors {
            tailf:info "Log LSP Path Error traps";
            presence "Log LSP Path Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container preemption {
            tailf:info "Log LSP Preemption traps";
            presence "Log LSP Preemption traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container reservation-errors {
            tailf:info "Log LSP Reservation Error traps";
            presence "Log LSP Reservation Error traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container setups {
            tailf:info "Log LSP Establishment Traps";
            presence "Log LSP Establishment Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container teardowns {
            tailf:info "Log LSP Teardown Traps";
            presence "Log LSP Teardown Traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
        }

        // mpls traffic-eng logging tunnel
        container tunnel {
          tailf:info "Tunnel-specific traps logging configuration";
          container lsp-selection {
            tailf:info "Log Tunnel LSP Selection traps";
            presence "Log Tunnel LSP Selection traps";
            leaf access-list {
              tailf:cli-drop-node-name;
              type exp-ip-acl-type;
            }
          }
          container "path" {
            tailf:info "Log Tunnel Path-related traps";
            container change {
              tailf:info "Log Tunnel Path change traps";
              presence "Log Tunnel Path change traps";
              leaf access-list {
                tailf:cli-drop-node-name;
                type exp-ip-acl-type;
              }
            }
          }
        }
      }

      // mpls traffic-eng auto-tunnel
      container auto-tunnel {
        tailf:info "Configure automatic TE tunnels";

        // mpls traffic-eng auto-tunnel backup
        leaf backup {
          tailf:info "Configure auto-tunnel backup tunnel";
          tailf:cli-full-command;
          type empty;
        }

        // mpls traffic-eng auto-tunnel backup X
        container backup-conf {
          tailf:cli-drop-node-name;
          container backup {
            tailf:info "Configure auto-tunnel backup tunnel";
            tailf:cli-incomplete-no;
            tailf:cli-incomplete-command;

            // mpls traffic-eng auto-tunnel backup nhop-only
            leaf nhop-only {
              tailf:info "Automatically create n-hop backup tunnels only";
              type empty;
            }

            // mpls traffic-eng auto-tunnel backup tunnel-num
            container tunnel-num {
              tailf:info "Configure tunnel I/F numbers for backup auto-tunnels";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf min {
                tailf:info "Configure the starting id-range";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;starting tunnel number range";
                }
              }
              leaf max {
                tailf:info "Configure the ending id-range";
                type uint16 {
                  tailf:info "<0-65535>;;ending tunnel number range";
                }
              }
            }
          }
        }

        // mpls traffic-eng auto-tunnel primary
        container primary {
          tailf:info "Automatically create one-hop primary tunnels";

          // mpls traffic-eng auto-tunnel primary config mpls ip
          container "config" {
            tailf:info "Config commands to apply to all primary auto-tunnels";
            container mpls {
              tailf:info "Configure dynamic MPLS forwarding";
              leaf ip {
                tailf:info "Configure dynamic MPLS forwarding for ip";
                type empty;
              }
            }
          }

          // mpls traffic-eng auto-tunnel primary tunnel-num
          container tunnel-num {
            tailf:info "Configure tunnel I/F numbers for primary auto-tunnels";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf min {
              tailf:info "Configure the starting id-range";
              type uint16 {
                tailf:info "<0-65535>;;starting tunnel number range";
              }
            }
            leaf max {
              tailf:info "Configure the ending id-range";
              type uint16 {
                tailf:info "<0-65535>;;ending tunnel number range";
              }
            }
          }
        }
      }

      // mpls traffic-eng path-selection
      container path-selection {
        tailf:info "Path Selection Configuration";

        // mpls traffic-eng path-selection metric
        leaf metric {
          tailf:info "Metric Type Configuration";
          tailf:cli-full-command;
          type enumeration {
            enum igp {
              tailf:info "Use IGP metric";
            }
            enum te {
              tailf:info "User TE metric";
            }
          }
          default te;
        }

        // mpls traffic-eng path-selection overload allow
        container overload {
          tailf:info "Overload Node Configuration";
          leaf allow {
            tailf:info "Allow overloaded nodes in CSPFs";
            type enumeration {
              enum head {
                tailf:info "Allow overloaded head node in TE CSPF";
              }
              enum middle {
                tailf:info "Allow overloaded middle node in TE CSPF";
              }
              enum tail {
                tailf:info "Allow overloaded middle node in TE CSPF";
              }
            }
          }
        }
      }

      // mpls traffic-eng reoptimize
      container reoptimize {
        tailf:info "Reoptimization parameters";

        // mpls traffic-eng reoptimize events
        container events {
          tailf:info "Reoptimization triggers";
          leaf link-up {
            tailf:info "Reoptimize tunnels on link up events";
            type empty;
          }
        }

        // mpls traffic-eng reoptimize timers
        container timers {
          tailf:info "Reoptimization timers";
          container delay {
            tailf:info "Delay reoptimization action";
            leaf cleanup {
              tailf:info "Delay cleanup of reoptimized LSP";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-60>;;seconds to delay "
                  +"cleanup of replaced tunnel LSP";
                range "0..60";
              }
            }
            leaf installation {
              tailf:info "Delay replacement of current LSP "
                +"by reoptimized LSP";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<0-3600>;;seconds to delay "
                  +"replacement of tunnel LSP";
                range "0..3600";
              }
            }
          }
          leaf frequency {
            tailf:info "Interval between reoptimization scans";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;seconds between "
                +"reoptimizations (0 disables reoptimization)";
              range "0..604800";
            }
          }
        }
      }

      // mpls traffic-eng signalling
      container signalling {
        tailf:info "Traffic Engineering Signalling Parameters";

        // mpls traffic-eng signalling advertise
        container advertise {
          tailf:info "Signalling advertisement parameters";
          container implicit-null {
            tailf:info "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            presence  "Use MPLS encoding for Implicit-Null "
              +"Label in signalling messages";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }

        // mpls traffic-eng signalling forwarding
        container forwarding {
          tailf:info "Control interaction of LSP signalling and "
            +"LFIB maintenance";
          leaf sync {
            tailf:info "Program linecard LFIBs before signalling "
              +"LSP label upstream";
            type empty;
          }
        }

        // mpls traffic-eng signalling restart
        container restart {
          tailf:info "Signalling restart parameters";
          container neighbors {
            tailf:info "Identify signalling restart capable "
              +"neighbors";
            presence "Identify signalling restart capable "
              +"neighbors";
            leaf nr {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-99>;;Number of IP access-list "
                  +"to determine applicable signalling peers";
                range "1..99";
              }
            }
          }
        }
      }

      // mpls traffic-eng topology
      container topology {
        tailf:info "Topology Database Configuration";
        container holddown {
          tailf:info "Topology Database hold down timers";
          leaf sigerr {
            tailf:info "Link hold down time for signalling errors";
            type uint16 {
              tailf:info "<0-300>;;Hold down time in seconds";
              range "0..300";
            }
          }
        }
      }

      // mpls traffic-eng tunnels
      leaf tunnels {
        tailf:info "Traffic Engineering tunnels";
        tailf:cli-full-command;
        type empty;
      }
    }

    // mpls propagate-cos
    leaf propagate-cos {
      type empty;
    }

    // mpls discovery vpn
    container discovery {
      tailf:info "Configure LSP discovery";
      container vpn {
        tailf:info "Configure Layer 3 VPN LSP discovery";

        // mpls discovery vpn interval
        leaf interval {
          tailf:info "Configure discovery refresh interval";
          type uint32 {
            tailf:info "<1-86400>;;Refresh interval in seconds";
            range "1..86400";
          }
        }

        leaf next-hop {
          tailf:info "Configure Layer 3 VPN LSP discovery";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// clns
  /// ========================================================================

  container clns {
    tailf:info "Global CLNS configuration subcommands";

    // clns routing
    leaf routing {
      tailf:info "Enable clns routing";
      type empty;
    }

    // clns filter-set *
    list filter-set {
      tailf:info "Define CLNS filter set";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of filter set";
        }
      }
      // clns filter-set * permit|deny
      leaf operation {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum deny {
            tailf:info "Deny matching addresses";
          }
          enum permit {
            tailf:info "Permit matching addresses";
          }
        }
      }
      leaf template {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Address template to filter";
        }
      }
    }
  }


  /// ========================================================================
  /// l3-over-l2
  /// ========================================================================

  container l3-over-l2 {
    tailf:info "L3 over L2 specific configuration";
    container flush {
      tailf:info "configure whether L3 buffers should be flushed";
      leaf buffers {
        tailf:info "Enable flushing of L3 buffers for L3-over-L2 support";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// l3vpn
  /// ========================================================================

  container l3vpn {
    tailf:info "l3vpn encapsulation ip commands";
    container encapsulation {
      tailf:info "l3vpn encapsulation ip";

      // l3vpn encapsulation ip *
      list ip {
        tailf:info "l3vpn encapsulation ip";
        tailf:cli-mode-name "config-l3vpn-encap-ip";
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;profile name";
          }
        }

        // l3vpn encapsulation ip * / transport ipv4
        container transport {
          tailf:info "transport mode";
          container ipv4 {
            tailf:info "transport ipv4 mode";
            presence true;
            // l3vpn encapsulation ip * / transport ipv4 source
            container source {
              tailf:info "transport source";
              uses interface-name-grouping;
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// router
  /// ========================================================================

  container router {
    tailf:info "Enable a routing process";
    //when "not(../../ip/routing) or (../../ip/routing = 'true')" {
    //tailf:dependency "../../ip/routing";
    //}

    // router mobile
    container mobile {
      tailf:info "Mobile routes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      presence true;
    }

    /// router bgp
    // router bgp *
    list bgp {
      tailf:info "Border Gateway Protocol (BGP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      tailf:cli-diff-dependency "../../route-map";
      tailf:cli-diff-dependency "../../ip/prefix-list";
      max-elements 1;
      key as-no;
      leaf as-no {
        tailf:cli-suppress-range;
        tailf:cli-diff-dependency "/ios:router/bgp" {
          tailf:cli-trigger-on-set;
        }
        type bgp-as-no-type;
      }

      // router bgp * / template
      container template {
        tailf:info "Enter template command mode";

        // router bgp * / template peer-policy *
        list peer-policy {
          tailf:info "Template configuration for policy parameters";
          tailf:cli-mode-name "config-router-ptmp";
          tailf:cli-exit-command "exit-peer-policy" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-policy template";
            }
          }
          leaf peer-group {
            tailf:hidden all;
            type empty;
          }
          leaf remote-as {
            tailf:hidden all;
            type empty;
          }
          leaf activate {
            tailf:hidden all;
            type empty;
          }

          // router bgp * / template peer-policy * / inherit
          container inherit {
            tailf:info "Inherit a template";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-diff-dependency "../peer-group";
            tailf:cli-diff-dependency "../remote-as";
            tailf:cli-diff-dependency "../activate";
            leaf peer-policy {
              tailf:info "Inherit a peer-policy template";
              tailf:cli-incomplete-command;
              tailf:non-strict-leafref {
                path "../../../peer-policy/name";
              }
              type string {
                tailf:info "WORD;;Template name";
              }
            }
            leaf sequence {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Sequence number";
                range "1..65535";
              }
            }
            leaf peer-session {
              tailf:hidden all;
              type empty; // to make cli-diff-dep happy
            }
          }
          uses router-bgp-peer-policy-grouping;
        }

        // router bgp * / template peer-session *
        list peer-session {
          tailf:info "Template configuration for session parameters";
          tailf:cli-mode-name "config-router-stmp";
          tailf:cli-exit-command "exit-peer-session" {
            tailf:info "Exit from template configuration mode";
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of peer-session template";
            }
          }

          // router bgp * / template peer-session * / remote-as
          leaf remote-as {
            tailf:info "Specify a BGP neighbor";
            tailf:cli-full-command;
            type string {
              tailf:info "AS of remote neighbor";
            }
          }
          leaf peer-group {
            tailf:hidden all;
            type empty;
          }
          leaf activate {
            tailf:hidden all;
            type empty;
          }

          // router bgp * / template peer-session * / description
          uses description-grouping;

          // router bgp * / template peer-session * / inherit
          container inherit {
            tailf:info "Inherit a template";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-diff-dependency "../peer-group";
            tailf:cli-diff-dependency "../remote-as";
            tailf:cli-diff-dependency "../activate";
            leaf peer-session {
              tailf:info "Inherit a peer-session template";
              tailf:non-strict-leafref {
                path "../../../peer-session/name";
              }
              type string {
                tailf:info "WORD;;Template name";
              }
            }
          }
          uses router-bgp-peer-session-grouping;
        }
      }

      // router bgp * / bgp
      uses router-bgp-bgp-grouping;

      // router bgp * /
      uses router-bgp-af-grouping {
        refine "neighbor/password/text" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router bgp <bgp><NL><*> ::  neighbor <neighbor> password <PASSWORD>";
          }
        }
        refine "neighbor-tag/neighbor/password/text" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router bgp <bgp><NL><*> ::  neighbor <neighbor> password <PASSWORD>";
          }
        }
      }

      // router bgp * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router bgp * / address-family ipv4 *
        list ipv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum mdt {
                tailf:info "IPv4 multicast distribution tree (MDT)";
              }
              enum tunnel {
                tailf:info "IPv4 tunnel address prefixes.";
              }
              enum labeled-unicast {
                tailf:info "IPv4 labeled-unicast address prefixes";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
              enum mvpn {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family ipv6 *
        list ipv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          tailf:cli-diff-dependency "../../../../ipv6/unicast-routing";
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
              enum mvpn {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family ipv4 vrf *
        container with-vrf {
          tailf:cli-drop-node-name;
          list ipv4 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            key af;
            leaf af {
              tailf:key-default "unicast";
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
                enum mdt {
                  tailf:info "IPv4 multicast distribution tree (MDT)";
                }
                enum tunnel {
                  tailf:info "IPv4 tunnel address prefixes.";
                }
                enum labeled-unicast {
                  tailf:info "IPv4 labeled-unicast address prefixes";
                }
                enum flowspec {
                  tailf:info "Address Family modifier";
                }
              }
            }
            // router bgp * / address-family ipv4 vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-delete-when-empty;
              tailf:cli-full-command;
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses router-bgp-bgp-grouping;
              uses router-bgp-af-grouping {
                refine "neighbor" {
                  tailf:cli-diff-dependency "../../../../../neighbor";
                  tailf:cli-diff-dependency "../../../../../../../ip/vrf/rd";
                }
                refine "neighbor/password/text" {
                  tailf:meta-data "secret-password" {
                    tailf:meta-value "router bgp <bgp><NL><*> address-family ipv4(?: <ipv4>)? vrf <vrf><NL><*> ::   neighbor <neighbor> password <PASSWORD>";
                  }
                }
              }
            }
          }
        }

        // router bgp * / address-family ipv6 * vrf *
        container ipv6-with-vrf {
          tailf:cli-drop-node-name;
          list ipv6 {
            tailf:info "Address family";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            tailf:cli-diff-dependency "../../../../../ipv6/unicast-routing";
            key af;
            leaf af {
              type enumeration {
                enum unicast {
                  tailf:info "Address Family modifier";
                }
                enum multicast {
                  tailf:info "Address Family modifier";
                }
                enum flowspec {
                  tailf:info "Address Family modifier";
                }
              }
              tailf:key-default "unicast";
            }
            // router bgp * / address-family ipv6 * vrf *
            list vrf {
              tailf:cli-mode-name "config-router-af";
              tailf:cli-delete-when-empty;
              tailf:cli-full-command;
              tailf:cli-exit-command "exit-address-family" {
                tailf:info "Exit from Address Family configuration mode";
              }
              key name;
              leaf name {
                tailf:cli-diff-dependency "../../../../../../../vrf/definition";
                tailf:cli-diff-dependency "../../../../../../../ip/vrf";
                type string {
                  tailf:info "WORD;;VPN Routing/Forwarding instance name";
                }
              }
              uses router-bgp-bgp-grouping;
              uses router-bgp-af-grouping {
                refine "neighbor" {
                  tailf:cli-diff-dependency "../../../../../neighbor";
                }
                refine "neighbor/password/text" {
                  tailf:meta-data "secret-password" {
                    tailf:meta-value "router bgp <bgp><NL><*> address-family ipv6(?: <ipv6>)? vrf <vrf><NL><*> ::   neighbor <neighbor> password <PASSWORD>";
                  }
                }
              }
            }
          }
        }

        // router bgp * / address-family vpnv4 *
        list vpnv4 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family vpnv6 *
        list vpnv6 {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            tailf:cli-diff-dependency "../../../../../ipv6/unicast-routing";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
              enum multicast {
                tailf:info "Address Family modifier";
              }
              enum flowspec {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family l2vpn *
        list l2vpn {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "vpls";
            type enumeration {
              enum evpn {
                tailf:info "Address Family modifier";
              }
              enum vpls {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family nsap *
        list nsap {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }

        // router bgp * / address-family rtfilter *
        list rtfilter {
          tailf:info "Address family";
          tailf:cli-mode-name "config-router-af";
          tailf:cli-delete-when-empty;
          tailf:cli-exit-command "exit-address-family" {
            tailf:info "Exit from Address Family configuration mode";
          }
          key af;
          leaf af {
            tailf:key-default "unicast";
            type enumeration {
              enum unicast {
                tailf:info "Address Family modifier";
              }
            }
          }
          uses router-bgp-af-grouping {
            refine "neighbor" {
              tailf:cli-diff-dependency "../../../neighbor";
            }
          }
        }
      }
    }

    /// router eigrp
    // router eigrp *
    container eigrp-virtual-instance {
      tailf:cli-drop-node-name;
      list eigrp {
        tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "../../../ip/routing" {
          tailf:cli-trigger-on-set;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;EIGRP Virtual-Instance Name";
            pattern "[A-Za-z]+.*";
          }
        }

        // router eigrp * / address-family
        container address-family {
          tailf:info "Enter Address Family command mode";

          // router eigrp * / address-family ipv4 unicast vrf *
          container ipv4-vrf {
            tailf:cli-drop-node-name;
            container ipv4 {
              tailf:info "Address family IPv4";
              container unicast {
                tailf:info "Address Family Unicast";
                list vrf {
                  tailf:info "Specify a specific virtual routing/forwarding "+
                    "instance";
                  tailf:cli-mode-name "config-router-af";
                  tailf:cli-sequence-commands;
                  tailf:cli-incomplete-command;
                  tailf:cli-exit-command "exit-address-family" {
                    tailf:info "Exit Address Family configuration mode";
                  }
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Virtual Routing/Forwarding instance name";
                    }
                  }
                  leaf autonomous-system {
                    tailf:info "Specify Address-Family Autonomous System Number";
                    tailf:cli-hide-in-submode;
                    tailf:cli-full-command;
                    type uint16 {
                      tailf:info "<1-65535>;;Autonomous System";
                      range "1..65535";
                    }
                  }
                  uses router-eigrp-af-virtual-instance-grouping;
                }
              }
            }
          }

          // router eigrp * / address-family ipv4
          container ipv4 {
            tailf:info "Address family IPv4";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            presence true;
            leaf af {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type enumeration {
                enum unicast {
                  tailf:info "Address Family Unicast";
                }
                enum multicast {
                  tailf:info "Address Family Multicast";
                }
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              tailf:cli-hide-in-submode;
              tailf:cli-remove-before-change;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }
            uses router-eigrp-af-virtual-instance-grouping;
          }

          // router eigrp * / address-family ipv6 unicast vrf *
          container ipv6-vrf {
            tailf:cli-drop-node-name;
            container ipv6 {
              tailf:info "Address family IPv6";
              container unicast {
                tailf:info "Address Family Unicast";
                list vrf {
                  tailf:info "Specify a specific virtual routing/forwarding "+
                    "instance";
                  tailf:cli-mode-name "config-router-af";
                  tailf:cli-sequence-commands;
                  tailf:cli-incomplete-command;
                  tailf:cli-exit-command "exit-address-family" {
                    tailf:info "Exit Address Family configuration mode";
                  }
                  key name;
                  leaf name {
                    tailf:cli-diff-dependency "../../../../../../../../../ip/vrf";
                    tailf:cli-diff-dependency "../../../../../../../../../vrf/definition";
                    type string {
                      tailf:info "WORD;;Virtual Routing/Forwarding instance name";
                    }
                  }
                  leaf autonomous-system {
                    tailf:info "Specify Address-Family Autonomous System Number";
                    tailf:cli-hide-in-submode;
                    tailf:cli-full-command;
                    type uint16 {
                      tailf:info "<1-65535>;;Autonomous System";
                      range "1..65535";
                    }
                  }
                  uses router-eigrp-af-virtual-instance-grouping;
                }
              }
            }
          }

          // router eigrp * / address-family ipv6
          container ipv6 {
            tailf:info "Address family IPv6";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            presence true;
            leaf af {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type enumeration {
                enum unicast {
                  tailf:info "Address Family Unicast";
                }
                enum multicast {
                  tailf:info "Address Family Multicast";
                }
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              tailf:cli-hide-in-submode;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }
            uses router-eigrp-af-virtual-instance-grouping;
          }
        }
      }
    }

    // router eigrp *
    list eigrp {
      tailf:info "Enhanced Interior Gateway Routing Protocol (EIGRP)";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key as-no;
      leaf as-no {
        type uint16 {
          tailf:info "<1-65535>;;Autonomous system number";
          range "1..65535";
        }
      }

      // router eigrp * / address-family ipv4 vrf *
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address Family IPv4";
          list vrf {
            tailf:info "Specify a specific virtual routing/forwarding "+
              "instance";
            tailf:cli-mode-name "config-router-af";
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit Address Family configuration mode";
            }
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              type string {
                tailf:info "WORD;;Virtual Routing/Forwarding instance name";
              }
            }
            leaf autonomous-system {
              tailf:info "Specify Address-Family Autonomous System Number";
              tailf:cli-hide-in-submode;
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Autonomous System";
                range "1..65535";
              }
            }

            // router eigrp * / address-family ipv4 vrf * / network *
            // router eigrp * / address-family ipv4 vrf * / eigrp
            uses router-eigrp-grouping;

            // router eigrp * / address-family ipv4 vrf * / redistribute
            // router eigrp * / address-family ipv4 vrf * / auto-summary
            uses router-eigrp-base-grouping;
          }
        }
      }

      // router eigrp * / network *
      // router eigrp * / eigrp
      uses router-eigrp-grouping;

      // router eigrp * / redistribute
      // router eigrp * / auto-summary
      uses router-eigrp-base-grouping;
    }

    /// router ospfv3
    // router ospfv3 *
    list ospfv3 {
      tailf:info "OSPFv3";
      tailf:cli-mode-name "config-router";
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }

      uses router-ospfv3-grouping;
      uses router-ospf-common-grouping;

      // router ospfv3 * / shutdown
      leaf shutdown {
        tailf:info "Shutdown the router process";
        type empty;
      }

      // router ospfv3 * / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";

        // router ospfv3 * / address-family ipv4 unicast
        container ipv4 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }

        // router ospfv3 * / address-family ipv6
        container ipv6 {
          tailf:info "Address family";
          container unicast {
            tailf:info "Address Family Modifier";
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            uses router-ospfv3-grouping;
            uses router-ospf-common-grouping;
            uses router-ospf-common-af-grouping;
            uses router-ospfv3-af-grouping;
          }
        }

        // router ospfv3 * / address-family ipv4 unicast vrf *
        container ipv4-vrf {
          tailf:cli-drop-node-name;
          container ipv4 {
            tailf:info "Address family";
            container unicast {
              tailf:info "Address Family Modifier";
              list vrf {
                tailf:info "Specify parameters for a VPN Routing/Forwarding "+
                  "instance";
                tailf:cli-mode-name "config-router-af";
                tailf:cli-full-command;
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit from Address Family configuration mode";
                }
                key name;
                leaf name {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;VPN Routing/Forwarding instance name";
                  }
                }
                uses router-ospfv3-grouping;
                uses router-ospf-common-grouping;
                uses router-ospf-common-af-grouping;
                uses router-ospfv3-af-grouping;
              }
            }
          }
        }

        // router ospfv3 * / address-family ipv6 unicast vrf *
        container ipv6-vrf {
          tailf:cli-drop-node-name;
          container ipv6 {
            tailf:info "Address family";
            container unicast {
              tailf:info "Address Family Modifier";
              list vrf {
                tailf:info "Specify parameters for a VPN Routing/Forwarding "+
                  "instance";
                tailf:cli-mode-name "config-router-af";
                tailf:cli-full-command;
                tailf:cli-exit-command "exit-address-family" {
                  tailf:info "Exit from Address Family configuration mode";
                }
                key name;
                leaf name {
                  tailf:cli-diff-dependency "../../../../../../../../ip/vrf";
                  tailf:cli-diff-dependency "../../../../../../../../vrf/definition";
                  type string {
                    tailf:info "WORD;;VPN Routing/Forwarding instance name";
                  }
                }
                uses router-ospfv3-grouping;
                uses router-ospf-common-grouping;
                uses router-ospf-common-af-grouping;
                uses router-ospfv3-af-grouping;
              }
            }
          }
        }
      }
    }

    /// router ospf
    // router ospf *
    list ospf {
      tailf:info "Open Shortest Path First (OSPF)";
      tailf:cli-mode-name "config-router";
      tailf:cli-sequence-commands;
      tailf:cli-diff-dependency "../../ip/routing" {
        tailf:cli-trigger-on-set;
      }
      key id;
      leaf id {
        tailf:cli-suppress-range;
        type uint16 {
          tailf:info "<1-65535>;;Process ID";
          range "1..65535";
        }
      }
      leaf vrf {
        tailf:info "VPN Routing/Forwarding Instance";
        tailf:cli-hide-in-submode;
        tailf:cli-full-command;
        tailf:cli-diff-dependency "../../../ip/vrf";
        tailf:cli-diff-dependency "../../../vrf/definition";
        type string {
          tailf:info "WORD;;VPN Routing/Forwarding Instance (VRF) name";
        }
      }
      uses router-ospf-common-grouping {
        refine "area" {
          tailf:cli-break-sequence-commands;
        }
      }
      uses router-ospf-common-af-grouping;
      uses router-ospf-grouping;
    }

    /// router isis
    // router isis
    container isis {
      tailf:info "ISO IS-IS";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "../../ip/routing";
      presence true;
      uses router-isis-grouping;
    }

    // router isis *
    container isis-container {
      tailf:cli-drop-node-name;
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-mode-name "config-router";
        tailf:cli-diff-dependency "../../../ip/routing";
        key area-tag;
        leaf area-tag {
          type string {
            tailf:info "WORD;;ISO routing area tag";
          }
        }
        uses router-isis-grouping;
      }
    }

    /// router rip
    // router rip
    container rip {
      tailf:info "Routing Information Protocol (RIP)";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;

      uses router-rip-grouping {
        refine "version" {
          tailf:cli-diff-dependency "../../../ip/routing" {
            tailf:cli-trigger-on-set;
          }
        }
      }

      // router rip / address-family
      container address-family {
        tailf:info "Enter Address Family command mode";
        container ipv4 {
          tailf:info "Address family";

          // router rip / address-family ipv4 unicast
          container unicast {
            tailf:cli-add-mode;
            tailf:cli-mode-name "config-router-af";
            tailf:info "Address Family Modifier";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "../../../../../ip/routing" {
              tailf:cli-trigger-on-set;
            }
            uses router-rip-grouping;
          }

          // router rip / address-family ipv4 vrf *
          list vrf {
            tailf:info "Specify parameters for a VPN Routing/Forwarding "+
              "instance";
            tailf:cli-mode-name "config-router-af";
            tailf:cli-full-command;
            tailf:cli-exit-command "exit-address-family" {
              tailf:info "Exit from Address Family configuration mode";
            }
            tailf:cli-diff-dependency "../../../../../ip/routing" {
              tailf:cli-trigger-on-set;
            }
            key name;
            leaf name {
              tailf:cli-diff-dependency "../../../../../../ip/vrf";
              tailf:cli-diff-dependency "../../../../../../vrf/definition";
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            uses router-rip-af-grouping;
          }
        }
      }
    }

    /// router lisp
    // router lisp
    container lisp {
      tailf:info "Locator/ID Separation Protocol";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router-lisp";
      tailf:cli-diff-dependency "../../interface";
      presence true;
      uses router-lisp-grouping {
        refine "eid-table/vrf/name" {
          tailf:cli-diff-dependency "../../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../../vrf/definition";
        }
        refine "site/authentication-key/secret" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router lisp<NL><*> site <site><NL><*> ::   authentication-key <PASSWORD>";
          }
        }
        refine "ipv4/etr/map-server/key/secret" {
          tailf:meta-data "secret-password" {
            tailf:meta-value "router lisp<NL><*> ::  ipv4 etr map-server <map-server> key <PASSWORD>";
          }
        }
      }
    }

    // router lisp *
    container router-lisp {
      tailf:cli-drop-node-name;
      list lisp {
        tailf:cli-mode-name "config-router-lisp";
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-15>;;router lisp ID";
            range "0..15";
          }
        }
        uses router-lisp-grouping {
          refine "eid-table/vrf/name" {
            tailf:cli-diff-dependency "../../../../../../ip/vrf";
            tailf:cli-diff-dependency "../../../../../../vrf/definition";
          }
        }
      }
    }

    /// router odr
    // router odr
    container odr {
      tailf:info "On Demand stub Routes";
      tailf:cli-add-mode;
      tailf:cli-mode-name "config-router";
      tailf:cli-full-command;
      presence true;
    }
  }


  /// ========================================================================
  /// vstack
  /// ========================================================================

  // vstack XXX
  container vstack-conf {
    tailf:cli-drop-node-name;
    container vstack {
      tailf:info "Configure vstack parameters";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;

      // vstack director
      leaf director {
        tailf:info "Configure director's IP address";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Director's IP Address";
        }
      }

      // vstack basic
      leaf basic {
        tailf:info "Enable vstack director";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  // no vstack
  container vstack-no {
    tailf:cli-drop-node-name;
    leaf vstack {
      tailf:info "Configure vstack parameters and enable or disable SmartInstall";
      tailf:cli-boolean-no;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// snmp
  /// ========================================================================

  container snmp {
    tailf:info "Modify non engine SNMP parameters";

    // snmp ifmib
    container ifmib {
      tailf:info "IF-MIB commands";

      // snmp ifmib ifindex
      container ifindex {
        tailf:info "ifindex persistence";
        leaf persist {
          tailf:info "Persist interface indices";
          type empty;
        }
      }

      // snmp ifmib ifalias long
      container ifalias {
        tailf:info "ifAlias description option, by default it is limited "+
          "to 64 character";
        leaf long {
          tailf:info "ifAlias description can be up to 256 characters";
          type empty;
        }
      }

      // snmp ifmib trap throttle
      container trap {
        tailf:info "IF-MIB trap options";
        leaf throttle {
          tailf:info "disable subinterface link down traps if main "+
            "interface is down";
          type empty;
        }
      }
    }

    // snmp mib
    container mib {
      tailf:info "MIB commands";

      // snmp mib bulkstat
      container bulkstat {
        tailf:info "Bulkstat Configuration commands";

        // snmp mib bulkstat object-list
        list object-list {
          tailf:info "Configure an Object List.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of object list";
            }
          }
        }
      }

      // snmp mib persist
      container persist {
        tailf:info "Persistence for MIBS";

        // snmp mib persist v3mibs
        leaf v3mibs {
          tailf:info "Persistence for v3 MIBS";
          type empty;
        }

        // snmp mib persist dsmib
        leaf dsmib {
          tailf:info "DiffServ MIB persistence";
          type empty;
        }

        // snmp mib persist cbqos
        leaf cbqos {
          tailf:info "CBQOS MIB index persistence";
          type empty;
        }

        // snmp mib persist circuit
        leaf circuit {
          tailf:info "Circuit MIB persistence";
          type empty;
        }
      }
    }
  }


  /// ========================================================================
  /// menu
  /// ========================================================================

  // menu * title
  list menu {
    tailf:info "Define a user-interface menu";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key name;
    leaf name {
      type string {
        tailf:info "WORD;;Name of this menu";
      }
    }

    // menu * title
    leaf title {
      tailf:info "Set menu title";
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "LINE;;Quoted text of title. Use \\r\\n for newline. "+
          "delimeter ^ is added automatically.";
      }
    }

    // menu * command *
    list command {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      key item;
      leaf item {
        type string {
          tailf:info "WORD;;Menu item number or character";
        }
      }
      leaf command {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "WORD;;Menu item number or character";
        }
      }
    }

    // menu * clear-screen
    leaf clear-screen {
      tailf:info "Use termcap database to clear screen";
      tailf:cli-full-command;
      type empty;
    }

    // menu * status-line
    leaf status-line {
      tailf:info "Display user status at top of screen";
      tailf:cli-full-command;
      type empty;
    }

    // menu * line-mode
    leaf line-mode {
      tailf:info "require <enter> after typing selection";
      tailf:cli-full-command;
      type empty;
    }

    // menu * single-space
    leaf single-space {
      tailf:info "single-space menu entries on display";
      tailf:cli-full-command;
      type empty;
    }
  }


  /// ========================================================================
  /// snmp-server
  /// ========================================================================

  container snmp-server {
    tailf:info "Modify SNMP engine parameters";

    // snmp-server user *
    list user {
      tailf:info "Define a user who can access the SNMP engine";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        tailf:cli-diff-dependency "../../engineID";
        type string {
          tailf:info "WORD;;Name of the user";
        }
      }
      leaf group {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "WORD;;Group to which the user belongs";
        }
      }

      // [remote]

      choice security-model {
        // snmp-server user * v1
        leaf v1 {
          tailf:info "user using the v1 security model";
          type empty;
        }
        // snmp-server user * v2c
        leaf v2c {
          tailf:info "user using the v2c security model";
          type empty;
        }
        // snmp-server user * v3 [encrypted] [auth {md5 | sha} auth-password]
        case v3 {
          leaf v3 {
            tailf:info "user using the v3 security model";
            type empty;
          }
          // snmp-server user * v3 encrypted
          leaf encrypted {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum encrypted {
                tailf:info "specifying passwords as MD5 or SHA digests";
              }
            }
            default encrypted;
          }
          leaf auth {
            tailf:info "authentication parameters for the user";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum md5 {
                tailf:info "Use HMAC MD5 algorithm for authentication";
              }
              enum sha {
                tailf:info "Use HMAC SHA algorithm for authentication";
              }
            }
          }
          leaf auth-password {
            when "../auth" {
              tailf:dependency "../auth";
            }
            tailf:cli-drop-node-name;
            tailf:meta-data "support-encrypted-password";
            type string {
              tailf:info "WORD;;authentication pasword for user";
            }
          }
          leaf priv {
            tailf:info "encryption parameters for the user";
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "3des" {
                tailf:info "Use 168 bit 3DES algorithm for encryption";
              }
              enum aes {
                tailf:info "Use AES algorithm for encryption";
              }
              enum des {
                tailf:info "Use 56 bit DES algorithm for encryption";
              }
            }
          }
          leaf bits {
            when "../priv = 'aes'" {
              tailf:dependency "../priv";
            }
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum "128" {
                tailf:info "128 bit keys.";
              }
              enum "192" {
                tailf:info "192 bit keys.";
              }
              enum "256" {
                tailf:info "256 bit keys.";
              }
            }
          }
          leaf priv-password {
            when "../priv" {
              tailf:dependency "../priv";
            }
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;privacy pasword for user";
            }
          }
        }
      }

      // snmp-server user * access
      container access {
        tailf:info "specify an access-list associated with this group";
        tailf:cli-flatten-container;
        choice access-choice {
          leaf access-list-std {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-99>;;Standard access list";
              range "1..99";
            }
          }
          leaf access-list-named {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Named access list";
            }
          }
          leaf ipv6 {
            tailf:info "Specify IPv6 Named Access-List";
            type string {
              tailf:info "WORD;;IPv6 Access-list name";
            }
          }
        }
      }
    }

    // snmp-server chassis-id
    leaf chassis-id {
      tailf:info "String to uniquely identify this chassis";
      tailf:cli-multi-value;
      type string {
        tailf:info "LINE;;Unique ID string";
      }
    }

    // snmp-server community *
    list community {
      tailf:info "Enable SNMP; set community string and access privs";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;SNMP community string";
        }
      }
      leaf view {
        tailf:info "Restrict this community to a named MIB view";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;MIB view to which this community has access";
        }
      }
      choice access-choice {
        leaf RO {
          tailf:info "Read-only access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf RW {
          tailf:info "Read-write access with this community string";
          tailf:cli-optional-in-sequence;
          type empty;
        }
      }
      leaf ipv6
      {
        tailf:info "Specify IPv6 Named Access-List";
        tailf:cli-optional-in-sequence;
        type string {
          tailf:info "WORD;;IPv6 Access-list name";
        }
      }
      leaf access-list-name {
        tailf:cli-drop-node-name;
        type std-ip-acl-type;
      }
    }

    // snmp-server contact
    leaf "contact" {
      tailf:info "Text for mib object sysContact";
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;identification of the contact person for this managed node";
      }
    }

    // snmp-server context *
    list context {
      tailf:info "Create/Delete a context apart from default";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Context Name";
        }
      }
    }

    // snmp-server drop
    container drop {
      tailf:info "Silently drop SNMP packets";
      leaf vrf-traffic {
        tailf:info "Silently drop SNMP packets that come on VRF interface";
        type empty;
      }
    }

    // snmp-server enable
    container enable {
      tailf:info "Enable SNMP Traps or Informs";
      choice enable-choice {

        // snmp-server enable informs
        leaf informs {
          tailf:info "Enable SNMP Informs";
          type empty;
        }

        // snmp-server enable traps *
        list traps {
          tailf:info "Enable SNMP Traps";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-full-command;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Trap name";
            }
          }
        }
      }
    }

    // snmp-server engine-id
    container engineID {
      tailf:info "Configure a local or remote SNMPv3 engineID";

      // snmp-server engineID local
      leaf local {
        tailf:info "engineID of the local agent";
        type string {
          tailf:info "WORD;;engine ID octet string";
          length "1..24";
        }
      }

      // snmp-server engineID remote *
      // FIXME: one entry per udp-port|vrf|udp-port&vrf can co-exist.
      list remote {
        tailf:info "engineID of the remote agent";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key address;
        leaf address {
          type inet:host {
            tailf:info "Hostname, A.B.C.D or X:X:X:X::X;;Remote address";
          }
        }
        leaf udp-port {
          tailf:info "The remote notification host's UDP port number";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<0-65535>;;The remote notification host's "+
              "UDP port number";
          }
        }
        leaf vrf {
          tailf:info "The remote notification host's VPN routing instance";
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        leaf engineid-string {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
      }
    }

    // snmp-server group *
    list group {
      tailf:info "Define a User Security Model group";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key id;
      leaf id {
        type string {
          tailf:info "WORD;;Name of the group";
        }
      }
      choice security-model {
        leaf v1 {
          tailf:info "group using the v1 security model";
          type empty;
        }
        leaf v2c {
          tailf:info "group using the v2c security model";
          type empty;
        }
        container v3 {
          tailf:info "group using the User Security Model (SNMPv3)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf security-level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum auth {
                tailf:info "group using the authNoPriv Security Level";
              }
              enum noauth {
                tailf:info "group using the noAuthNoPriv Security Level";
              }
              enum priv {
                tailf:info "group using SNMPv3 authPriv security level";
              }
            }
          }
          leaf context {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a context to associate these views for the "
              +"group";
            type string {
              tailf:info "WORD;;context name";
            }
          }
          leaf match {
            tailf:cli-optional-in-sequence;
            tailf:info "context name match criteria";
            type enumeration {
              enum exact {
                tailf:info "match the exact context";
              }
              enum prefix {
                tailf:info "only match the context prefix";
              }
            }
          }
          leaf read {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a read view for the group";
            type string {
              tailf:info "WORD;;read view name";
            }
          }
          leaf write {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a write view for the group";
            type string {
              tailf:info "WORD;;write view name";
            }
          }
          leaf notify {
            tailf:cli-optional-in-sequence;
            tailf:info "specify a notify view for the group";
            type string {
              tailf:info "WORD;;notify view name";
            }
          }
          leaf access {
            tailf:info "specify an access-list associated with this group";
            type empty;
          }
          leaf ipv6 {
            when "../access" {
              tailf:dependency "../access";
            }
            tailf:info "Specify IPv6 Named Access-List";
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;IPv6 Access-list name";
            }
          }
          leaf acl {
            when "../access" {
              tailf:dependency "../access";
            }
            tailf:cli-drop-node-name;
            type union {
              type uint8 {
                tailf:info "<1-99>;;Std IP accesslist allowing access with "
                  +"this group";
                range "1..99";
              }
              type string {
                tailf:info "WORD;;Access-list name";
              }
            }
          }
        }
      }
    }

    // snmp-server host *
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key ip-address;
      leaf ip-address {
        tailf:cli-disallow-value "vrf";
        tailf:cli-case-sensitive;
        type inet:host {
          tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP"+
            " notification host";
        }
      }
      uses snmp-server-host-grouping;
    }

    // snmp-server host * vrf *
    container host-vrf {
      tailf:cli-drop-node-name;
      list host {
        tailf:info "Specify hosts to receive SNMP notifications";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-incomplete-command;
        key "ip-address vrf";
        leaf ip-address {
          tailf:cli-case-sensitive;
          type inet:host {
            tailf:info "WORD;;Hostname or IP/IPv6 address of SNMP"+
              " notification host";
          }
        }
        leaf vrf {
          tailf:info "VPN Routing instance for this host";
          tailf:cli-expose-key-name;
          tailf:cli-diff-dependency "../../../../ip/vrf";
          tailf:cli-diff-dependency "../../../../vrf/definition";
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
        uses snmp-server-host-grouping;
      }
    }

    // snmp-server ip
    container ip {
      tailf:info "IP ToS configuration for SNMP traffic";

      // snmp-server ip dscp
      leaf dscp {
        tailf:info "IP DSCP value for SNMP traffic";
        type uint8 {
          tailf:info "<0-63>;;ip dscp value (default value 0 )";
          range "0..63";
        }
      }

      // snmp-server ip precedence
      leaf precedence  {
        tailf:info "IP Precedence value for SNMP traffic";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;ip precedence value (default value 0)";
          range "0..7";
        }
      }
    }

    // snmp-server ifindex
    container ifindex {
      tailf:info "Enable ifindex persistence";
      leaf persist {
        tailf:info "Persist interface indices";
        type empty;
      }
    }

    // snmp-server location
    leaf location {
      tailf:info "Text for mib object sysLocation";
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;The physical location of this node";
      }
    }

    // snmp-server manager
    container manager {
      tailf:info "Modify SNMP manager parameters";
      tailf:cli-display-separated;
      presence true;
      leaf session-timeout {
        tailf:info "Timeout value for destroying sessions";
        type uint32 {
          tailf:info "<10-2147483>;;seconds";
          range "10..2147483";
        }
      }
    }

    // snmp-server packetsize
    leaf packetsize {
      tailf:info "Largest SNMP packet size";
      type uint16 {
        tailf:info "<484-17940>;;Packet size";
        range "484..17940";
      }
    }

    // snmp-server queue-length
    leaf queue-length {
      tailf:info "Message queue length for each TRAP host";
      type uint16 {
        tailf:info "<1-5000>;;Queue length (default 10)";
        range "1..5000";
      }
    }

    // snmp-server queue-limit notification-host
    container queue-limit {
      tailf:info "Message queue size for different queues";
      leaf notification-host {
        tailf:info "Message queue length for each notification host";
        type uint16 {
          tailf:info "<1-5000>;;notification host queue length";
          range "1..5000";
        }
      }
    }

    // snmp-server tftp-server-list
    leaf tftp-server-list {
      tailf:info "Limit TFTP servers used via SNMP";
      tailf:cli-full-command;
      type std-acl-type;
    }

    // snmp-server system-shutdown
    leaf system-shutdown {
      tailf:info "Enable use of the SNMP reload command";
      type empty;
    }

    // snmp-server file-transfer access-group *
    container file-transfer {
      tailf:info "File transfer related commands";
      list access-group {
        tailf:info "Access control for file transfers";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type std-ip-acl-type;
        }

        // snmp-server file-transfer access-group * protocol *
        leaf-list protocol {
          tailf:info "protocol options";
          tailf:cli-list-syntax;
          type enumeration {
            enum ftp {
              tailf:info "Configure acl for ftp transfer protocol";
            }
            enum rcp {
              tailf:info "Configure acl for rcp transfer protocol";
            }
            enum scp {
              tailf:info "Configure acl for scp transfer protocol";
            }
            enum sftp {
              tailf:info "Configure acl for sftp transfer protocol";
            }
            enum tftp {
              tailf:info "Configure acl for tftp transfer protocol";
            }
          }
        }
      }
    }

    // snmp-server source-interface
    container source-interface {
      tailf:info "Assign an source interface";
      container informs {
        tailf:info "source interface for informs";
        uses interface-name-grouping;
      }
      container traps {
        tailf:info "source interface for traps";
        uses interface-name-grouping;
      }
    }

    // snmp-server trap
    container trap {
      tailf:info "SNMP trap options";

      // snmp-server trap timeout
      leaf timeout {
        tailf:info "Set timeout for TRAP message retransmissions";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-1000>;;Timeout (default 30 seconds)";
          range "1..1000";
        }
        default 30;
      }

      // no snmp-server trap authentication unknown-context
      container authentication  {
        tailf:info "fine-tune enable/disable of authentication traps";
        leaf unknown-context {
          tailf:info "enable authentication traps for unknown context error";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }

    // no snmp-server sparse-tables
    leaf sparse-tables {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // snmp-server trap-source
    container trap-source {
      tailf:info "Assign an interface for the source address of all traps";
      uses interface-name-grouping;
    }

    // snmp-server trap-timeout
    leaf trap-timeout {
      tailf:info "Set timeout for TRAP message retransmissions";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-1000>;;Timeout (default 30 seconds)";
      }
    }

    // snmp-server view *
    list view {
      tailf:info "Define an SNMPv2 MIB view";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key "name mib";
      leaf name {
        type string {
          tailf:info "WORD;;Name of the view";
        }
      }
      leaf mib {
        type string {
          tailf:info "WORD;;MIB view family name";
        }
      }
      leaf inc-exl {
        tailf:cli-drop-node-name;
        type enumeration {
          enum excluded {
            tailf:info "MIB family is excluded from the view";
          }
          enum included {
            tailf:info "MIB family is included in the view";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// rtr
  /// ========================================================================

  container rtr {
    tailf:info "RTR Base Configuration";

    // rtr responder
    container responder {
      tailf:info "Enable RTR Responder";
      presence true;
    }
  }


  /// ========================================================================
  /// ipc
  /// ========================================================================

  container ipc {
    tailf:info "Configure IPC system";
    container zone {
      tailf:info "Configure an IPC Zone";

      // ipc zone default
      container "default" {
        tailf:info "Configure the default zone";
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-ipczone";
        presence true;
      }
    }
  }


  /// ========================================================================
  /// cts
  /// ========================================================================

  container cts {
    tailf:info "Cisco Trusted Security commands";
    container logging {
      tailf:info "Set logging parameters";
      leaf verbose {
        tailf:info "Show verbose messages in system logs";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// license
  /// ========================================================================

  container license {
    tailf:info "Configure license features";

    // license accept end user agreement
    container accept {
      tailf:info "Accept all further License Agreements";
      container end {
        tailf:info "Accept all further License Agreements";
        container user {
          tailf:info "Accept all further License Agreements";
          leaf agreement {
            tailf:info "Accept all further License Agreements";
            type empty;
          }
        }
      }
    }

    // license feature *
    list "feature" {
      tailf:info "License features";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;License line";
        }
      }
    }

    // license boot *
    list boot {
      tailf:info "license boot config commands";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      ordered-by user;
      key line;
      leaf line {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;License line";
        }
      }
    }

    // license smart enable
    container smart {
      tailf:info "Smart licensing";
      leaf enable {
        tailf:info "Enable Smart Licensing";
        type empty;
      }
    }
  }


  /// ========================================================================
  /// setup
  /// ========================================================================

  container setup {
    tailf:info "Configure setup options";

    // no setup express
    leaf express {
      tailf:info "Configure whether express setup mode is enabled";
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// trunk
  /// ========================================================================

  container trunk {
    tailf:info "Global trunk configuration";

    // trunk group *
    list group {
      tailf:info "Specify a trunk group";
      tailf:cli-mode-name "config-trunk-group";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Trunk group label";
        }
      }

      // trunk group * / hunt-scheme
      container hunt-scheme {
        tailf:info "The hunt scheme in trunk group";
        choice hunt-scheme-choice {
          container round-robin {
            tailf:info "The next interface with free timeslots is selected";
            tailf:cli-compact-syntax;
            tailf:cli-delete-when-empty;
            presence true;
          }
          leaf random {
            tailf:info "The timeslot is selected randomly";
            type empty;
          }
          leaf sequential {
            type empty;
          }
        }
      }
    }

  }


  /// ========================================================================
  /// gw-accounting
  /// ========================================================================

  container gw-accounting {

    choice gw-accounting-choice {

      // gw-accounting syslog
      container syslog {
        tailf:info "Enable voip syslog accounting.";
        tailf:cli-delete-when-empty;
        presence true;
        // gw-accounting syslog stats
        leaf stats {
          tailf:info "Enable stats as part of accounting.";
          type empty;
        }
      }

      // gw-accounting aaa
      leaf aaa {
        tailf:info "Enable aaa accounting";
        type empty;
      }

      // gw-accounting file
      leaf file {
        tailf:info "Enable voip file accounting.";
        type empty;
      }

      // gw-accounting h323
      container h323 {
        tailf:cli-delete-when-empty;
        presence true;
        leaf vsa {
          type empty;
        }
      }

      // gw-accounting voip
      leaf voip {
        type empty;
      }
    }

  }


  /// ========================================================================
  /// voice-card
  /// ========================================================================

  // voice-card *
  list voice-card {
    tailf:info "Configure a specific voice-card";
    tailf:cli-mode-name "config-voicecard";
    key slot;
    leaf slot {
      type string {
        tailf:info "WORD;;Voice interface slot/abay";
        pattern '[0-9]+.*';
      }
    }

    // voice-card * / dspfarm
    leaf dspfarm {
      tailf:info "Enable dspFarm feature for this voice card";
      type empty;
    }

    // voice-card * / no watchdog
    leaf watchdog {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }
  }


  /// ========================================================================
  /// voice
  /// ========================================================================

  container voice {
    tailf:info "Global voice configuration";

    // voice service
    container service {
      tailf:info "Global packet telephony service commands";

      // voice service voip
      container voip {
        tailf:info "Voice over IP";
        tailf:cli-add-mode;
        tailf:cli-mode-name "conf-voi-serv";

        // voice service voip / sip
        container sip {
          tailf:info "SIP configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name "conf-serv-sip";
          tailf:cli-delete-when-empty;
          presence true;
          container bind {
            tailf:info "SIP bind command";
            container control {
              tailf:info "bind only SIP control packets";
              // voice service voip / sip / bind control source-interface
              container source-interface {
                tailf:info "Specify interface for source address of "+
                  "SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }
            container media {
              tailf:info "bind only SIP media packets";
              // voice service voip / sip / bind media source-interface
              container source-interface {
                tailf:info "Specify interface for source address of "+
                  "SIP packets";
                tailf:cli-compact-syntax;
                uses interface-name-grouping;
              }
            }
          }
        }
      }
    }

    // voice iec syslog
    container iec {
      tailf:info "Configure Internal Error Code behavior";
      leaf syslog {
        tailf:info "Enable syslog reporting whenever an IEC is triggered";
        type empty;
      }
    }

    // voice translation-rule *
    list translation-rule {
      tailf:info "Translation Rule configuration commands";
      tailf:cli-mode-name "cfg-translation-rule";
      key tag;
      leaf tag {
        type uint32 {
          tailf:info "<1-2147483647>;;Translation rule tag";
          range "1..2147483647";
        }
      }

      // voice translation-rule * / rule *
      list rule {
        tailf:info "Translation rule";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        ordered-by user;
        key tag;
        leaf tag {
          type uint8 {
            tailf:info "<1-15>;;Translation rule tag";
            range "1..15";
          }
        }
        leaf reject {
          tailf:info "Call block rule";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf "pattern" {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;Matching pattern";
          }
        }
      }
    }

    // voice translation-profile *
    list translation-profile {
      tailf:info "Translation profile configuration commands";
      tailf:cli-mode-name "cfg-translation-profile";
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Translation profile name";
        }
      }

      // voice translation-profile * / translate
      container translate {
        tailf:info "Specify numbers that should be translated";

        // voice translation-profile * / translate called *
        list called {
          tailf:info "Translation rule for the called-number";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key tag;
          leaf tag {
            type uint32 {
              tailf:info "<1-2147483647>;;Translation rule tag";
              range "1..2147483647";
            }
          }
        }
      }
    }

  }


  /// ========================================================================
  /// event
  /// ========================================================================

  container event {
    tailf:info "Event related configuration commands";

    // event manager
    container manager {
      tailf:info "Event Manager configuration commands";

      // event manager environment *
      list environment {
        tailf:info "Set an Embedded Event Manager global environment variable";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the global environment variable";
          }
        }
        leaf "value" {
          tailf:cli-multi-value;
          tailf:cli-drop-node-name;
          type string {
            tailf:info "LINE;;Value of the global environment variable";
          }
        }
      }

      // event manager session cli username
      container session {
        tailf:info "Set Embedded Event Manager session attributes";
        container cli {
          tailf:info "Set Embedded Event Manager session cli attributes";
          leaf username {
            tailf:info "Set username used in Embedded Event Manager "+
              "cli sessions";
            type string {
              tailf:info "WORD;;username";
            }
          }
        }
      }

      // event manager directory
      container directory {
        tailf:info "Set Embedded Event Manager directory information";
        container user {
          tailf:info "Set Embedded Event Manager user directory information";
          leaf policy {
            tailf:info "Set Embedded Event Manager user policy directory";
            type string {
              tailf:info "WORD;;Path of the Embedded Event Manager user "+
                "policy directory";
            }
          }
        }
      }

      // event manager applet *
      list applet {
        tailf:info "Register an Event Manager applet";
        tailf:cli-mode-name "config-applet";
        tailf:cli-exit-command "exit" {
          tailf:info "Exit from Event Manager applet configuration submode";
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Event Manager applet";
          }
        }

        // event manager applet * / description
        leaf "description" {
          tailf:info "Add or modify an applet description";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;description";
          }
        }

        // event manager applet * / authorization
        leaf authorization  {
          tailf:info "Specify an authorization type for the applet";
          tailf:cli-hide-in-submode;
          type enumeration {
            enum bypass {
              tailf:info "EEM aaa authorization type bypass";
            }
          }
        }

        // event manager applet * / class
        leaf class {
          tailf:info "Specify a class for the applet";
          tailf:cli-hide-in-submode;
          type string {
            tailf:info "Class A-Z | default - default class";
            pattern "[A-Z]|default";
          }
        }

        // event manager applet * / trap
        leaf trap {
          tailf:info "Generate an SNMP trap when applet is triggered.";
          tailf:cli-hide-in-submode;
          type empty;
        }

        // event manager applet * / event
        container event {
          tailf:info "Add or modify event information";
          uses event-manager-applet-event-grouping;

          // event manager applet * / event tag *
          list tag {
            tailf:info "event tag identifier";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;tag name";
              }
            }
            uses event-manager-applet-event-grouping;
          }
        }

        // event manager applet * / action *
        list action {
          tailf:info "Add or modify an action statement";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          ordered-by user;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Label";
            }
          }

          choice action-choice {
            // event manager applet * / action * cli
            container cli {
              tailf:info "Execute a CLI command";
              tailf:cli-compact-syntax;
              leaf command {
                tailf:info "CLI command";
                type string {
                  tailf:info "WORD;;CLI string";
                }
              }
              leaf "pattern" {
                tailf:info "response pattern";
                type string {
                  tailf:info "WORD;;pattern";
                }
              }
            }

            // event manager applet * / action * regexp
            leaf regexp {
              tailf:info "regular expression match";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;regular expression pattern";
              }
            }

            // event manager applet * / action * wait
            leaf wait {
              tailf:info "Wait for a specified amount of time";
              type uint32 {
                tailf:info "<1-31536000>;;Seconds value";
                range "1..31536000";
              }
            }

            // event manager applet * / action * syslog
            container syslog {
              tailf:info "Log a syslog message";
              tailf:cli-compact-syntax;

              // event manager applet * / action * syslog priority
              leaf priority {
                tailf:info "Priority of syslog message";
                type logging-level-type;
              }

              // event manager applet * / action * syslog msg
              leaf msg {
                tailf:info "Syslog message";
                type string {
                  tailf:info "WORD;;message string";
                }
              }

              // event manager applet * / action * syslog facility
              leaf facility {
                tailf:info "Facility string";
                type string {
                  tailf:info "WORD;;facility string";
                }
              }

              // event manager applet * / action * syslog filter
              leaf filter {
                tailf:info "Filter destination of syslog message";
                type enumeration {
                  enum esm {
                    tailf:info "Filter destination is ESM";
                  }
                }
              }
            }

            // event manager applet * / action * snmp-trap
            container snmp-trap {
              tailf:info "Send an SNMP trap";
              tailf:cli-compact-syntax;
              leaf intdata1 {
                tailf:info "SNMP integer data1";
                type int32 {
                  tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer value1";
                }
              }
              leaf intdata2 {
                tailf:info "SNMP integer data2";
                type int32 {
                  tailf:info "<-2147483648 - 2147483647>;;SNMP trap integer value2";
                }
              }
              leaf strdata {
                tailf:info "SNMP trap string";
                type string {
                  tailf:info "WORD;;SNMP trap string value";
                }
              }
            }

            // GENERIC DEFAULT
            // event manager applet * / action * ?
            leaf cmd {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              //note: tailf:cli-preformatted; - removes "".
              type string {
                tailf:info "Action string within quotes";
              }
            }
          }
        }

        // event manager applet * / trigger
        container trigger {
          tailf:info "Enter applet trigger configuration submode";
          tailf:cli-add-mode;
          tailf:cli-mode-name "config-applet-trigger";
          presence true;

          // event manager applet * / trigger / correlate
          container correlate {
            tailf:info "event correlation statement";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf event {
              tailf:info "event for correlation";
              type string {
                tailf:info "WORD;;event tag value";
              }
            }
            leaf operand2 {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum and {
                  tailf:info "Use boolean and logic";
                }
                enum andnot {
                  tailf:info "Use boolean andnot logic";
                }
                enum or {
                  tailf:info "Use boolean or logic";
                }
              }
            }
            container event2 {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              leaf event {
                tailf:info "event2 for correlation";
                type string {
                  tailf:info "WORD;;event tag value";
                }
              }
            }
          }
        }
      }

      // event manager policy *
      list policy {
        tailf:info "Run a pre-registered policy";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the Embedded Event Manager policy file";
          }
        }
        leaf "type" {
          tailf:info "Type of Embedded Event Manager policy";
          type enumeration {
            enum system {
              tailf:info "Search for a Embedded Event Manager system policy";
            }
            enum user {
              tailf:info "Search for a Embedded Event Manager user policy";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// disable-eadi
  /// ========================================================================

  leaf disable-eadi {
    tailf:cli-full-command;
    type empty;
  }


  /// ========================================================================
  /// memory-size
  /// ========================================================================

  container memory-size {
    tailf:info "Adjust memory size by percentage";

    // memory-size iomem
    leaf iomem {
      tailf:info "I/O memory";
      type uint8 {
        tailf:info "<5-25>;;percentage of DRAM to use for I/O memory: "+
          "5, 10, 15, 20, 25";
        range "5..25" {
          tailf:step 5;
        }
      }
    }
  }


  /// ========================================================================
  /// memory
  /// ========================================================================

  container memory {
    tailf:info "Configure memory management";

    // memory free low-watermark
    container free {
      tailf:info "free memory low water mark";
      container low-watermark {
        tailf:info "low water mark for notifications";

        // memory free low-watermark processor
        leaf processor {
          tailf:info "Processor memory";
          type uint32 {
            tailf:info "<1-3994575>;;low water mark of memory in KB";
          }
        }
      }
    }
  }


  /// ========================================================================
  /// transceiver
  /// ========================================================================

  container transceiver {
    tailf:info "Select from transceiver configuration commands";
    container "type" {
      tailf:info "type keyword";

      // transceiver type all
      container all {
        tailf:cli-add-mode;
        tailf:cli-mode-name "config-xcvr-type";
        tailf:cli-full-command;

        // transceiver type all / monitoring
        container monitoring {
          tailf:info "Enable/disable monitoring";
          presence true;
          leaf interval {
            tailf:info "Set interval for monitoring";
            type uint16 {
              tailf:info "<300-3600>;;Time interval for monitoring "+
                "transceiver in seconds";
              range "300..3600";
            }
          }
        }
      }
    }
  }


  /// ========================================================================
  /// alias
  /// ========================================================================

  list alias {
    tailf:info "Create command alias";
    tailf:cli-suppress-mode;
    tailf:cli-delete-when-empty;
    key "mode name";
    leaf mode {
      type string {
        tailf:info "WORD;;;Alias mode";
      }
    }
    leaf name {
      type string {
        tailf:info "WORD;;Alias name";
      }
    }
    leaf line {
      tailf:cli-drop-node-name;
      tailf:cli-multi-value;
      tailf:cli-no-value-on-delete;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;alias line";
      }
    }
  }


  /// ========================================================================
  /// spd
  /// ========================================================================

  container spd {
    // no spd enable
    leaf enable {
      tailf:cli-boolean-no;
      tailf:cli-full-command;
      type boolean;
      default true;
    }

    // spd headroom
    leaf headroom {
      type uint16 {
      }
    }
  }


  /// ========================================================================
  /// cached-show
  /// ========================================================================
  /// Cached output of exec command show

  container cached-show {

    // show version
    container version {
      tailf:info "Cached output of 'show version' on device";
      leaf version {
        type string;
      }
      leaf model {
        type string;
      }
      container license {
        leaf level {
          type string;
        }
        leaf "type" {
          type string;
        }
      }
    }

    // show license udi
    container license {
      tailf:info "Cached output of 'show license udi' on device";
      container udi {
        leaf pid {
          type string;
        }
        leaf sn {
          type string;
        }
      }
    }

    // show inventory
    list inventory {
      tailf:info "Cached output of 'show inventory' on device";
      tailf:cli-suppress-mode;
      key name;
      leaf name {
        tailf:cli-expose-key-name;
        type string;
      }
      leaf sn {
        type string;
      }
    }
  }




  /// ========================================================================
  /// xxyyzztop
  /// ========================================================================

  leaf xxyyzztop {
    tailf:info "Internal state variable, do not modify.";
    tailf:cli-run-template "";
    tailf:cli-show-with-default;
    type uint16;
    default "0";
  }

  // debug trick to fail last in transaction, do not set
  leaf xxyyzzfail {
    type empty;
  }

  /// ========================================================================
  //                          EOF
  /// ========================================================================
}
